#ifdef HAVE_JPEGLIB


#include <stdio.h>
#include <stdlib.h>
#include <string.h>

#include <setjmp.h>
#include <math.h>


#include "Image.h"
#include "ImageInternal.h"


#ifdef HAVE_IJG_EXTENSIONS
#include "cdjpeg.h"
#include "jcthresh.h"
#endif

#include "jpeglib.h"

#include <ctype.h>     /* to declare isdigit(), isspace() */

/* 
 * ZigZagCoefOrder[i] is the zigzag-order position of the i'th element
 * of a DCT block read in natural order (left to right, top to bottom).
 */

const int ZigZagCoefOrder[DCTSIZE2] = {
   0,  1,  5,  6, 14, 15, 27, 28,
   2,  4,  7, 13, 16, 26, 29, 42,
   3,  8, 12, 17, 25, 30, 41, 43,
   9, 11, 18, 24, 31, 40, 44, 53,
  10, 19, 23, 32, 39, 45, 52, 54,
  20, 22, 33, 38, 46, 51, 55, 60,
  21, 34, 37, 47, 50, 56, 59, 61,
  35, 36, 48, 49, 57, 58, 62, 63
};

static int
blankline(char *s)
{
  while (*s != '\0') {
    if (!isspace((int)*s)) return 0;
    s++; 
  }
  return 1;
}

static void GetScanBreaks(float *bpp, int numACscans, int *ACscanBreaks)
{ 
  float bppspan, bppincr, currbpp;
  int lastcoeff, s; 

  bppspan = bpp[63] - bpp[0];
  bppincr = bppspan/((float) numACscans);
  lastcoeff = 0;

  for (s=1;s<=numACscans;s++) {
      if (s==numACscans) lastcoeff = 63;
      else {
        lastcoeff++;
        currbpp = bpp[0] + (((float) s)*bppincr);
        while ((lastcoeff < (64 - numACscans + s)) &&
	     (bpp[lastcoeff] < currbpp)) {
	  lastcoeff++;
        }
      }
      ACscanBreaks[s] = lastcoeff; 
  }
}

#define IMUTILS_STRLENMAX 400

#ifndef MAXCOMPS
#define MAXCOMPS 4 
#endif
#define MAXSCANS 2000

static jpeg_scan_info SavedScanInfo[MAXSCANS];

static int
read_qtabinfo (j_compress_ptr cinfo, void *src, long src_bytes, int src_kind)
/* 
 * Also reads bpp-psnr distribution (generated by RD-OPT) and creates
 * a progressive scan sequence. 
 */ 
{
  DataSrc dsrc, *ds = &dsrc; 
  int tblno, i, j, n, distno; 
  
  unsigned int table[DCTSIZE2];
  char nextline[IMUTILS_STRLENMAX]; 
  char *nextchar; 
  int ret, eof_reached; 

  #ifdef HAVE_IJG_EXTENSIONS
  int th_tblno = 0; 
  
  static const float aanscalefactor[8] = {
            1.0, 1.387039845, 1.306562965, 1.175875602,
            1.0, 0.785694958, 0.541196100, 0.275899379
          };
  #endif

  #define numBaseScans  5 
  #define numNonBaseScans  2 
  
  int defBaseScanSe[numBaseScans+1] = {0, 2, 5, 9, 32, 63}; 
  int defNonBaseScanSe[numNonBaseScans+1] = {0, 10, 63}; 

  float bpp[MAXCOMPS][64], tpsnr, trmse; 
  int ntemp,ntemp1,ntemp2;
  int ScanBreaks[MAXCOMPS][MAXSCANS]; 
  jpeg_scan_info *scanptr; 
  int scanno = 0; 

  tblno = 0;
  distno = 0;

  if (!src) goto no_qsrc; 

  DS_Init(ds, 0);
  if (src_kind == DS_KIND_FILE || src_kind == DS_KIND_WEB) { 
    if (!DS_OpenFile(ds, (char *) src, src_bytes)) return 0; 
  } else if (src && (src_kind == DS_KIND_FD)) { 
    if (!DS_OpenFd(ds, *((int *) src), src_bytes)) return 0; 
  } else if (src_kind == DS_KIND_MEMORY) { 
    if (!DS_OpenMemory(ds, (char *) src, src_bytes)) return 0; 
  } else if (src_kind == DS_KIND_STREAM) { 
    if (!DS_OpenStream(ds, (FILE *) src, src_bytes)) return 0; 
  } else return 0; 

  while ((ret = DS_ReadLine(ds, nextline, IMUTILS_STRLENMAX)) != 0) {
    if (blankline(nextline)) continue;
    else if ((!strncmp(nextline,"#D",2)) && (distno < MAXCOMPS)) {
      /* read distribution */ 
      i = 0; eof_reached = 0; 
      while ((i < 64) && !eof_reached) {
        sscanf(nextline+2,"%d%f%f%f", &ntemp,&bpp[distno][i],
	   &trmse, &tpsnr);
        i++; 
	if (i == 64) break; 
        while ((ret =DS_ReadLine(ds,nextline,IMUTILS_STRLENMAX)) != 0) {
          if (blankline(nextline)) {
	      continue;
          } else if (!strncmp(nextline,"#END",4)) {
	      eof_reached = 1; 
              break; 
          } else if (!strncmp(nextline,"#D",2)) {
              break; 
          } else {
	      continue; 
          }
        } 
	if (!ret) eof_reached = 1; 
      }
      if (eof_reached) {
	DS_Close(ds);
	return 0; 
      }
      distno++; 
    } else if (!strncmp(nextline,"#END",4)) {
      break; 
    #ifdef HAVE_IJG_EXTENSIONS
    } else if (!strncmp(nextline,"#T",2)) {
      /* read thresh table */ 
      nextchar = nextline + 3;
      i = 0; eof_reached = 0; 
      while ((i < 64) && !eof_reached) {
	if (sscanf(nextchar,"%f",&jc_thresh_table[th_tblno][i]) == 1) {
	  i++;
	  while (isspace((int)*nextchar)) nextchar++; 
	  while ((*nextchar !='\0') && !isspace((int)*nextchar)) nextchar++; 
	} else {
          while ((ret =DS_ReadLine(ds,nextline,IMUTILS_STRLENMAX))!=0) {
            if (blankline(nextline)) {
	      continue;
            } else if (!strncmp(nextline,"#END",4)) {
	      eof_reached = 1; 
              break; 
            } else if (!strncmp(nextline,"#T",2)) {
	      nextchar = nextline + 3; 
	      break; 
            } else if (!strncmp(nextline,"#",1)) {
              continue; 
            } else { 
	      eof_reached = 1; /* bad format */ 
	      break; 
	    }
          } 
	  if (!ret) eof_reached = 1; 
	} 
      }
      if (i != 64) {
	DS_Close(ds); 
	return(0); 
      }

      n=0;
      for (i=0;i<8;i++) {
        for (j=0;j<8;j++) {
          jc_thresh_table[th_tblno][n++]
	    *= (aanscalefactor[i]*aanscalefactor[j]*8.0);
      } }

      th_tblno++;

    #endif
    } else if (!strncmp(nextline,"#",1)) {
      continue; 
    } else if (tblno < MAXCOMPS) { 
      /* read q table */ 
      i = 0; eof_reached = 0; 
      nextchar = nextline; 
      while ((i < 64) && !eof_reached) {
	if (sscanf(nextchar,"%u",&table[ZigZagCoefOrder[i]]) == 1) {
	  i++;
	  while (isspace((int)*nextchar)) nextchar++; 
	  while (isdigit((int)*nextchar)) nextchar++; 
	} else {
          while ((ret =DS_ReadLine(ds,nextline,IMUTILS_STRLENMAX))!=0) {
            if (blankline(nextline)) {
	      continue;
            } else if (!strncmp(nextline,"#END",4)) {
	      eof_reached = 1; 
              break; 
            } else if (!strncmp(nextline,"#",1)) {
              continue; 
            } else {
	      nextchar = nextline; 
	      break; 
	    }
          } 
	  if (!ret) eof_reached = 1; 
	} 
      } 
      if (eof_reached) {
        DS_Close(ds);
        return 0; 
      } 
      jpeg_add_quant_table(cinfo, tblno, table, 100, 0); 
      tblno++;
    } 
  } 
  DS_Close(ds); 
  
  no_qsrc:

  #ifdef HAVE_IJG_EXTENSIONS
  if ((jc_num_thresh_tables = th_tblno) > 0) jc_do_thresh = TRUE; 
  #endif

  if (tblno > 0) { 
    cinfo->comp_info[0].quant_tbl_no = 0; 
    cinfo->comp_info[1].quant_tbl_no = 0; 
    cinfo->comp_info[2].quant_tbl_no = 0; 
  } 
  if (tblno > 1) { 
    cinfo->comp_info[1].quant_tbl_no = 1; 
    cinfo->comp_info[2].quant_tbl_no = 1; 
  } 
  if (tblno > 2) { 
    cinfo->comp_info[2].quant_tbl_no = 2; 
  } 

  if (cinfo->scan_info) return 1;

  /* figure out a scan script */ 
  if (cinfo->input_components == 1) { 
    scanno = 0;
    scanptr = SavedScanInfo; 

    scanptr->component_index[0] = 0; 
    scanptr->comps_in_scan = 1; 
    scanptr->Ss = 0; 
    scanptr->Se = 0; 
    scanptr->Ah = 0; 
    scanptr->Al = 0; 
    scanptr++; scanno++; 

    if (distno >= 1) {
      /* have the distribution info */ 
      GetScanBreaks( bpp[0], numBaseScans, ScanBreaks[0]); 
    } else {
      for (n=1;n<=numBaseScans;n++) ScanBreaks[0][n] = defBaseScanSe[n];
    } 
    ntemp = 0; 
    for (n=1;n<=numBaseScans;n++) {
        scanptr->component_index[0] = 0; 
        scanptr->comps_in_scan = 1; 
        scanptr->Ss = ntemp + 1; 
        ntemp = scanptr->Se = ScanBreaks[0][n]; 
        scanptr->Ah = 0; 
        scanptr->Al = 0; 
        scanptr++; scanno++; 
    } 
  } else if (cinfo->input_components == 3) { 
    scanno = 0;
    scanptr = SavedScanInfo; 

    scanptr->component_index[0] = 0; 
    scanptr->component_index[1] = 1; 
    scanptr->component_index[2] = 2; 
    scanptr->comps_in_scan = 3; 
    scanptr->Ss = 0; 
    scanptr->Se = 0; 
    scanptr->Ah = 0; 
    scanptr->Al = 0; 
    scanptr++; scanno++; 

    if (distno >= 1) {
      /* have the distribution info */ 
      GetScanBreaks( bpp[0], numBaseScans, ScanBreaks[0]); 
    } else {
      for (n=1;n<=numBaseScans;n++) ScanBreaks[0][n] = defBaseScanSe[n];
    }
    if (distno >= 2) {
      /* have the distribution info */ 
      GetScanBreaks( bpp[1], numNonBaseScans, ScanBreaks[1]); 
    } else {
      for (n=1;n<=numNonBaseScans;n++)
	ScanBreaks[1][n] = defNonBaseScanSe[n];
    }
    if (distno >= 3) {
      /* have the distribution info */ 
      GetScanBreaks( bpp[2], numNonBaseScans, ScanBreaks[2]); 
    } else {
      for (n=1;n<=numNonBaseScans;n++)
	ScanBreaks[2][n] = defNonBaseScanSe[n];
    }

    ntemp = 0; 
    for (n=1;n<numBaseScans;n++) {
      /* get all but one base scans */ 
        scanptr->component_index[0] = 0; scanptr->comps_in_scan = 1; 
        scanptr->Ss = ntemp + 1; 
        ntemp = scanptr->Se = ScanBreaks[0][n]; 
        scanptr->Ah = 0; scanptr->Al = 0; 
        scanptr++; scanno++; 
    } 
    ntemp1 = 0; 
    ntemp2 = 0; 
    /* get 1 non-base scan each, then the last base scan */ 
    scanptr->component_index[0] = 1; scanptr->comps_in_scan = 1; 
    scanptr->Ss = ntemp1 + 1; 
    ntemp1 = scanptr->Se = ScanBreaks[1][1]; 
    scanptr->Ah = 0; scanptr->Al = 0; 
    scanptr++; scanno++; 
    scanptr->component_index[0] = 2; scanptr->comps_in_scan = 1; 
    scanptr->Ss = ntemp2 + 1; 
    ntemp2 = scanptr->Se = ScanBreaks[2][1]; 
    scanptr->Ah = 0; scanptr->Al = 0; 
    scanptr++; scanno++; 
    scanptr->component_index[0] = 0; scanptr->comps_in_scan = 1; 
    scanptr->Ss = ntemp + 1; 
    ntemp = scanptr->Se = ScanBreaks[0][numBaseScans]; 
    scanptr->Ah = 0; scanptr->Al = 0; 
    scanptr++; scanno++; 
    for (n=2;n<=numNonBaseScans;n++) {
        scanptr->component_index[0] = 1; 
        scanptr->comps_in_scan = 1; 
        scanptr->Ss = ntemp1 + 1; 
        ntemp1 = scanptr->Se = ScanBreaks[1][n]; 
        scanptr->Ah = 0; 
        scanptr->Al = 0; 
        scanptr++; scanno++; 
        scanptr->component_index[0] = 2; 
        scanptr->comps_in_scan = 1; 
        scanptr->Ss = ntemp2 + 1; 
        ntemp2 = scanptr->Se = ScanBreaks[2][n]; 
        scanptr->Ah = 0; 
        scanptr->Al = 0; 
        scanptr++; scanno++; 
    } 
  }


  if (scanno > 0) {
    scanptr = (jpeg_scan_info *)
      (*cinfo->mem->alloc_small) ((j_common_ptr) cinfo, JPOOL_IMAGE,
				  scanno * sizeof(jpeg_scan_info));
    MEMCOPY(scanptr, SavedScanInfo, scanno * sizeof(jpeg_scan_info));
    cinfo->scan_info = scanptr;
    cinfo->num_scans = scanno;
  } 

  return 1;
} 


/* call this before read_quant_tables */ 
static int
read_scan_info (j_compress_ptr cinfo, void *src, long src_bytes, int src_kind)
{ 
  int scanno, ncomps; 
  jpeg_scan_info * scanptr;
  DataSrc dsrc, *ds = &dsrc;
  char nextline[IMUTILS_STRLENMAX];
  char *nextchar; 
  int ret; 
  int vals[10], i; 

  DS_Init(ds, 0); 
  if (src_kind == DS_KIND_FILE || src_kind == DS_KIND_WEB) { 
    if (!DS_OpenFile(ds, (char *) src, src_bytes)) return 0; 
  } else if (src && (src_kind == DS_KIND_FD)) { 
    if (!DS_OpenFd(ds, *((int *) src), src_bytes)) return 0; 
  } else if (src_kind == DS_KIND_MEMORY) { 
    if (!DS_OpenMemory(ds, (char *) src, src_bytes)) return 0; 
  } else if (src_kind == DS_KIND_STREAM) { 
    if (!DS_OpenStream(ds, (FILE *) src, src_bytes)) return 0; 
  } else return 0; 

  scanptr = SavedScanInfo;
  scanno = 0;
  
  while ((ret =DS_ReadLine(ds,nextline,IMUTILS_STRLENMAX))!=0) { 
    if (blankline(nextline)) {
      continue;
    } else if (!strncmp(nextline,"#END",4)) {
      break; 
    } else if (!strncmp(nextline,"#",1)) {
      continue; 
    } else {
      nextchar = nextline; 
    }
    i=0;
    while (i < 10) {
      while ((*nextchar != '\0') && !isdigit((int)*nextchar)) nextchar++;
      if (!isdigit((int)*nextchar)) break; 
      sscanf(nextchar,"%d",&vals[i]);
      while (isdigit((int)*nextchar)) nextchar++;
      i++;
    }
    if ((i <= 4) || (i > (4 + MAXCOMPS))) break; 
    if (scanno >= MAXSCANS) break; 

    ncomps = i - 4;

    for (i=0;i<ncomps;i++) scanptr->component_index[i] = vals[i]; 
    scanptr->comps_in_scan = ncomps;
    scanptr->Ss = vals[ncomps]; 
    scanptr->Se = vals[ncomps+1]; 
    scanptr->Ah = vals[ncomps+2]; 
    scanptr->Al = vals[ncomps+3]; 

    scanptr++, scanno++;
  }
  DS_Close(ds); 

  if (scanno > 0) {
    scanptr = (jpeg_scan_info *)
      (*cinfo->mem->alloc_small) ((j_common_ptr) cinfo, JPOOL_IMAGE,
				  scanno * sizeof(jpeg_scan_info));
    MEMCOPY(scanptr, SavedScanInfo, scanno * sizeof(jpeg_scan_info));
    cinfo->scan_info = scanptr;
    cinfo->num_scans = scanno;
  }

  return 1;
}


/*
 * Here's the routine that will replace the standard error_exit method:
 */

METHODDEF void
my_jpg_error_exit (j_common_ptr cinfo)
{
  /* cinfo->err really points to a my_error_mgr struct, so coerce pointer */
  my_jpg_error_ptr myerr = (my_jpg_error_ptr) cinfo->err;

  /* Always display the message. */
  /* We could postpone this until after returning, if we chose. */
  (*cinfo->err->output_message) (cinfo);

  /* Return control to the setjmp point */
  longjmp(myerr->setjmp_buffer, 1);
}


extern void FreeImgJpeg(Image *Im)
{
  if (Im->jinfo_alive && ImKindSubSetOf(Im->ImKind, IM_JPEG) ) {
    jpeg_destroy_decompress(&Im->jpg_info);
    Im->jinfo_alive = FALSE;
    if (Im->jpg_im) IM_FREE_PTR(Im->jpg_im);
    Im->jpg_im = (unsigned char *) 0;
    if (Im->jpg_outbuff) IM_FREE_PTR(Im->jpg_outbuff);
    Im->jpg_outbuff = (JSAMPARRAY) 0;
  }
}


extern int ReadJpegHeader(Image *Im)
{
  struct jpeg_decompress_struct * cinfo = &Im->jpg_info;

  /** no suspension should occur here! **/


  Im->jpg_im = (unsigned char *) 0;
  Im->jpg_outbuff = (JSAMPARRAY) 0;


  /* We set up the normal JPEG error routines, then override error_exit. */
  Im->jpg_info.err = jpeg_std_error(&(Im->jpg_err.pub));

  Im->jpg_err.pub.error_exit = my_jpg_error_exit;

  /* Establish the setjmp return context for my_jpg_error_exit to use. */
  if (setjmp(Im->jpg_err.setjmp_buffer)) {
    /* If we get here, the JPEG code has signaled an error.
     * We need to clean up the JPEG object
     */
    FreeImgJpeg(Im);
    return 0;
  }

  jpeg_create_decompress(cinfo);

  Im->jinfo_alive = TRUE; 

  jpeg_dynam_src(cinfo, &(Im->ImgSrc), 5, Im->FirstFiveChars); 

  if (!jpeg_read_header(cinfo, TRUE)) {
    /* suspension while reading header is not allowed! */
    if (!Im->Silent)
      (void) DD_WriteLine(&Im->ImgErr, 
	"JPEG data doesn't even have full header!");
    FreeImgJpeg(Im);
    return(0);
  }

  if (cinfo->jpeg_color_space == JCS_UNKNOWN) {
    if (!Im->Silent)
      (void) DD_WriteLine(&Im->ImgErr, 
        "unknown JPEG format");
    FreeImgJpeg(Im);
    return(0);
  } else if (cinfo->jpeg_color_space == JCS_GRAYSCALE) {
    cinfo->out_color_space = JCS_GRAYSCALE;
    Im->NumPlanes = 1;
    Im->ImKind = IM_JPEG_GRAY;
  } else {
    Im->NumPlanes = 3;
    cinfo->out_color_space = JCS_RGB;
    Im->ImKind = IM_JPEG_RGB;
  }


  cinfo->buffered_image = TRUE;
  cinfo->do_block_smoothing = TRUE;
  #ifdef HAVE_IJG_EXTENSIONS
  cinfo->do_fancy_pt_untrans = TRUE; 
  #endif

  jpeg_calc_output_dimensions(cinfo); /* won't suspend */

  Im->NumCols = cinfo->output_width;
  Im->NumRows = cinfo->output_height;

  return(1);
}

extern int ReadJpegImg(Image *Im)
{
  struct jpeg_decompress_struct * cinfo = &Im->jpg_info;
  long i, j, k, width, height, rwidth; 
  long imbytes; 
  int nplanes, nlines, pixstart, npixels, firstline;
  int ret, ip_done, curr_scan; 
  register unsigned char *temp;

  width = Im->NumCols;
  height = Im->NumRows;
  nplanes = Im->NumPlanes;
  rwidth = width * nplanes;

  imbytes = rwidth*cinfo->rec_outbuf_height; 

  if ((Im->jpg_im = (unsigned char *) malloc(imbytes)) == NULL) { 
    FreeImgJpeg(Im);
    return(0);
  }
  

  if ((Im->jpg_outbuff = (JSAMPARRAY) calloc(1,sizeof(JSAMPROW)*
	 cinfo->rec_outbuf_height)) == NULL) {
    FreeImgJpeg(Im);
    return(0);
  }
  
  Im->jpg_outbuff[0] = ((JSAMPROW) Im->jpg_im); 
  for (i=1;i<cinfo->rec_outbuf_height;i++) {
    Im->jpg_outbuff[i] = Im->jpg_outbuff[i-1] + rwidth;  
  }

  /* Establish the setjmp return context for
     my_jpg_error_exit to use. */
  if (setjmp(Im->jpg_err.setjmp_buffer)) {
    /* If we get here, the JPEG code has signaled an error.
     * We need to clean up the JPEG object
     */
    FreeImgJpeg(Im);
    return 0;
  }

  (void) jpeg_start_decompress(cinfo); /* will not suspend */ 


  while (((ret = jpeg_consume_input(cinfo)) != JPEG_REACHED_EOI) &&
	   (ret != JPEG_SUSPENDED) );
  ip_done = jpeg_input_complete(cinfo);

  curr_scan = cinfo->input_scan_number;
  if ((ret == JPEG_SUSPENDED) && (curr_scan > 1) && !ip_done)
     curr_scan--;
  
  if ((ret == JPEG_REACHED_EOI) || ip_done)
    cinfo->dct_method = Im->final_idct;
  else
    cinfo->dct_method = Im->rough_idct;

  (void) jpeg_start_output(cinfo, curr_scan); 
      /* will not suspend */ 

  while (cinfo->output_scanline < cinfo->output_height) {
      
      firstline = cinfo->output_scanline; 

      if (!(nlines = jpeg_read_scanlines(cinfo, Im->jpg_outbuff,
		  cinfo->rec_outbuf_height))) { 
	/* this can only happen when curr_scan==1 */ 
	Im->ImRestartPt = 0; 
        goto readjpg_susp;
      } else {
        if (nplanes==1) {
          memcpy(Im->Im[0] + (firstline*rwidth),
		 Im->jpg_im, (nlines*rwidth)); 
        } else {
	  pixstart = firstline * width; 
          npixels = pixstart + (nlines * width); 
          for (i=0;i<nplanes;i++) {
            temp = Im->jpg_im + i;
            for (j=pixstart,k=0;j<npixels;j++,k+=nplanes) {
	      Im->Im[i][j] = temp[k];
            }
          }
        }
      } 

  } 

  if (!jpeg_finish_output(cinfo)) {
      Im->ImRestartPt = 1; 
      goto readjpg_susp;
  }

  Im->ImRestartPt = 2; 


  readjpg_susp:
  if (cinfo->input_scan_number == 1) { 
    for (i=0;i<nplanes;i++) { 
      if ((Im->LastChangedRow[i] = cinfo->output_scanline) >=
	      Im->NumRows) { 
        Im->LastChangedRow[i] = Im->NumRows - 1;
      }
    }
  } else {
    for (i=0;i<nplanes;i++) Im->LastChangedRow[i] = Im->NumRows - 1;
  }

  if (jpeg_input_complete(cinfo) &&
        (cinfo->input_scan_number == cinfo->output_scan_number) ) { 
    Im->ImState = ImStateReadAll;
  }

  return(1);
}


extern int ReadMoreJpegImg(Image *Im)
{
  struct jpeg_decompress_struct * cinfo = &Im->jpg_info;
  long i, j, k, width, height, rwidth; 
  int nplanes, nlines, npixels, pixstart, firstline; 
  int ret, ip_done, curr_scan; 
  register unsigned char *temp;

  if (!Im->jinfo_alive) return 0; 



  width = Im->NumCols;
  height = Im->NumRows;
  nplanes = Im->NumPlanes;
  rwidth = width * nplanes;

  /* Establish the setjmp return context for
     my_jpg_error_exit to use. */
  if (setjmp(Im->jpg_err.setjmp_buffer)) {
    /* If we get here, the JPEG code has signaled an error.
     * We need to clean up the JPEG object
     */
    FreeImgJpeg(Im);
    return 0;
  }

  while (((ret = jpeg_consume_input(cinfo)) != JPEG_REACHED_EOI) &&
	   (ret != JPEG_SUSPENDED) );
  ip_done = jpeg_input_complete(cinfo);

  curr_scan = cinfo->input_scan_number;
  if ((ret == JPEG_SUSPENDED) && (curr_scan > 1)
    && !ip_done) curr_scan--;

  if (Im->ImRestartPt == 0) {
    /* had suspended during read_scanlines for the very first scan */
    if (cinfo->input_scan_number > 1) {
      if (!jpeg_finish_output(cinfo)) {
	/* shouldn't really happen */
	Im->ImRestartPt = 1;
	goto readmorejpg_susp; 
      } 
    if ((ret == JPEG_REACHED_EOI) || ip_done)
      cinfo->dct_method = Im->final_idct;
    else
      cinfo->dct_method = Im->rough_idct;

      (void) jpeg_start_output(cinfo, curr_scan); 
    } /* else, still the same scan continues,
	 don't need to finish_output */ 
  } else if (Im->ImRestartPt == 1) {
    /* had suspended during finish_output */ 
    if (!jpeg_finish_output(cinfo)) {
      Im->ImRestartPt = 1;
      goto readmorejpg_susp; 
    } 
    if ((ret == JPEG_REACHED_EOI) || ip_done)
      cinfo->dct_method = Im->final_idct;
    else
      cinfo->dct_method = Im->rough_idct;
    (void) jpeg_start_output(cinfo, curr_scan); 
  } else {
    if ((ret == JPEG_REACHED_EOI) || ip_done)
      cinfo->dct_method = Im->final_idct;
    else
      cinfo->dct_method = Im->rough_idct;
    (void) jpeg_start_output(cinfo, curr_scan); 
  } 


  while (cinfo->output_scanline < cinfo->output_height) {
      
      firstline = cinfo->output_scanline; 

      if (!(nlines = jpeg_read_scanlines(cinfo, Im->jpg_outbuff,
		  cinfo->rec_outbuf_height))) { 
	/* this can only happen when curr_scan==1 */ 
	Im->ImRestartPt = 0; 
        goto readmorejpg_susp;
      } else {
        if (nplanes==1) {
          memcpy(Im->Im[0] + (firstline*width),
		 Im->jpg_im, (nlines*width)); 
        } else {
	  pixstart = firstline * width; 
          npixels = pixstart + (nlines * width); 
          for (i=0;i<nplanes;i++) {
            temp = Im->jpg_im + i;
            for (j=pixstart,k=0;j<npixels;j++,k+=nplanes) {
	      Im->Im[i][j] = temp[k];
            }
          }
        }
      } 

  } 

  if (!jpeg_finish_output(cinfo)) {
      Im->ImRestartPt = 1; 
      goto readmorejpg_susp;
  }

  Im->ImRestartPt = 2; 

  readmorejpg_susp:
  if (cinfo->input_scan_number == 1) { 
    for (i=0;i<nplanes;i++) { 
      Im->FirstChangedRow[i] = Im->LastChangedRow[i]; 
      if ((Im->LastChangedRow[i] = cinfo->output_scanline) >=
	      Im->NumRows) { 
        Im->LastChangedRow[i] = Im->NumRows - 1;
      }
    }
  } else {
    for (i=0;i<nplanes;i++) {
      Im->FirstChangedRow[i] = 0; 
      Im->LastChangedRow[i] = Im->NumRows - 1;
    } 
  }

  if (jpeg_input_complete(cinfo) &&
        (cinfo->input_scan_number == cinfo->output_scan_number) ) { 
    Im->ImState = ImStateReadAll;
  }

  return(1);
}

/**** some code for generating internal rate-quality curves for JPEG */

#define M_SOI   0xD8	/* Start Of Image (beginning of datastream) */
#define M_EOI   0xD9	/* End Of Image (end of datastream) */
#define M_SOS   0xDA	/* Start Of Scan (begins compressed data) */


#define NEXT_MARKER \
  while ( (*nextchar) != 0xFF) {nextchar++; nread++;} \
  while ( (*nextchar) == 0xFF) {nextchar++; nread++;} \
  nread++; marker = *nextchar++;  

#define SKIP_VARIABLE \
  varlen = (unsigned long) (*nextchar++); nread++; \
  varlen <<= 8; \
  varlen += (unsigned long) (*nextchar++); nread++; \
  varlen -= 2; \
  nextchar += varlen; nread += varlen


static int
JpegFillIcurve(QclicInfo *qinfo, int IsCompressed, 
	       Pixel *ImPlane1, Pixel *ImPlane2, Pixel *ImPlane3, 
	       int NumPlanes, int CurrCols, int CurrRows, 
	       char *cdata,
	       long cbytes, int cscans, int qm_kind) 
{ 

  /* assume that cdata is a complete and correct JPEG sequence */

  long nread = 0;
  unsigned long varlen; 
  unsigned char *nextchar = (unsigned char *) cdata; 
  unsigned char marker;
  int npoints = cscans + 1;
  int nextpoint = 0; 
  long *offsets, sspan;
  float *qualities, qspan;
  Image DecImg, OrigImgCopy, *OrigImg = &OrigImgCopy; 
  long npix[3], i, incr; 
  double peaksq, diff1, diff2, diff3;
  double tot_err1, tot_err2, tot_err3;

  /* figure out qmetric */
  if (NumPlanes == 1) {
    QM_MAKE_GRAYSCALE(qm_kind);
  } else { 
    QM_MAKE_RGB(qm_kind);
  }
  if (IsCompressed) {
    QM_MAKE_NO_NEED_LOSSLESS(qm_kind);
    QM_MAKE_ADD1_TO_DIST(qm_kind); 
  } else {
    QM_MAKE_NEED_LOSSLESS(qm_kind);
    QM_MAKE_NO_ADD1_TO_DIST(qm_kind); 
  } 

  if (qinfo->icurve_points > 0) {
      IM_FREE_PTR(qinfo->icurve_size); qinfo->icurve_size = (long *) 0; 
      IM_FREE_PTR(qinfo->icurve_quality); qinfo->icurve_quality = (float *) 0; 
      qinfo->icurve_points = 0; 
  }

  offsets = (long *) malloc(sizeof(long)*npoints); 
  qualities = (float *) malloc(sizeof(float)*npoints); 
  if (!offsets || !qualities) {
    if (offsets) IM_FREE_PTR(offsets); 
    if (qualities) IM_FREE_PTR(qualities); 
    return(0);
  }

  NEXT_MARKER; /* read off SOI */ 

  /* Scan miscellaneous markers until we reach EOI. */
  while ((nextpoint < npoints) && (nread < cbytes)) { 
    NEXT_MARKER; 
    switch (marker) {

    case M_SOS:	
      offsets[nextpoint++] = nread; 
      SKIP_VARIABLE; 
      break;
    case M_EOI:	
      if (nextpoint != (npoints - 1)) {
	IM_FREE_PTR(offsets);
	IM_FREE_PTR(qualities);
	return 0;
      } 
      offsets[nextpoint++] = nread; 
      break; 
    case 0:
      break; 
    default: 
      SKIP_VARIABLE; 
      break;
    }  
  } 

  if (nextpoint != npoints) { 
	IM_FREE_PTR(offsets);
	IM_FREE_PTR(qualities);
	return 0;
  } 
  
  qinfo->icurve_points = npoints;
  qinfo->icurve_size = offsets; 
  qinfo->icurve_quality = qualities; 

  
  sspan = offsets[npoints-1] - offsets[0];
  if (!QM_NEEDS_PSNR(qm_kind)) goto no_psnr_needed; 

  ImInitImg(&DecImg);

  npix[0] = ((long) CurrRows) * CurrCols; 

  if (NumPlanes == 3) {
    ImInitImg(OrigImg);
    ImSetSilent(OrigImg);
    ImDiscardOriginal(OrigImg);
    ImSetKindRaw(OrigImg, 3, CurrRows, CurrCols, 1);
    ImSetImgMemory(OrigImg, ImPlane1, npix[0]);
    if (!ImPeekImg(OrigImg) || !ImReadImg(OrigImg)) {
      /* drat! */
      qm_kind = QM_DEFAULT; 
      goto bogus_qualities; 
    } 
    ImSetImgMemory(OrigImg, ImPlane2, npix[0]);
    ImReadMoreImg(OrigImg); 
    ImSetImgMemory(OrigImg, ImPlane3, npix[0]);
    ImReadMoreImg(OrigImg); 
    ImChangeCspace(OrigImg, ImC_YCbCr);
    if (!ImStretchAndShrink(OrigImg, 1, 1, 2, 1, 2, 0, 0) ||
        !ImStretchAndShrink(OrigImg, 2, 1, 2, 1, 2, 0, 0) ) { 
      /* drat! */
      qm_kind = QM_DEFAULT; 
      goto bogus_qualities; 
    } 
    npix[1] = ((long) OrigImg->CurrRows[1]) * OrigImg->CurrCols[1]; 
    npix[2] = ((long) OrigImg->CurrRows[2]) * OrigImg->CurrCols[2]; 
  }

  ImSetSilent(&DecImg);
  ImDiscardOriginal(&DecImg);

  if (QM_INTERPOLATES(qm_kind)) { 
    nextchar = cdata;
    ImSetRoughIDCT(&DecImg, JDCT_FLOAT); 
    ImSetFinalIDCT(&DecImg, JDCT_FLOAT); 
    if (!ImSetImgMemory(&DecImg, nextchar, offsets[npoints-1]) || 
      !ImPeekImg(&DecImg) || !ImReadImg(&DecImg) ) { 
        qm_kind = QM_DEFAULT; 
	goto bogus_qualities; 
    } 
    if (NumPlanes == 3) { 
      ImChangeCspace(&DecImg, ImC_YCbCr);
      if (!ImStretchAndShrink(&DecImg, 1, 1, 2, 1, 2, 0, 0) || 
        !ImStretchAndShrink(&DecImg, 2, 1, 2, 1, 2, 0, 0)) { 
        /* drat! */
        qm_kind = QM_DEFAULT; 
        goto bogus_qualities; 
      } 
    } 

    peaksq = (double) 65025.0;

    for (nextpoint = npoints-1;nextpoint>=0; nextpoint -= (npoints-1)) {

      /** compute PSNRs **/
      if (NumPlanes == 1) { 
        tot_err1 = (double) (QM_ADDS1_TO_DIST(qm_kind) ? npix[0] : 0);
        for (i=0; i<npix[0]; i++) {
  	  diff1 = ((double) ImPlane1[i]) - 
	       ((double) DecImg.Im[0][i]); 
          tot_err1 += (diff1*diff1);
        }
        qualities[nextpoint] =
	   ((float) 10.0)* log10(peaksq*((double) npix[0])/ tot_err1);

      } else {

        tot_err1 = (double) (QM_ADDS1_TO_DIST(qm_kind) ? npix[0] : 0);
        for (i=0; i<npix[0]; i++) {
  	  diff1 = ((double) OrigImg->Im[0][i]) - 
	          ((double) DecImg.Im[0][i]); 
          tot_err1 += (diff1*diff1);
        }
        tot_err2 = (double) (QM_ADDS1_TO_DIST(qm_kind) ? npix[1] : 0);
        for (i=0; i<npix[1]; i++) {
	  diff2 = ((double) OrigImg->Im[1][i]) - 
	          ((double) DecImg.Im[1][i]); 
          tot_err2 += (diff2*diff2);
        }
        tot_err3 = (double) (QM_ADDS1_TO_DIST(qm_kind) ? npix[2] : 0);
        for (i=0; i<npix[2]; i++) {
	  diff3 = ((double) OrigImg->Im[2][i]) - 
	        ((double) DecImg.Im[2][i]); 
          tot_err3 += (diff3*diff3);
        } 

        tot_err1 += (tot_err2 + tot_err3);
        qualities[nextpoint] = ((float) 10.0)*log10(peaksq*
	    ((double) (npix[0] + npix[1] + npix[2]))/tot_err1);
      }

      if (nextpoint != 0) { 
        for (i=0; i<NumPlanes; i++)
	  memset(DecImg.Im[i], 128, npix[i]); 
      } 
    } 
    qspan = qualities[npoints-1] - qualities[0];
    for (nextpoint=1;nextpoint < (npoints-1); nextpoint++) {
      qualities[nextpoint] = qualities[0] +
	((float) offsets[nextpoint]-offsets[0])*qspan/((float) sspan); 
    } 

  } else {

    nextchar = cdata;
    ImSetRoughIDCT(&DecImg, JDCT_FLOAT); 
    ImSetFinalIDCT(&DecImg, JDCT_FLOAT); 
    if (!ImSetImgMemory(&DecImg, nextchar, offsets[1]) || 
      !ImPeekImg(&DecImg) || !ImReadImg(&DecImg) ) { 
        qm_kind = QM_DEFAULT; 
	goto bogus_qualities; 
    } 
    nextchar += offsets[1];

    if (NumPlanes == 3) { 
      ImChangeCspace(&DecImg, ImC_YCbCr);
      if (!ImStretchAndShrink(&DecImg, 1, 1, 2, 1, 2, 0, 0) || 
        !ImStretchAndShrink(&DecImg, 2, 1, 2, 1, 2, 0, 0)) { 
        /* drat! */
        qm_kind = QM_DEFAULT; 
        goto bogus_qualities; 
      } 
    } 

    peaksq = (double) 65025.0;

    for (nextpoint = 1; nextpoint <= npoints; nextpoint++) {

      /** compute PSNRs **/
      if (NumPlanes == 1) { 
        tot_err1 = (double) (QM_ADDS1_TO_DIST(qm_kind) ? npix[0] : 0);
        for (i=0; i<npix[0]; i++) {
  	  diff1 = ((double) ImPlane1[i]) - 
	       ((double) DecImg.Im[0][i]); 
          tot_err1 += (diff1*diff1);
        }
        qualities[(nextpoint==npoints)?0:nextpoint] =
	   ((float) 10.0)* log10( 
		 peaksq*((double) npix[0])/tot_err1);
      } else {

        tot_err1 = (double) (QM_ADDS1_TO_DIST(qm_kind) ? npix[0] : 0);
        for (i=0; i<npix[0]; i++) {
  	  diff1 = ((double) OrigImg->Im[0][i]) - 
	          ((double) DecImg.Im[0][i]); 
          tot_err1 += (diff1*diff1);
        }
        tot_err2 = (double) (QM_ADDS1_TO_DIST(qm_kind) ? npix[1] : 0);
        for (i=0; i<npix[1]; i++) {
	  diff2 = ((double) OrigImg->Im[1][i]) - 
	          ((double) DecImg.Im[1][i]); 
          tot_err2 += (diff2*diff2);
        }
        tot_err3 = (double) (QM_ADDS1_TO_DIST(qm_kind) ? npix[2] : 0);
        for (i=0; i<npix[2]; i++) {
	  diff3 = ((double) OrigImg->Im[2][i]) - 
	        ((double) DecImg.Im[2][i]); 
          tot_err3 += (diff3*diff3);
        } 

        tot_err1 += (tot_err2 + tot_err3);
        qualities[(nextpoint==npoints)?0:nextpoint] =
	  ((float) 10.0)*log10(peaksq*
	    ((double) (npix[0] + npix[1] + npix[2]))/tot_err1);
      }

      if (nextpoint < (npoints-1)) { 
        incr = offsets[nextpoint+1] - offsets[nextpoint]; 
        if (!ImSetImgMemory(&DecImg, nextchar, incr) ||
	    !ImReadMoreImg(&DecImg)) { 
          qm_kind = QM_DEFAULT; 
	  goto bogus_qualities; 
	} 
        nextchar += incr; 
      } else if (nextpoint == (npoints - 1)) {
        for (i=0; i<NumPlanes; i++)
	  memset(DecImg.Im[i], 128, npix[i]); 
      } 
    }
  } 

  bogus_qualities:
  ImFreeImg(&DecImg); 
  if (NumPlanes == 3) ImFreeImg(OrigImg); 

  no_psnr_needed:
  if (!QM_NEEDS_PSNR(qm_kind)) { 
    if ((qm_kind != QM_SIZE) && (qm_kind != QM_PSIZE) &&
	 (qm_kind != QM_BPP)) 
      qm_kind = QM_PSIZE; 
    for (nextpoint = 0; nextpoint < npoints; nextpoint++) {
      qualities[nextpoint] = ((float) offsets[nextpoint]); 
    } 
    if (qm_kind == QM_PSIZE) {
      diff1 = ((double) 100.0)/
	      ((double) CurrRows*CurrCols*NumPlanes); 
      for (nextpoint = 0; nextpoint < npoints; nextpoint++) {
        qualities[nextpoint] *= ((float) diff1); 
      }  
    } else if (qm_kind == QM_BPP) {
      diff1 = ((double) 8.0)/
	      ((double) CurrRows*CurrCols); 
      for (nextpoint = 0; nextpoint < npoints; nextpoint++) {
        qualities[nextpoint] *= ((float) diff1); 
      }  
    } 
  } 
  strcpy(qinfo->icurve_qmetric,Qmetric(qm_kind)); 

  return 1; 
}

/*****************************************************
 JPEG compresses image.
 UseCoeffs: if not NULL, it has the quantized jpeg coefficients
	    obtained by decoding some image. These coeffs will
	    be used.
 ImPlane1, ImPlane2, ImPlane3: If !UseCoeffs, image data must
	    exist in these arrays.
 NumPlanes, CurrCols, CurrRows: dimensions of image.
 dd: data destination for compressed data. 
*******************************************************/ 

static int SendJpegInner(
  jvirt_barray_ptr * UseCoeffs, 
  Pixel *ImPlane1, Pixel *ImPlane2, Pixel *ImPlane3, 
  int NumPlanes, int CurrCols, int CurrRows,
  DataDest *dd,
  void * qsrc, long qsrc_bytes, int qsrc_kind,  
  void * ssrc, long ssrc_bytes, int ssrc_kind,  
  int *numscans) 
{
  struct jpeg_compress_struct cinfo, * cinfoptr = &cinfo; 
  struct my_jpg_error_mgr jerr, * jerrptr = &jerr;
  char *imbuffer = (char *) 0; 
  long nloops, remaining, ninloop, looppixels, pixinloop; 
  #define LOOPROWS 16
  int i, j, k, n; 
  JSAMPROW jpeg_imbuffer[LOOPROWS]; 

  looppixels = LOOPROWS * CurrCols;

  if (!UseCoeffs && (NumPlanes == 3)) {
    imbuffer = (char *) malloc(looppixels*3);
    if (!imbuffer) return 0; 
  }


  /* We set up the normal JPEG error routines,
     then override error_exit. */
  cinfoptr->err = jpeg_std_error(&(jerrptr->pub));
  jerrptr->pub.error_exit = my_jpg_error_exit;

  /* Establish the setjmp return context for
     my_jpg_error_exit to use. */
  if (setjmp(jerrptr->setjmp_buffer)) {
    /* If we get here, the JPEG code has signaled an error.
     * We need to clean up the JPEG object
     */
    jpeg_destroy_compress(cinfoptr); 
    if (imbuffer) IM_FREE_PTR(imbuffer);  
    return 0; 
  }

  jpeg_create_compress(cinfoptr);

  /* Initialize JPEG parameters.
   */

  if (NumPlanes == 1) {
    cinfoptr->in_color_space = JCS_GRAYSCALE; 
  } else /* if (NumPlanes == 3) */ { 
    cinfoptr->in_color_space = JCS_RGB; 
  } 
  cinfoptr->image_width = CurrCols; 
  cinfoptr->image_height = CurrRows; 
  cinfoptr->input_components = NumPlanes; 

  jpeg_set_defaults(cinfoptr);

  cinfoptr->dct_method = JDCT_FLOAT; 
  cinfoptr->optimize_coding = TRUE;

  if (ssrc) { 
    if (!read_scan_info(cinfoptr, ssrc, ssrc_bytes, ssrc_kind)) {
      jpeg_destroy_compress(cinfoptr); 
      if (imbuffer) IM_FREE_PTR(imbuffer);  
      return 0; 
    }
  }

  if (!read_qtabinfo(cinfoptr, qsrc, qsrc_bytes, qsrc_kind)) {
    jpeg_destroy_compress(cinfoptr); 
    if (imbuffer) IM_FREE_PTR(imbuffer);  
    return 0; 
  }

  /* Specify data destination for compression */
  jpeg_dynam_dest(cinfoptr, dd); 

  if (UseCoeffs) {
    jpeg_write_coefficients(cinfoptr, UseCoeffs);
  } else { 
    /* Start compressor */
    jpeg_start_compress(cinfoptr, TRUE);

    /* Process data */
    nloops = CurrRows/LOOPROWS; 
    remaining = CurrRows - (nloops*LOOPROWS); 
    if (remaining) nloops++;
    else remaining = LOOPROWS; 

    if (NumPlanes == 1) {
      jpeg_imbuffer[0] = (JSAMPROW) ImPlane1; 
      for (i=1;i<LOOPROWS;i++)
        jpeg_imbuffer[i] = jpeg_imbuffer[i-1] + CurrCols; 
      for (i=0;i<nloops;i++) { 
        if (i==(nloops-1)) ninloop = remaining;
        else ninloop = LOOPROWS; 
        if ( jpeg_write_scanlines(cinfoptr, jpeg_imbuffer, ninloop)
  		   != ninloop ) { 
          jpeg_destroy_compress(cinfoptr); 
          return 0; 
        } 
        for (j=0;j<LOOPROWS;j++)
          jpeg_imbuffer[j] += looppixels; 
      } 
    } else {

      jpeg_imbuffer[0] = (JSAMPROW) imbuffer; 
      for (i=1;i<LOOPROWS;i++)
        jpeg_imbuffer[i] = jpeg_imbuffer[i-1] + (CurrCols*3); 

      n = 0;
      for (i=0;i<nloops;i++) {
        if (i==(nloops-1)) ninloop = remaining; 
        else ninloop = LOOPROWS; 
        pixinloop = ninloop * CurrCols; 
        for (j=0,k=0;j<pixinloop;j++,n++) {
	  imbuffer[k++] = (char) ImPlane1[n]; 
	  imbuffer[k++] = (char) ImPlane2[n]; 
	  imbuffer[k++] = (char) ImPlane3[n]; 
        } 
        if (jpeg_write_scanlines(cinfoptr,jpeg_imbuffer, ninloop)
	     != ninloop){ 
	  IM_FREE_PTR(imbuffer); 
          jpeg_destroy_compress(cinfoptr); 
          return 0; 
        } 
      } 
    }   
  } 

  /* Finish compression and release memory */
  jpeg_finish_compress(cinfoptr); 
  *numscans = cinfoptr->num_scans; 

  jpeg_destroy_compress(cinfoptr);

  if (imbuffer) IM_FREE_PTR(imbuffer); imbuffer = (char *) 0; 
  return 1; 
} 

static char DefQTableBuffer[1024];

static void FillDefQTable(int Rows, int Cols, int Planes,
  float target, int comp_till_kind)
{
  float psnr = target, bpp = target; 
  int q, i; 
  char * nextchar = DefQTableBuffer; 

  switch (comp_till_kind) {
  case QM_BPP:
    break; 
  case QM_PSIZE:
    bpp *= ((float) Rows * Cols * Planes);
    bpp /= ((float) 100); 
    /* fall through */ 
  case QM_SIZE:
    bpp *= ((float) 8.0); 
    bpp /= ((float) Rows * Cols);
    break; 
  default:
    /* dumb heuristic */ 
    if (psnr < 15.5 ) psnr = (float) 15.5; 
    bpp = (psnr - 15.0)/((float) 15.0);
    break; 
  }

  if      (bpp <= 0.05) q = 255;
  if      (bpp <= 0.10) q = 128;
  else if (bpp <= 0.20) q = 48; 
  else if (bpp <= 0.30) q = 32;
  else if (bpp <= 0.40) q = 24; 
  else if (bpp <= 0.50) q = 20;
  else if (bpp <= 0.60) q = 16;
  else if (bpp <= 0.70) q = 14;
  else if (bpp <= 0.80) q = 12;
  else if (bpp <= 0.90) q = 10;
  else if (bpp <= 1.00) q = 8;
  else if (bpp <= 1.50) q = 4; 
  else if (bpp <= 2.00) q = 2;
  else                  q = 1; 

  for (i=0;i<8;i++) {
    sprintf(nextchar,"%d %d %d %d %d %d %d %d\n",
	 q, q, q, q, q, q, q, q);
    nextchar += strlen(nextchar); 
  }  
}

static const char IJGDefLumQtab[512] = "\
16 11 10 16 24 40 51 61\n\
12 12 14 19 26 58 60 55\n\
14 13 16 24 40 57 69 56\n\
14 17 22 29 51 87 80 62\n\
18 22 37 56 68 109 103 77\n\
24 35 55 64 81 104 113 92\n\
49 64 78 87 103 121 120 101\n\
72 92 95 98 112 100 103 99\n\0";

static const char IJGDefChromQtab[512] = "\
17 18 24 47 99 99 99 99\n\
18 21 26 66 99 99 99 99\n\
24 26 56 99 99 99 99 99\n\
47 66 99 99 99 99 99 99\n\
99 99 99 99 99 99 99 99\n\
99 99 99 99 99 99 99 99\n\
99 99 99 99 99 99 99 99\n\
99 99 99 99 99 99 99 99\n\0"; 

static int ZigZagToN[64] =
{
0, 1, 8, 16, 9, 2, 3, 10, 
17, 24, 32, 25, 18, 11, 4, 5, 
12, 19, 26, 33, 40, 48, 41, 34, 
27, 20, 13, 6, 7, 14, 21, 28, 
35, 42, 49, 56, 57, 50, 43, 36, 
29, 22, 15, 23, 30, 37, 44, 51, 
58, 59, 52, 45, 38, 31, 39, 46, 
53, 60, 61, 54, 47, 55, 62, 63,
};


static void GetQTablesFromCinfo(struct jpeg_decompress_struct *cinfo,
		 int planes)
{
  int i,num,Q[64],n,zn; 
  char *nextchar = DefQTableBuffer; 
  for (i=0;i<planes;i++) {
    num = cinfo->comp_info[i].quant_tbl_no;
    if (!cinfo->quant_tbl_ptrs[num]) {
      if (i==0) sprintf(nextchar,"%s",IJGDefLumQtab);
      else sprintf(nextchar,"%s",IJGDefChromQtab);
      nextchar += strlen(nextchar); 
    } else {
      for (zn=0;zn<64;zn++)
        Q[ZigZagToN[zn]] = (int)
	  cinfo->quant_tbl_ptrs[num]->quantval[zn];
      for (n=0;n<64;n+=8) {
	sprintf(nextchar,"%d %d %d %d %d %d %d %d\n",
	  Q[n],   Q[n+1], Q[n+2], Q[n+3], 
	  Q[n+4], Q[n+5], Q[n+6], Q[n+7]);  
        nextchar += strlen(nextchar); 
      } 
    }
  }
}

#define SCANSCRIPTLENMAX 3000 

static char defScanScriptBuffer[SCANSCRIPTLENMAX];

struct MaxCoefsStruct {
  /* coeff numbers in zigzag order */ 
  char HaveCoefMax[IM_MAXPLANES][64]; 
  long CoefMax[IM_MAXPLANES][64];
};
typedef struct MaxCoefsStruct MaxCoefs;

static void InitMaxCoefs(MaxCoefs *mc)
{
  int i, j;
  for (i=0;i<IM_MAXPLANES;i++) {
    for (j=0;j<64;j++) {
      mc->HaveCoefMax[i][j] = 0;
    }
  }
}

static long FillMaxCoefs(MaxCoefs *mc, 
  struct jpeg_decompress_struct *cinfo, 
  int pstart, int pend, int cstart, int cend)
{
  int ci, bi, bj, zn,  n; 
  register long qv; 
  JBLOCKARRAY buffer;
  jpeg_component_info *compptr;
  int have_all = 1; 
  jvirt_barray_ptr *coef_array = cinfo->coef->coef_arrays; 
  long ans; 

  ans = 0; 
  for (ci = pstart; ci <= pend; ci++) {
    for (zn=cstart;zn<=cend;zn++) {
      if (!mc->HaveCoefMax[ci][zn]) { 
        mc->CoefMax[ci][zn] = 0L;
	have_all = 0; 
      } else {
        if (mc->CoefMax[ci][zn] > ans) { 
          ans = mc->CoefMax[ci][zn]; 
  } } } }  

  if (have_all) return ans; 

  for (ci = pstart; !have_all && (ci <= pend); ci++) {
    compptr = &cinfo->comp_info[ci];
    for (bi=0;bi < compptr->height_in_blocks; bi++) {
      buffer = (*cinfo->mem->access_virt_barray)
          ((j_common_ptr) cinfo, coef_array[compptr->component_index],
           bi, 1, TRUE);
      for (bj=0;bj < compptr->width_in_blocks; bj++) {
        for (zn=cstart;zn<=cend;zn++) {
	  if (mc->HaveCoefMax[ci][zn]) continue; 
	  n = ZigZagToN[zn]; 
	  qv = (long) buffer[0][bj][n];
	  if (qv < 0) qv = 0L - qv; 
	  if (mc->CoefMax[ci][zn] < qv) mc->CoefMax[ci][zn] = qv;  
  } } } } 

  for (ci = pstart; ci <= pend; ci++) {
    for (zn=cstart;zn<=cend;zn++) {
      if (!mc->HaveCoefMax[ci][zn]) { 
        mc->HaveCoefMax[ci][zn] = 1; 
        if (mc->CoefMax[ci][zn] > ans) { 
          ans = mc->CoefMax[ci][zn]; 
  } } } }  

  return ans; 
} 


static int CanExpandScan(int sno, 
  struct jpeg_decompress_struct *cinfo, MaxCoefs *mc) 
{
  int firstc, lastc, Ah, Al;
  jpeg_scan_info * sptr = SavedScanInfo; 
  int i, j, k; 
  char *nextchar = defScanScriptBuffer; 
  int firstAl, maxqvbits = 2; 
  long maxqv; 

  if (!sptr || (sno < 0)) return 0;
  firstc = sptr[sno].Ss;
  lastc = sptr[sno].Se;
  Ah = sptr[sno].Ah; 
  Al = sptr[sno].Al; 
  firstAl = Al + 1; 

  for (i=0;i<sno;i++) { 
    sprintf(nextchar,"%d", sptr[i].component_index[0]);
    nextchar += strlen(nextchar); 
    for (j=1; j < sptr[i].comps_in_scan; j++) {
      sprintf(nextchar," %d", sptr[i].component_index[j]);
      nextchar += strlen(nextchar); 
    } 
    sprintf(nextchar,": %d %d %d %d;\n",
      sptr[i].Ss, sptr[i].Se, sptr[i].Ah, sptr[i].Al); 
    nextchar += strlen(nextchar); 
  } 

  if ((Ah == 0) && cinfo && mc) {
    maxqv = FillMaxCoefs(mc, cinfo, sptr[sno].component_index[0],
	  sptr[sno].component_index[sptr[sno].comps_in_scan-1],
	  firstc, lastc); 
    maxqvbits = 0; 
    while (maxqv) {
      maxqvbits++; 
      maxqv >>= 1;
    }
    firstAl = maxqvbits - 2; 
  } 


  if ((Ah==0) && (firstAl > Al)) { 
    sprintf(nextchar,"%d", sptr[sno].component_index[0]);
    nextchar += strlen(nextchar); 
    for (j=1; j < sptr[sno].comps_in_scan; j++) {
      sprintf(nextchar," %d", sptr[sno].component_index[j]);
      nextchar += strlen(nextchar); 
    } 
    sprintf(nextchar,": %d %d 0 %d;\n",
      sptr[sno].Ss, sptr[sno].Se, firstAl); 
    nextchar += strlen(nextchar); 
    for (i=firstAl; i > Al; i--) {
      sprintf(nextchar,"%d", sptr[sno].component_index[0]);
      nextchar += strlen(nextchar); 
      for (j=1; j < sptr[sno].comps_in_scan; j++) {
        sprintf(nextchar," %d", sptr[sno].component_index[j]);
        nextchar += strlen(nextchar); 
      } 
      sprintf(nextchar,": %d %d %d %d;\n",
        sptr[sno].Ss, sptr[sno].Se, i, i-1); 
      nextchar += strlen(nextchar); 
    }
    return 1; 
  } else if (lastc > firstc) {
    j = (lastc - firstc + 1) / 2; 
    if (j <= 0) j = 1; 
    for (i = firstc; i < lastc; i += j) { 
      sprintf(nextchar,"%d", sptr[sno].component_index[0]);
      nextchar += strlen(nextchar); 
      for (k=1; k < sptr[sno].comps_in_scan; k++) {
        sprintf(nextchar," %d", sptr[sno].component_index[k]);
        nextchar += strlen(nextchar); 
      } 
      k = i + j - 1;
      if (k > lastc) k = lastc; 
      sprintf(nextchar,": %d %d %d %d;\n",
             i, k, Ah, Al); 
      nextchar += strlen(nextchar); 
    } 
    return 1; 
  } else return 0; 


}

#define QualityLessUpper(qual,targ,post) \
   (((post) < (float) 0) || ((qual) <= ((targ) + (post)))) 
#define QualityMoreLower(qual,targ,negt) \
   (((negt) < (float) 0) || ((qual) >= ((targ) - (negt)))) 

#define QualityIsOK(qual,targ,negt,post) \
  ( QualityMoreLower((qual),(targ),(negt)) && \
    QualityLessUpper((qual),(targ),(post)) )


extern long ImSendJpeg(Image *Im,
  int on_original, 
  void *comp_till, 
  char *comp_till_metric,  
  float neg_tolerance,
  float pos_tolerance, 
  int retries_comp_till, 
  DataDest *dd, char **extramem,
  DataDest *qclicdd, char **qclicextramem,
  long *qclicbytes,
  char *qclicqmetric, 
  void * qsrc, long qsrc_bytes, int qsrc_kind,  
  void * ssrc, long ssrc_bytes, int ssrc_kind)   
{
  int have_extramem = (extramem != (char **) 0); 
  int have_qclicextramem = (qclicextramem != (char **) 0); 
  int i, j, numscans, scanno, still_need_implanes, qm_kind =QM_DEFAULT; 
  QclicInfo qclic; 
  int using_internal_ddest = 0, retries; 
  DataDest internal_ddest, *idd; 
  long init_offset, qclic_init_offset=0; 
  int CurrRows=0, CurrCols=0, NumPlanes, is_compressed;
  long PlanePixels = 1; 
  Pixel *ImPlane[3] = {0, 0, 0};
  int AllocedImPlane[3] = {0, 0, 0};
  jvirt_barray_ptr * UseCoeffs = (jvirt_barray_ptr *) 0;  
  Image TempImg;
  int using_TempImg = 0; 
  int using_internal_qsrc = 0, comp_till_kind = QM_SIZE; 
  float comp_target = 0; 
  float target_err = 0; 
  long tot_size = 0;
  MaxCoefs mxcstruct, *mc = 0; 
  struct jpeg_decompress_struct *cinfo_for_mc = 0; 
  int qclic_point_used = -1;
  char qclic_parfile[QCLIC_STRLENMAX]; 

  char *bestJpegData = 0;
  long bestJpegSize; 
  int bestNumScans; 
  float bestJpegErr =0; 

  if (Im->ImState < ImStateReadSome)
    ImNonFatalError("ImSendJpeg: cannot be called before ImReadImg");
  else if (Im->ImState >= ImStateDead)
    ImNonFatalError("ImSendJpeg: image already dead!");

  if (!on_original && !Im->AllPlanesEqual) 
    ImNonFatalError("ImSendJpeg: plane dimensions unequal");

  if (Im->NumPlanes == 1) {
    if (Im->SampleBytes[0] != 1) 
      ImNonFatalError("ImSendJpeg: can only do 8-bit images");
  } else if (Im->NumPlanes == 3) { 
    if ( (Im->SampleBytes[0] != 1)  || 
         (Im->SampleBytes[1] != 1)  || (Im->SampleBytes[2] != 1) ) 
      ImNonFatalError("ImSendJpeg: can only do 8-bit images");
  } else {  
    ImNonFatalError("ImSendJpeg: can only do 1 or 3 planes");
  }  

  if ((Im->NumPlanes == 3) && 
     ((!on_original && (Im->CurrCspace != ImC_RGB)) ||
      (on_original && (Im->OrigCspace != ImC_RGB)))  ) 
    ImNonFatalError("ImSendJpeg: can only do RGB space for 3 planes");

  if (on_original && ImChanged(Im) && (Im->ImState == ImStateReadAll)
	 &&!Im->RetainOrigOnChange) {
    ImNonFatalError("ImSendJpeg: original image has been discarded"); 
  }

  NumPlanes = Im->NumPlanes;

  if (comp_till) { 
    comp_till_kind = QmetricKind(comp_till_metric); 
    if (comp_till_kind == QM_SIZE)
      comp_target = (float) (*((long *) comp_till));
    else 
      comp_target = *((float *) comp_till);
  } 
  if (qclicdd) { 
    if (!qclicbytes) 
      ImNonFatalError("ImSendJpeg: qclicbytes is a NULL ptr"); 
    qm_kind = QmetricKind(qclicqmetric);
  } 

  still_need_implanes = 1; 

  if ((on_original || !ImChanged(Im)) &&
      ImKindSubSetOf(Im->ImKind, IM_JPEG) && Im->jinfo_alive && !qsrc) {
    /* can use existing JPEG coefficients */
    CurrRows = Im->NumRows; 
    CurrCols = Im->NumCols; 
    /* still, will need ImPlane[..] if qclic needs PSNR or
       comp_till needs PSNR */ 
    if ( ! ( (qclicdd && QM_NEEDS_PSNR(qm_kind)) || 
             (comp_till && QM_NEEDS_PSNR(comp_till_kind)) ) ) { 
      still_need_implanes = 0; 
    } 
    UseCoeffs = Im->jpg_info.coef->coef_arrays; 
    PlanePixels = ((long) CurrRows)*CurrCols; 
    GetQTablesFromCinfo(&Im->jpg_info, NumPlanes); 
    qsrc_bytes = (long) strlen(DefQTableBuffer); 
    qsrc = DefQTableBuffer; 
    qsrc_kind = DS_KIND_MEMORY;
    using_internal_qsrc = 1; 
  } 
  
  if (still_need_implanes) {
    if (!on_original || !ImChanged(Im)) { 
      for (i=0;i<NumPlanes;i++) ImPlane[i] = Im->Im[i]; 
      CurrRows = Im->CurrRows[0]; 
      CurrCols = Im->CurrCols[0]; 
      PlanePixels = ((long) CurrRows)*CurrCols; 
    } else {
      CurrRows = Im->NumRows; 
      CurrCols = Im->NumCols; 
      PlanePixels = ((long) CurrRows)*CurrCols; 
  
      for (i=0;i<NumPlanes;i++) {
	  if (Im->Changed[i]) {
	    if (Im->RetainedData[i]) ImPlane[i] = Im->RetainedData[i]; 
	    else ImNonFatalError("ImSendJpeg: original image was not retained"); 
	  } else ImPlane[i] = Im->Im[i]; 
      } 
  } }  

  if (!comp_till) retries_comp_till = 0; 
  else if (retries_comp_till < 0) retries_comp_till = 0; 

  if (have_extramem) {
    DD_Use_Auto_Mem(dd); 
    DD_Set_Auto_Mem_Step(dd,16384);
  } 
  init_offset = DD_total_count(dd); 
  
  if (comp_till) {
    if (!qsrc) {
      qclic_point_used = -1;
      if ((on_original || !ImChanged(Im)) && Im->qclic.have_info
	  && (Im->qclic.curve_points > 0) &&
	  !strncasecmp(Im->qclic.curve_format,"JPEG",4) ) { 
	if (comp_till_kind == QM_SIZE) 
	  qclic_point_used =
	    ImQclicSOnBetterCurve(Im, *((long *) comp_till));
        else if (comp_till_kind == QM_PSIZE) 
	  qclic_point_used =
	    ImQclicSOnBetterCurve(Im, (long)
	      ((float) comp_target * PlanePixels * NumPlanes/100.0));
        else if (comp_till_kind == QM_BPP) 
	  qclic_point_used =
	    ImQclicSOnBetterCurve(Im, (long)
	      ((float) comp_target * PlanePixels /8.0));
	else if (QM_NEEDS_PSNR(comp_till_kind))
	  qclic_point_used =
	    ImQclicQOnCurve(Im, comp_target);
      }

      if (qclic_point_used >= 0) {
	if (!ImQclicCurvePoint(Im, qclic_point_used, 0, 0, 0, qclic_parfile)
	    || !strcmp(qclic_parfile,"")) qclic_point_used = -1;
      }

      if (qclic_point_used < 0) {
        FillDefQTable(CurrRows, CurrCols, NumPlanes,
         comp_target, comp_till_kind); 
        qsrc_bytes = (long) strlen(DefQTableBuffer); 
        qsrc = DefQTableBuffer; 
        qsrc_kind = DS_KIND_MEMORY;
      } else {
        qsrc_bytes = 0;
	qsrc = qclic_parfile;
	qsrc_kind = DS_KIND_FILE;
      }
      using_internal_qsrc = 1; 
    } 
  }

  if (qclicdd || comp_till) {
    if (qclicdd) {
      if (have_qclicextramem) {
	DD_Use_Auto_Mem(qclicdd); 
	DD_Set_Auto_Mem_Step(qclicdd, 512); 
      } 
      qclic_init_offset = DD_total_count(qclicdd); 
    } 
    idd = &internal_ddest;
    DD_Init(idd);
    DD_Use_Auto_Mem(idd);
    DD_Set_Auto_Mem_Step(idd,32768);
    if (!DD_OpenMemory(idd, (char *) 0, 0)) { 
      for (j = 0; j < NumPlanes; j++) {
        if (AllocedImPlane[j]) IM_FREE_PTR(ImPlane[j]); 
      }
      ImNonFatalError("ImSendJpeg: internal error (DD_OpenMemory)"); 
    } 
    using_internal_ddest = 1; 
  } else {
    idd = dd; 
  }

  if (!SendJpegInner( UseCoeffs, ImPlane[0], ImPlane[1], ImPlane[2], 
    NumPlanes, CurrCols, CurrRows, 
    idd, qsrc, qsrc_bytes, qsrc_kind,
    ssrc, ssrc_bytes, ssrc_kind, 
    &numscans)) {
      DD_Free_Auto_Mem(idd); 
      for (j = 0; j < NumPlanes; j++) {
        if (AllocedImPlane[j]) IM_FREE_PTR(ImPlane[j]); 
      }
      ImNonFatalError("ImSendJpeg: error in compression (SendJpegInner)"); 
  }
  
  if (qclic_point_used >= 0) { 
    Im->qclic.curve_better_size[qclic_point_used] = DD_total_count(idd) -
      (using_internal_ddest ? 0 : init_offset);
  }

  if (!using_internal_ddest) { 
    if (have_extramem && DD_using_auto_mem(idd)) *extramem = DD_auto_mem(idd);
    for (j = 0; j < NumPlanes; j++) {
      if (AllocedImPlane[j]) IM_FREE_PTR(ImPlane[j]); 
    }
    return (DD_total_count(idd) - init_offset); 
  }
  
  QclicInfoInit(&qclic);

  bestJpegSize = tot_size = DD_total_count(idd); 
  bestJpegData = DD_auto_mem(idd);
  bestNumScans = numscans; 

  DD_Close(idd); 
  is_compressed = ImIsCompressed(Im); 

  if (comp_till) {

    if (!JpegFillIcurve(&qclic,
	is_compressed, ImPlane[0], ImPlane[1], ImPlane[2], 
      NumPlanes, CurrCols, CurrRows, 
      bestJpegData, tot_size, numscans, 
      comp_till_kind)) {
           IM_FREE_PTR(bestJpegData); 
           for (j = 0; j < NumPlanes; j++) {
             if (AllocedImPlane[j]) IM_FREE_PTR(ImPlane[j]); 
           }
           QclicInfoFree(&qclic);
           ImNonFatalError("ImSendJpeg: error in compression (JpegFillIcurve)"); 
    } 
    
    /* find largest scan # s.t QualityIsOk */
    scanno = numscans;
    while ((scanno > 0) && !QualityIsOK(qclic.icurve_quality[scanno],\
       comp_target, neg_tolerance, pos_tolerance)) scanno--;
    if (scanno > 0) {
      /* done! */
      bestJpegSize = qclic.icurve_size[scanno];
      retries_comp_till = 0;
    } else { 

      /* retain at least one scan */ 
      scanno = 1;
      while ((scanno < numscans) && 
	   (qclic.icurve_quality[scanno+1] <= comp_target)) scanno++;

      bestJpegErr = comp_target - qclic.icurve_quality[scanno];  
      bestJpegSize = qclic.icurve_size[scanno]; 

      if (scanno == numscans) {
        retries_comp_till = 0; 
      } 
    } 

    bestNumScans = numscans = scanno; 

    if ((retries_comp_till > 0) && !UseCoeffs &&
	(using_TempImg == 0)) {
      ImInitImg(&TempImg);
      ImSetSilent(&TempImg);
      ImDiscardOriginal(&TempImg);
      ImSetImgMemory(&TempImg, bestJpegData, tot_size); 
      ImSetRoughIDCT(&TempImg, JDCT_FLOAT); 
      ImSetFinalIDCT(&TempImg, JDCT_FLOAT); 
      if (!ImPeekImg(&TempImg) || !ImReadImg(&TempImg) || 
	 !TempImg.jinfo_alive) {
	ImFreeImg(&TempImg); 
	using_TempImg = -1; 
      } else { 
        UseCoeffs = TempImg.jpg_info.coef->coef_arrays; 
	using_TempImg = 1; 
      } 
    } 

    if (UseCoeffs && (retries_comp_till > 0)) {
      /* fill bit distributions, to be used by CanExpandScan */
      mc = &mxcstruct; 
      InitMaxCoefs(mc); 
      if (using_TempImg) {
	cinfo_for_mc = &(TempImg.jpg_info); 
      } else { 
	cinfo_for_mc = &(Im->jpg_info); 
      } 
    } 

    retries = 0; 

    while ((retries < retries_comp_till) &&
       (qclic.icurve_quality[numscans] != comp_target) &&
       CanExpandScan(numscans, cinfo_for_mc, mc) ) {

      ssrc_bytes = (long) strlen(defScanScriptBuffer); 
      ssrc = defScanScriptBuffer; 
      ssrc_kind = DS_KIND_MEMORY;

      DD_Init(idd);
      DD_Use_Auto_Mem(idd);
      DD_Set_Auto_Mem_Step(idd, qclic.icurve_size[numscans]);  
      (void) DD_OpenMemory(idd, 0, 0); 

      if (!SendJpegInner(UseCoeffs,   
	 ImPlane[0], ImPlane[1], ImPlane[2], 
         NumPlanes, CurrCols, CurrRows, 
         idd, qsrc, qsrc_bytes, qsrc_kind,
         ssrc, ssrc_bytes, ssrc_kind, 
         &numscans)) {
           DD_Free_Auto_Mem(idd); 
	   IM_FREE_PTR(bestJpegData); 
           for (j = 0; j < NumPlanes; j++) {
             if (AllocedImPlane[j]) IM_FREE_PTR(ImPlane[j]); 
           }
           QclicInfoFree(&qclic);
	   if (using_TempImg == 1) ImFreeImg(&TempImg); 
           ImNonFatalError("ImSendJpeg: error in compression (SendJpegInner)"); 
      }
      if (!JpegFillIcurve(&qclic,
	is_compressed, ImPlane[0], ImPlane[1], ImPlane[2], 
        NumPlanes, CurrCols, CurrRows, 
        DD_auto_mem(idd), DD_total_count(idd), numscans, 
        comp_till_kind)) {
           DD_Free_Auto_Mem(idd); 
	   IM_FREE_PTR(bestJpegData); 
           for (j = 0; j < NumPlanes; j++) {
             if (AllocedImPlane[j]) IM_FREE_PTR(ImPlane[j]); 
           }
           QclicInfoFree(&qclic);
	   if (using_TempImg == 1) ImFreeImg(&TempImg); 
           ImNonFatalError("ImSendJpeg: error in compression (JpegFillIcurve)"); 
      } 

      /* find largest scan # s.t QualityIsOk */
      scanno = numscans;
      while ((scanno > 0) && !QualityIsOK(qclic.icurve_quality[scanno],\
         comp_target, neg_tolerance, pos_tolerance)) scanno--;
      if (scanno > 0) {
        /* done! */
        bestJpegSize = qclic.icurve_size[scanno];
        retries_comp_till = 0;
	IM_FREE_PTR(bestJpegData); 
	bestJpegData = DD_auto_mem(idd); 
	bestNumScans = scanno; 
      } else {  
        /* retain at least one scan */ 
        scanno = 1;
        while ((scanno < numscans) && 
	   (qclic.icurve_quality[scanno+1] <= comp_target)) scanno++;

        target_err = comp_target - qclic.icurve_quality[scanno];  

        if (bestJpegErr > target_err) {
	  IM_FREE_PTR(bestJpegData); 
	  bestJpegData = DD_auto_mem(idd); 
	  bestJpegSize = qclic.icurve_size[scanno];
	  bestJpegErr = target_err; 
	  bestNumScans = scanno; 
        } 

        if (scanno == numscans) {
          retries_comp_till = 0;
        } 
      } 

      if (bestJpegData != DD_auto_mem(idd)) {
	DD_Free_Auto_Mem(idd);
      } 

      numscans = scanno; 

      retries++; 
    }

    tot_size = bestJpegSize; 
    ((unsigned char *) bestJpegData)[tot_size-1] = M_EOI; 
    if (using_TempImg == 1) ImFreeImg(&TempImg); 

  } 

  if (qclicdd) { 
    /* generate qclic info */

    if (on_original || !ImChanged(Im)) {
      QclicInfoCopy(&qclic, &(Im->qclic)); 
    } else {
      qclic.width = CurrCols; 
      qclic.height = CurrRows; 
      qclic.planes = NumPlanes; 
      strcpy(qclic.name, Im->ImName);
      strcat(qclic.name, "+changes"); 
      qclic.have_info = 1; 
    }
    qclic.is_lossless = 0; 

    if (DD_file_dest(dd)) {
      dirOf(DD_name(dd), qclic.dir);
      strcpy(qclic.webdir,qclic.dir); 
      fileOf(DD_name(dd), qclic.source); 
    }
    if (dd == qclicdd) strcpy(qclic.source, "."); 

    if (!JpegFillIcurve(&qclic, 
	is_compressed, ImPlane[0], ImPlane[1], ImPlane[2], 
      NumPlanes, CurrCols, CurrRows, 
      bestJpegData, tot_size, bestNumScans, qm_kind)) {
	   IM_FREE_PTR(bestJpegData); 
           for (j = 0; j < NumPlanes; j++) {
             if (AllocedImPlane[j]) IM_FREE_PTR(ImPlane[j]); 
           }
           QclicInfoFree(&qclic);
           ImNonFatalError("ImSendJpeg: error in compression (JpegFillIcurve)"); 
    } 

    (void) QclicInfoWrite(&qclic, qclicdd);
  }

  QclicInfoFree(&qclic);
  for (j = 0; j < NumPlanes; j++) {
    if (AllocedImPlane[j]) IM_FREE_PTR(ImPlane[j]); 
  }

  if (qclicdd) { 
    *qclicbytes = DD_total_count(qclicdd) - qclic_init_offset;
    if (dd == qclicdd) {
      if (have_qclicextramem && DD_using_auto_mem(qclicdd)) {
	IM_FREE_PTR(bestJpegData); 
        DD_Free_Auto_Mem(qclicdd); 
        ImNonFatalError("ImSendJpeg: common destination for compressed image and qclicinfo too small"); 
      }
    } 
  }  


  if (DD_Write(dd, bestJpegData, tot_size) != tot_size) { 
    if (qclicdd) DD_Free_Auto_Mem(qclicdd); 
    DD_Free_Auto_Mem(dd); 
    IM_FREE_PTR(bestJpegData); 
    ImNonFatalError("ImSendJpeg: error writing compressed image"); 
  }

  IM_FREE_PTR(bestJpegData); 
  if (qclicdd && have_qclicextramem && DD_using_auto_mem(qclicdd)) {
    *qclicextramem = DD_auto_mem(qclicdd); 
  }
  if (have_extramem && DD_using_auto_mem(dd)) {
    *extramem = DD_auto_mem(dd); 
  }

  return tot_size; 
} 

#define IsStdin(s) \
  (!(s) || !strcmp(s,"") || !strcmp(s,"-"))

extern long ImSaveJpeg(Image *Im,
  int on_original, 
  void *comp_till, 
  char *comp_till_metric,  
  float neg_tolerance,
  float pos_tolerance, 
  int retries_comp_till, 
  char *fname,
  char *qclicfname,
  long *qclicbytes,
  char *qclicqmetric, 
  void * qsrc, long qsrc_bytes, int qsrc_kind,  
  void * ssrc, long ssrc_bytes, int ssrc_kind)   
{
  DataDest ddest, *dd = &ddest;
  DataDest qclicddest, *qclicdd; 
  long ans; 
  int qclicdd_equals_dd = 0; 
  DD_Init(dd); 
  if (!DD_OpenFile(dd, fname))
    ImNonFatalError("ImSaveJpeg: bad file given");
  if (!qclicfname) {
    qclicdd = (DataDest *) 0;
  } else if ((fname && !strcmp(qclicfname,fname)) || 
             (IsStdin(fname) && IsStdin(qclicfname)) ) { 
    qclicdd = dd;
    qclicdd_equals_dd = 1; 
  } else { 
    qclicdd = &qclicddest; 
    DD_Init(qclicdd); 
    if (!DD_OpenFile(qclicdd, qclicfname)) {
      DD_Close(dd); 
      ImNonFatalError("ImSaveJpeg: bad qclic file given");
    }
  } 
  ans = ImSendJpeg(Im,
    on_original,
    comp_till, comp_till_metric,
    neg_tolerance, pos_tolerance, retries_comp_till,
    dd, (char **) 0,
    qclicdd, (char **)0, qclicbytes, qclicqmetric, 
    qsrc, qsrc_bytes, qsrc_kind,  
    ssrc, ssrc_bytes, ssrc_kind);   

  DD_Close(dd);
  if (qclicfname && !qclicdd_equals_dd) DD_Close(qclicdd); 
  return ans;
}

extern long ImStreamWriteJpeg(Image *Im,
  int on_original, 
  void *comp_till, 
  char *comp_till_metric,  
  float neg_tolerance,
  float pos_tolerance, 
  int retries_comp_till, 
  FILE *fp,  
  FILE *qclicfp,  
  long *qclicbytes,
  char *qclicqmetric, 
  void * qsrc, long qsrc_bytes, int qsrc_kind,  
  void * ssrc, long ssrc_bytes, int ssrc_kind)   
{ 
  DataDest ddest, *dd = &ddest;
  DataDest qclicddest, *qclicdd; 
  long ans; 
  int qclicdd_equals_dd = 0; 
  DD_Init(dd); 
  if (!DD_OpenStream(dd, fp))
    ImNonFatalError("ImStreamWriteJpeg: bad fp given");
  if (!qclicfp) { 
    qclicdd = (DataDest *) 0;
  } else if (qclicfp == fp) { 
    qclicdd = dd;
    qclicdd_equals_dd = 1; 
  } else { 
    qclicdd = &qclicddest; 
    DD_Init(qclicdd); 
    if (!DD_OpenStream(qclicdd, qclicfp)) {
      DD_Close(dd); 
      ImNonFatalError("ImStreamWriteJpeg: bad qclic fp given");
    }
  } 
  ans = ImSendJpeg(Im,
    on_original,
    comp_till, comp_till_metric,
    neg_tolerance, pos_tolerance, retries_comp_till,
    dd, (char **) 0,
    qclicdd, (char **)0, qclicbytes, qclicqmetric, 
    qsrc, qsrc_bytes, qsrc_kind,  
    ssrc, ssrc_bytes, ssrc_kind);   

  DD_Close(dd);
  if (qclicfp && !qclicdd_equals_dd) DD_Close(qclicdd); 
  return ans;
}

extern long ImWriteJpeg(Image *Im,
  int on_original, 
  void *comp_till, 
  char *comp_till_metric,  
  float neg_tolerance,
  float pos_tolerance, 
  int retries_comp_till, 
  int fd,
  int qclicfd,
  long *qclicbytes,
  char *qclicqmetric, 
  void * qsrc, long qsrc_bytes, int qsrc_kind,  
  void * ssrc, long ssrc_bytes, int ssrc_kind)   
{ 
  DataDest ddest, *dd = &ddest;
  DataDest qclicddest, *qclicdd; 
  long ans; 
  int qclicdd_equals_dd = 0; 
  DD_Init(dd); 
  if (!DD_OpenFd(dd, fd))
    ImNonFatalError("ImWriteJpeg: bad fd given");
  if (qclicfd < 0) { 
    qclicdd = (DataDest *) 0;
  } else if (qclicfd == fd) { 
    qclicdd = dd;
    qclicdd_equals_dd = 1; 
  } else { 
    qclicdd = &qclicddest; 
    DD_Init(qclicdd); 
    if (!DD_OpenFd(qclicdd, qclicfd)) {
      DD_Close(dd); 
      ImNonFatalError("ImWriteJpeg: bad qclic fd given");
    }
  } 
  ans = ImSendJpeg(Im,
    on_original,
    comp_till, comp_till_metric,
    neg_tolerance, pos_tolerance, retries_comp_till,
    dd, (char **) 0,
    qclicdd, (char **)0, qclicbytes, qclicqmetric, 
    qsrc, qsrc_bytes, qsrc_kind,  
    ssrc, ssrc_bytes, ssrc_kind);   

  DD_Close(dd);
  if ((qclicfd >= 0) && !qclicdd_equals_dd) DD_Close(qclicdd); 
  return ans;
}


extern long ImBufferJpeg(Image *Im,
  int on_original, 
  void *comp_till, 
  char *comp_till_metric,  
  float neg_tolerance,
  float pos_tolerance, 
  int retries_comp_till, 
  char *buff, long buffsize, char **extramem,
  char *qclicbuff, long qclicbuffsize, char **qclicextramem,
  long *qclicbytes,
  char *qclicqmetric, 
  void * qsrc, long qsrc_bytes, int qsrc_kind,  
  void * ssrc, long ssrc_bytes, int ssrc_kind)   
{
  DataDest ddest, *dd = &ddest;
  DataDest qclicddest, *qclicdd; 
  long ans; 
  DD_Init(dd); 
  if (!DD_OpenMemory(dd, buff, buffsize))
    ImNonFatalError("ImBufferJpeg: bad memory-buffer given");
  if (!qclicbuff) 
    qclicdd = (DataDest *) 0;
  else { 
    qclicdd = &qclicddest; 
    DD_Init(qclicdd); 
    if (!DD_OpenMemory(qclicdd, qclicbuff, qclicbuffsize)) {
      DD_Close(dd); 
      ImNonFatalError("ImBufferJpeg: bad qclic memory-buffer given");
    }
  } 
  ans = ImSendJpeg(Im,
    on_original,
    comp_till, comp_till_metric,
    neg_tolerance, pos_tolerance, retries_comp_till,
    dd, extramem, 
    qclicdd, qclicextramem, qclicbytes, qclicqmetric, 
    qsrc, qsrc_bytes, qsrc_kind,  
    ssrc, ssrc_bytes, ssrc_kind);   

  DD_Close(dd);
  if (qclicbuff) DD_Close(qclicdd); 
  return ans;
}

#endif /* HAVE_JPEGLIB */



