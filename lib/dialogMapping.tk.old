#!/usr/local/bin/wish -f
# tian zhang 01/20/95
# this procedure use a dialog box to input and edit mapping.
# The interface of dialogMapping:
# proc dialogMapping {w title text bitmap mappings GetName}
#
# w: window name
# title: window title
# text: text message
# bitmap: bitmap to be displayed
# mappings: mapping params in the following form:
# { { name1 {{attr type} {attr type} ...} {default mapping 1} }
#   { name2 {{attr type} {attr type} ...} {default mapping 2}}
#  ...
# }
# For example:
# { {x { {time date} {name string} {temp int} } time }
#   {y { {time date} {name string} {temp int} } temp }
#   {color { {1 black} {2 red} {3 yellow} } 3 }
#  ...
# }
# getName: set true to display the name of the mapping.
# REturn: 
#	if netName == false, the new mapping.
#	else, a list containing {mappingName mapping}
#############################################################################

global flag button1 button2 choice

# Find maximum length in attrName of list of the following form:
# { {attrName attrType } { attrName attrType } ... }
proc FindAttrNameMaxLength { maps } {
	set len 1
	foreach map $maps {
		set attrName [lindex $map 0]
		set temp [string length $attrName]
#		puts "attrName $attrName length $temp"
		if { $temp > $len} {
			set len $temp
		}
	}
	return $len
}

# Find maximum length in attrType of list of the following form:
# { {attrName attrType } { attrName attrType } ... }
proc FindAttrTypeMaxLength { maps } {
	set len 1
	foreach map $maps {
		set attrType [lindex $map 1]
		set temp [string length $attrType]
		if { $temp > $len} {
			set len $temp
		}
	}
	return $len
}

# Find the maximum length of mappings
proc MappingMaxLength { mappings } {
	set len 1
	foreach item $mappings {
		set name [lindex $item 0]
		set temp [string length $name]
		if { $temp > $len} {
			set len $temp
		}
		set maps [lindex $item 1]
		set temp [FindAttrNameMaxLength $maps]
		if { $temp > $len} {
			set len $temp
		}
		set temp [FindAttrTypeMaxLength $maps]
		if { $temp > $len} {
			set len $temp
		}

		set default [lindex $item 2]
		set temp [string length $default]
		if { $temp > $len} {
			set len $temp
		}

	}
	return $len
}

proc dialogMapping {w title text bitmap mappings {getName 0} } { 

global flag button1

# find max length for entry
set entryWidth [expr [MappingMaxLength  $mappings]*2+5]
# puts "entryWidth = $entryWidth, getName = $getName"

set flag [lindex [lindex $mappings 0] 0]

# setup toplevel widget

# default options for Frame, Button
set tmpFrameOpt ""
set tmpButtonOpt ""

# destroy the old widget with the same name if there exists one
if {"[info commands XFDestroy]" != ""} {
    catch {XFDestroy $w}
} else {
    catch {destroy $w}
}

# toplevel widget parameters
toplevel $w -borderwidth 4
catch "$w config $tmpFrameOpt"
wm geometry $w +00+00
# wm geometry $w 400x150
wm maxsize $w 1000 1000
wm minsize $w 100 100
wm title $w $title
wm iconname $w DialogMapping

#############################################################################

# display TEXT or BITMAP in a sub widget
label $w.message -relief raised -text "$text" -bitmap "$bitmap" \
	-font -*-*-medium-r-normal-*-140-*-*-m-*
catch "$w.message config $tmpFrameOpt" 

############################################################################

# handle mapping: {x y color shape ...} in a sub widget
frame $w.mapping -borderwidth 4 -relief raised
catch "$w.mapping config $tmpFrameOpt"
frame $w.mapping.gdata -borderwidth 0 -relief raised
catch "$w.mapping.gdata config $tmpFrameOpt"
frame $w.mapping.map -borderwidth 0 -relief raised
catch "$w.mapping.map config $tmpFrameOpt"

# create the name widget
set nameMsgWidget ""
set nameEntryWidget ""
if { $getName } {
	set nameMsgWidget $w.mapping.gdata.mapNameMsg
	set nameEntryWidget $w.mapping.map.mapNameEntry
	entry $nameMsgWidget  -relief raised -width 10 
	$nameMsgWidget insert 0 "mapName"
	$nameMsgWidget configure -state disabled
	entry $nameEntryWidget  -relief sunken -width $entryWidth
	set item0 [lindex $mappings 0]
	set item1 [lindex $mappings 1]
	set initName [UniqueName [format {%s_vs_%s} [lindex $item1 2] [lindex $item0 2]]]
	$nameEntryWidget insert 0 $initName
}

# XXX:This is hard coded
set xWidget $w.mapping.map.valx
set yWidget $w.mapping.map.valy

foreach item $mappings {
    set itemname [lindex $item 0]
    radiobutton $w.mapping.gdata.$itemname -text $itemname \
	    -command "DoButton $w {$item} $getName $xWidget $yWidget $nameEntryWidget" \
	    -width 10
    catch "$w.mapping.gdata.$itemname config $tmpButtonOpt"
    entry $w.mapping.map.val$itemname -relief sunken -width $entryWidth
    catch "$w.mapping.map.val$itemname config $tmpFrameOpt"
    $w.mapping.map.val$itemname delete 0 end
    $w.mapping.map.val$itemname insert 0 [lindex $item 2]
}

#############################################################################

# handle decision: ok cancel in a sub widget
#############################################################################
frame $w.decision -borderwidth 4 -relief raised
catch "$w.decision config $tmpFrameOpt"

# Ok: return new mapping
button $w.decision.ok -text "Ok" -command  { set button1 1 }
catch "$w.decision.ok config $tmpButtonOpt"

# Cancel: return old mapping
button $w.decision.cancel -text "Cancel" -command { set button1 0 }
catch "$w.decision.cancel config $tmpButtonOpt"
#############################################################################

# packings
#############################################################################
pack append $w.decision \
	$w.decision.cancel {left fill expand} \
	$w.decision.ok {left fill expand} 

foreach item $mappings {
    set itemname [lindex $item 0]
    pack append $w.mapping.gdata $w.mapping.gdata.$itemname {top fill expand}
    pack append $w.mapping.map $w.mapping.map.val$itemname {top fill expand}
}

# Pack the mapping name widget
if { $getName } {
	pack append $w.mapping.gdata $nameMsgWidget {top fill expand}
	pack append $w.mapping.map $nameEntryWidget {top fill expand}
}

pack append $w.mapping \
	$w.mapping.gdata {left fill expand} \
	$w.mapping.map {right fill expand}

pack append $w \
	$w.message {top fill} \
	$w.mapping {top fill} \
	$w.decision {bottom fill} 
#############################################################################

#############################################################################
tkwait variable button1
set newmap ""
if { $button1 == 1 } {
   foreach item $mappings {
   set itemname [lindex $item 0]
   lappend newmap [$w.mapping.map.val$itemname get]
   }

   if {$getName } {
	set newmap [list [$nameEntryWidget get] $newmap]
   }
} 
if {"[info commands XFDestroy]" != ""} {
    catch {XFDestroy $w}
} else {
    catch {destroy $w}
}
return $newmap
}
#############################################################################

proc DoButton {w item { getName 1} { xWidget "" } {yWidget ""} \
	{ nameEntryWidget "" } } {
global flag
set choice [DisplayAndSelect $w $item]
if {$choice != ""} {
    $w.mapping.map.val$flag delete 0 end
    $w.mapping.map.val$flag insert 0 $choice

#	Change name of widget
# puts "DoButton getName = $getName"
	if { $getName } {
		set mapName [UniqueName [format {%s_vs_%s} [$yWidget get] [$xWidget get]]]
		$nameEntryWidget delete 0 end
		$nameEntryWidget insert 0 $mapName
	}
}
}


#############################################################################
proc DisplayAndSelect {w item} { 

global flag button2 choice
set flag [lindex $item 0]
set choice ""
set itemname [lindex $item 0]

set tmpFrameOpt ""
set tmpButtonOpt ""
set tmpScrollOpt ""

toplevel $w.schema -borderwidth 4 -relief raised
catch "$w.schema config $tmpFrameOpt"
wm geometry $w.schema +120+120
# wm geometry $w.schema 500x300
wm maxsize $w.schema 1000 1000
wm minsize $w.schema 100 100
wm title $w.schema "Data Schema"

label $w.schema.message -relief raised -text "Select $flag" -bitmap ""
catch "$w.schema.message config $tmpFrameOpt"

frame $w.schema.decision -borderwidth 4 -relief raised
catch "$w.schema.decision config $tmpFrameOpt"
button $w.schema.decision.ok -text "Ok" -command {set button2 1}
catch "$w.schema.decision.ok config $tmpButtonOpt"
button $w.schema.decision.cancel -text "Cancel" -command {set button2 0}
catch "$w.schema.decision.cancel config $tmpButtonOpt"

set attrs [lindex $item 1]
set attrNameWidth [expr [FindAttrNameMaxLength $attrs]+1]
set attrTypeWidth [expr [FindAttrTypeMaxLength $attrs]+1]

frame $w.schema.content -borderwidth 4 -relief raised
catch "$w.schema.content config $tmpFrameOpt"
# vertical scrollbar
scrollbar $w.schema.content.yscroll \
	-command "DoScroll $w.schema.content" \
	-relief raised
catch "$w.schema.content.yscroll config $tmpScrollOpt"

set attrNameGeometry [ format {%sx10} $attrNameWidth]
listbox $w.schema.content.attrs -exportselection false -relief raised \
	-yscrollcommand "$w.schema.content.yscroll set" \
	-geometry $attrNameGeometry
catch "$w.schema.content.attrs config $tmpFrameOpt"

set attrTypeGeometry [ format {%sx10} $attrTypeWidth]
listbox $w.schema.content.types -exportselection false -relief raised \
	-yscrollcommand "$w.schema.content.yscroll set"  \
	-geometry $attrTypeGeometry
catch "$w.schema.content.types config $tmpFrameOpt"

foreach attr $attrs {
    $w.schema.content.attrs insert end "[lindex $attr 0]"
    $w.schema.content.types insert end "[lindex $attr 1]"
}

bind $w.schema.content.attrs <ButtonPress-1> \
	{SelectAttr1 %W %y}
bind $w.schema.content.attrs <Double-Button-1> \
	{SelectAttr1 %W %y}
bind $w.schema.content.types <ButtonPress-1> \
	[list SelectAttr2 $w.schema.content.attrs %W %y]
bind $w.schema.content.types <Double-Button-1> \
	[list SelectAttr2 $w.schema.content.attrs %W %y]

pack append $w.schema.decision \
	$w.schema.decision.cancel {left fill expand} \
	$w.schema.decision.ok {left fill expand}
pack append $w.schema.content \
	$w.schema.content.attrs {left fill expand} \
	$w.schema.content.yscroll {left filly} \
        $w.schema.content.types {left fill expand}
pack append $w.schema \
	$w.schema.message {top fill} \
	$w.schema.content {top fill} \
	$w.schema.decision {bottom fill}

tkwait variable button2
if {"[info commands XFDestroy]" != ""} {
    catch {XFDestroy $w.schema}
} else {
    catch {destroy $w.schema}
}
if {$button2 == 1} {
    return $choice
} else {
    return ""
}
}
	
proc DoScroll {box index} {
   $box.attrs yview $index
   $box.types yview $index
}

proc SelectAttr1 {attrW attrY} {
    global choice
    set attrNearest [$attrW nearest $attrY]
    if { $attrNearest >=0 } {
	$attrW select from $attrNearest
	$attrW select to $attrNearest
    }
    set attr [$attrW get $attrNearest]
    set choice [lindex $attr 0]
}

proc SelectAttr2 {attrW typeW attrY} {
    global choice
    set attrNearest1 [$typeW nearest $attrY]
    if {$attrNearest1 >=0 } {
	$typeW select from $attrNearest1
	$typeW select to $attrNearest1
    }
    set attrNearest2 [$attrW nearest $attrY]
    if {$attrNearest2 >=0 } {
	$attrW select from $attrNearest2
	$attrW select to $attrNearest2
    }
    set attr [$attrW get $attrNearest2]
    set choice [lindex $attr 0]
}
