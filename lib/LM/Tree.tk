#!/s/tcl/bin/wish -f
# A widget to display hierarchies (similar to the Windows widget)
# Creates collapsible tree structures which can expanded and collapsed
# by pressing buttons

global winInfo
global circleDist 
set circleDist 30
global textDist
set textDist 50
global winDist 
set winDist 50

proc CreateWin { c name x y lastWin parent } {
    global winInfo 
    global circleDist textDist
	
    set circleX [expr $x + $circleDist]
    set textX [expr $x + $textDist]
    
    if { $lastWin != "" } {
	set x0 [lindex $winInfo($lastWin) 0]
	set y0 [lindex $winInfo($lastWin) 1]
	$c create line $x0 $y0 $x $y -tags $lastWin.down
	$c lower $lastWin.down
    }

    $c create line $x $y $circleX $y -tags $name.side
    button $c.but_$name -text "+" -command  \
	    "Expand $c $name 1"  -bg yellow 
    $c create window $x $y \
	    -window $c.but_$name  -tags $name.but
    $c create oval [expr $circleX - 3] [expr $y - 3] \
	    [expr $circleX + 3] [expr $y + 3] -fill red -outline black \
	    -tags "$name.oval oval"
    $c create text $textX $y -text $name -anchor w -tags "$name.text text"
    
    set winInfo($name) [list $x $y 0 $parent]
    if { $lastWin != "" } {
	set winInfo($lastWin) [lappend winInfo($lastWin) $name]
    }
    puts "Creating $name : $winInfo($name)"
}

proc CreateBinding { w  tag but procName  } {
    $w bind $tag $but  "ExecProc $w {$procName}"
}

proc ExecProc  { w procName } {
    set tags [$w gettags current] 
    puts "$tags"
    set name [lindex $tags 0]
    puts "$name"
    set splitList [split $name "."]
    puts $splitList
    eval "$procName [lindex $splitList 0] "
}

proc Expand { c name dir } {
    global winInfo 
    global winDist circleDist

    puts "Expanding $name : $winInfo($name)"
    if { $dir > 0 } {
	$c.but_$name configure -text "-"
	set winInfo($name) [lreplace $winInfo($name) 2 2 1]
	$c.but_$name configure -command "Expand $c $name -1"
    } else {
	$c.but_$name configure -text "+"
	set winInfo($name) [lreplace $winInfo($name) 2 2 0]
	$c.but_$name configure -command "Expand $c $name 1"
    }
    set children [GetChildren $name]
    set numChildren [llength $children]
    if { !$numChildren } {
	return
    }
    set x0 [expr [lindex $winInfo($name) 0] + $circleDist]
    set y0 [lindex $winInfo($name) 1]
    if { $dir > 0 } {
	CreateChildBranch $c $name $x0 $y0 
	set lastWin ""
	foreach child $children {
	    incr y0 $winDist
	    CreateWin $c $child $x0 $y0 $lastWin $name
	    set lastWin $child
	}
    } else {
	catch  { $c delete $name.child }
	foreach child $children {
	    DestroyWin $c $child
	}
    }
    set next [lindex $winInfo($name) 4]
    set totalMove [expr $numChildren * $dir * $winDist]
    
    MoveDown $c $name 0 $totalMove $dir
}

proc CreateChildBranch { c name x y } {
    global winDist
    $c create line $x $y $x [expr $y + $winDist] -tags $name.child
    $c lower $name.child
}

proc StretchDown { c name next amount} {
    global winInfo
    set y1 [expr [lindex $winInfo($next) 1] + $amount]
    puts "y1 = $y1"
    $c coords $name.down \
	    [lindex $winInfo($name) 0] \
	    [lindex $winInfo($name) 1] \
	    [lindex $winInfo($name) 0] $y1
}


proc DestroyWin { c name } {
    global winInfo
    catch { $c delete $name.but }
    catch { $c delete $name.text }
    catch { $c delete $name.side }
    catch { $c delete $name.down }
    catch { $c delete $name.oval }
    destroy $c.but_$name
    set state [lindex $winInfo($name) 2]
    if { $state } {
	$c delete $name.child
	foreach child [GetChildren $name] {
	    DestroyWin $c $child
	}
    }
    unset winInfo($name)
}


proc MoveDown { c name xamount yamount dir } {
    global winInfo
    if { $name == "" } {
	return
    }
    puts "$name : $winInfo($name)"
    
    set next [lindex $winInfo($name) 4]
    if { $next == "" } {
	return
    }
    StretchDown $c $name $next $yamount 
    MoveFwd $c $next $xamount $yamount $dir
    set parent [lindex $winInfo($name) 3]
    if { $parent == "" } {
	return
    } else {
	MoveDown $c $parent $xamount $yamount $dir
    }
}

# In fact xamount == 0
proc MoveFwd { c name xamount yamount dir } {
    global winInfo
    if { $name == "" } {
	return
    }
    
    puts "$name : $winInfo($name)"
    $c move $name.but $xamount $yamount
    $c move $name.text $xamount $yamount
    $c move $name.side $xamount $yamount
    $c move $name.oval $xamount $yamount
    catch { $c move $name.down $xamount $yamount }

    set x0 [lindex $winInfo($name) 0]
    set y0 [lindex $winInfo($name) 1]

    set state [lindex $winInfo($name) 2]
    set winInfo($name) \
	    [lreplace $winInfo($name)  1 1 [expr $y0 + $yamount] ]
    if { $state } {
	set firstChild [lindex [GetChildren $name] 0] 
	MoveFwd $c $firstChild $xamount $yamount $dir
    }
    set next [lindex $winInfo($name) 4]
    MoveFwd $c $next $xamount $yamount $dir
}

proc AddChild { w  name child } {
    global winInfo circleDist winDist

    # if this window is not yet expanded we dont have to do anything
    if { ! [CheckExpanded $w $name] } {
	return
    }
    set children [GetChildren $name]
    puts "child : $children"
    if { [llength $children] == 0 } {
	set lastWin ""
	set x [expr [lindex $winInfo($name) 0]  + $circleDist]
	set y [expr [lindex $winInfo($name) 1]  + $winDist]
	CreateChildBranch $w $name $x [lindex $winInfo($name) 1] 
    } else {
	set lastWin [lindex $children end]
	set x [lindex $winInfo($lastWin) 0]
	set y [expr [lindex $winInfo($lastWin) 1] + $winDist]
    }
    CreateWin $w $child $x $y $lastWin $name 
    MoveDown $w $name 0 $winDist 1
}

proc CheckExpanded { w name } {
    global winInfo
    
    if { [$w find withtag $name.but] != "" } {
	puts " Found $winInfo($name)"
	return [lindex $winInfo($name) 2]
    } else {
	return 0
    }
}

# Delete semantics ???  Assume all children have been deleted before parent ? 
proc DeleteChild { w name child } {
    global winInfo circleDist winDist
    # if this window is not expanded we dont have to do anything
    
    if { ![CheckExpanded $w $name] } {
	return
    }
    if { [llength [GetChildren $child]] != 0 } {
	puts "Delete Children first"
	return
    }
    set children [GetChildren $name]
    set numChildren [llength $children]
    set lastWin ""
    set index [lsearch $children $child]
    if { $index == -1 } {
	return
    }
    set next [lindex $winInfo($child) 4]
    set prevIndex [expr $index - 1]
    set prev [lindex $children $prevIndex]
    DestroyWin $w $child
    if { $index != 0 } {  
	set winInfo($prev) [lreplace $winInfo($prev) 4 4 $next]
	puts "Modified $winInfo($prev)"
    }
    if { $next == "" } {
	if { $index == 0 } {
	    $w delete $name.child
	} else {
	    $w delete $prev.down
	}
    } else {
	MoveFwd $w $next 0 [expr $winDist * -1] -1
	# if not first child, have to rearrange next pointers
    }
    MoveDown $w $name 0 [expr $winDist * -1] -1
}


#########test 
#global children
#set children(Display) [list frame1 frame2 frame3]
#set children(frame1) [list a b c]
#set children(a) {}
#set children(b) {}
#set children(c) {}
#set children(frame2) [list x y z w]
#set children(x) [list x1 x2 x3]
#set children(x1) {}
#set children(x2) {}
#set children(x3) {}
#set children(y) [list y1 y2 y3]
#set children(y1) {}
#set children(y2) {}
#set children(y3) {}
#set children(z) [list z1 z2 z3]
#set children(z1) {}
#set children(z2) {}
#set children(z3) {}
#set children(w) {}
#set children(frame3) [list foo bar baz qux mix]
#set children(foo) {}
#set children(bar) [list foo1 foo2]
#set children(foo1) {}
#set children(foo2) {}
#set children(baz) {}
#set children(qux) {}
#set children(mix) {}


global rootx  rooty
set rootx 30
set rooty 30
#global lastWin 
#set lastWin ""
#CreateWin $c Display $rootx $rooty $lastWin ""







