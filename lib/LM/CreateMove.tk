# General bindings and routines for the main canvas of the application

### create button bindings to highlight current object

global highlightColor
set highlightColor #c4d1df
global glassColor
set glassColor grey
global currentWin
set currentWin ""
$canvas bind glass <Enter> {
    $canvas itemconfigure current -fill $highlightColor
    set tags [$canvas gettags current]
    puts "tags = $tags"
    if { [lsearch [$canvas gettags current] newRect] != -1 } {
	puts "Rect being created"
	set curname $name(newChild)
	set fg $colorFg(newChild)
    } else {
	set curname [lindex [$canvas gettags current] 0]
	set fg [LM getFgColor $curname]
    }
    puts "curname = $curname, fg = $fg"
    $canvas create text 400 400   -text $curname -tags curTxt \
	    -fill $fg
    $canvas raise curTxt
}
$canvas bind glass <Leave> {
    $canvas itemconfigure current -fill $glassColor
    $canvas delete curTxt
}

# some utility functions used in lots of places

proc MapWindow { name origX origY relX relY width height color} {
    global canvas frameWidth
    set x1 [expr $origX + $relX]
    set y1 [expr $origY + $relY]
    set x2 [expr $x1 + $width]
    set y2 [expr $y1 + $height]
    set tags [$canvas find withtag $name]
    if { $tags == "" } {
	DrawFixedFrame $canvas $name $x1 $y1 $x2 $y2 $color 0
    } else {
	ReDrawWindow $name $x1 $y1 $x2 $y2 $frameWidth
    }
}
proc UnMapWindow { name } {
    global canvas 
    $canvas delete $name
    $canvas delete Frame_$name
}

proc DrawOutline { win index  } {
    global name origX origY relX relY dimH dimW colorBg 
    
    # compute actual x and y coordinates 
    
    set x1 [expr $relX($index) + $origX($index)]
    set y1 [expr $relY($index) + $origY($index)]
    set x2 [expr $x1 + $dimW($index)]
    set y2 [expr $y1 + $dimH($index)]

    DrawFixedFrame $win $name($index) $x1 $y1 $x2 $y2 $colorBg($index) 0
}


proc DrawFixedFrame { win name x1 y1 x2 y2 color bd } {
    global glassColor
    $win create rectangle \
	    $x1 $y1 \
	    $x2 $y2 \
	    -outline $color \
	    -width $bd -tags "$name glass" \
	    -fill $glassColor \
}

proc SetEditableTag { win name } {
    global win 
    $win addtag editable $name
}

proc ReSetEditableTag { win name } {
    global win
    $win dtag editable $name
}

proc DeepenFrame {win name color bd } {
    global glassColor 
    set coords [$win coords $name]
    set x1 [lindex $coords 0]
    set y1 [lindex $coords 1]
    set x2 [lindex $coords 2]
    set y2 [lindex $coords 3]
    
    $win create polygon \
	    $x1 $y1 \
	    $x2 $y1 \
	    $x2 $y2 \
	    $x1 $y2 \
	    $x1 $y1 \
	    [expr $x1 + $bd] [expr $y1 + $bd] \
	    [expr $x2 - $bd] [expr $y1 + $bd] \
	    [expr $x2 - $bd] [expr $y2 - $bd] \
	    [expr $x1 + $bd] [expr $y2 - $bd] \
	    [expr $x1 + $bd] [expr $y1 + $bd] \
	    -outline black \
	    -fill $color -tags "Frame_$name frame"
}

$canvas bind frame <Double-1> {
    #set  item [$canvas find withtag current]
    set tags [ $canvas gettags current]
    puts "tags = $tags"
    if { $tags == "" } {
	set currentWin ""
    }
    if { [lsearch $tags newRect ] == -1 } {
	set currentTag [lindex $tags 0]
	puts "currentTag = /$currentTag/"
	set currentWin [string range $currentTag 6 end]
	puts $currentWin
    }
}
$canvas bind glass <Double-1> {
    #set  item [$canvas find withtag current]
    set tags [ $canvas gettags current]
    puts "tags = $tags"
    if { $tags == "" } {
	set currentWin ""
    }
    if { [lsearch $tags newRect ] == -1 } {
	set currentWin [lindex $tags 0]
    }
}

####Move Routines and bindings

$canvas bind glass <Button-2> {
    global movingWin beingCreated
    set tags [$canvas gettags current]
    set movingWin [lindex $tags 0]
    
    puts "movingWin = $movingWin"
    if {$movingWin == "Display"} {
	set movingWin ""
	return
    }

    # if the window in question is being created
    if { [lsearch $tags newRect] != -1 } {
	CopyWinParams movingWin newChild
	set beingCreated 1
    } else {
	SetWinParams movingWin movingWin
	set beingCreated 0
    }
    #PrintWinParams movingWin
    
    set parentWin $parent(movingWin)
    SetWinParams parentWin parentWin

    PrintWinParams movingWin
    PrintWinParams parentWin
    
    set maxX(movingWin) [expr $dimW(parentWin) - 2 * $frameWidth]
    set maxY(movingWin) [expr $dimH(parentWin) - 2 * $frameWidth]
    global newX1 newY1 newX2 newY2
    set newX1 $relX(movingWin)
    set newY1 $relY(movingWin)
}

$canvas bind glass <B2-Motion> {
    global frameWidth movingWin beingCreated
    global name origX origY maxX maxY dimW dimH
    global newX1 newY1 

    #changing relative position only using pointer position as center
    
    puts "B2-Motion"
    if { $movingWin == "" } {
	return
    }
    set oldX1 $newX1
    set oldY1 $newY1
    
    set newX1 [expr %x - $dimW(movingWin) / 2 - $origX(movingWin)]
    set newY1 [expr %y - $dimH(movingWin) / 2 - $origY(movingWin)]
    
    set newX2 [expr $newX1 + $dimW(movingWin)]
    set newY2 [expr $newY1 + $dimH(movingWin)]

    puts "maxX = $maxX(movingWin)"
    puts "maxY = $maxY(movingWin)"
    if { [expr ($newX1 < 0 ) || ($newY1 < 0) \
            || ($newX2 > $maxX(movingWin))  \
            || ($newY2 > $maxY(movingWin)) ] } {
	set newX1 $oldX1
	set newY1 $oldY1
	puts "returning"
    } else {
	puts "maxX = $maxX(movingWin)"
	puts "maxY = $maxY(movingWin)"
	set hasKids [expr !$beingCreated]
	MoveWindow $name(movingWin)  \
		[expr $origX(movingWin) + $newX1] \
		[expr $origY(movingWin) + $newY1] \
		[expr $origX(movingWin) + $newX2] \
		[expr $origY(movingWin) + $newY2] \
		$frameWidth $hasKids
    }
    
}


$canvas bind glass <ButtonRelease-2> {
    global movingWin newX1 newY1 origX origY frameWidth
    global name beingCreated

    puts "B2-Release"
    if { $movingWin == "" } {
	return
    }
    #    puts "Updating $movingWin $newX1 $newY1 "

    if { !$beingCreated } {
	LM moveWindow $movingWin $newX1 $newY1
	puts "After moving : "
	LM printWindow $movingWin 
	# move orig of child to abs position of left top corner of parent
	LM printWindow $movingWin
	set origMovingWinX  [expr $origX(movingWin) + $newX1 + $frameWidth] 
	set origMovingWinY  [expr $origY(movingWin) + $newY1 + $frameWidth] 

	foreach child [LM getChildren $movingWin] {
	    UpdatePosition $child $origMovingWinX $origMovingWinY $frameWidth
	}
    }
    puts "--------------current : " 
    PrintWinParams current
    puts "--------------edit"
    PrintWinParams edit
    if { $movingWin == $currentWin } {
	set relX(current) $newX1
	set relY(current) $newY1
	set relX(edit) $newX1
	set relY(edit) $newY1
    } elseif { $beingCreated } {
	set relX(newChild) $newX1
	set relY(newChild) $newY1
    }
	
    puts "---------------------After current : " 
    PrintWinParams current
    puts "---------------------------edit"
    PrintWinParams edit
    set movingWin ""
}


proc UpdatePosition { name origX origY bd } {
    puts "Updating origin for $name : $origX $origY"

    LM setOrig $name $origX $origY
    set posn [LM getPosn $name]
    set posX [expr $origX + [lindex $posn 2] + $bd]
    set posY [expr $origY + [lindex $posn 3] + $bd]
    puts "new posn -> $posn"

    foreach child [LM getChildren $name] {
	puts "$child : setting origin to ....$origX $origY"
	# calculate pos of child so that its children may be updated
	UpdatePosition $child $posX $posY $bd
	LM printWindow $child
    }
}

proc MoveWindow { name x1 y1 x2 y2 bd dorecursive } {
    puts "About to move window $name"

    ReDrawWindow $name $x1 $y1 $x2 $y2 $bd
    if { !$dorecursive } {
	return
    }
    set origChildX [expr $x1 + $bd]
    set origChildY [expr $y1 + $bd]
    foreach child [LM getChildren $name ]  {
	set posn [LM getPosn $child]
	puts "posn = $posn"
	#coords 0 and 1 are the old abs coords
	set x1child [expr $origChildX + [lindex $posn 2]]
	set y1child [expr $origChildY + [lindex $posn 3]]
	set x2child [expr $x1child + [lindex $posn 4]]
	set y2child [expr $y1child + [lindex $posn 5]]
	MoveWindow $child $x1child $y1child $x2child $y2child $bd $dorecursive
    }
}

proc ReDrawWindow { name x1 y1 x2 y2 bd } {
    global canvas
    $canvas coords $name $x1 $y1 $x2 $y2 
    
    if { [$canvas find withtag Frame_$name] == "" } {
	return
    }

    $canvas coords Frame_$name \
	    $x1 $y1 \
	    $x2 $y1 \
	    $x2 $y2 \
	    $x1 $y2 \
	    $x1 $y1 \
	    [expr $x1 + $bd] [expr $y1 + $bd] \
	    [expr $x2 - $bd] [expr $y1 + $bd] \
	    [expr $x2 - $bd] [expr $y2 - $bd] \
	    [expr $x1 + $bd] [expr $y2 - $bd] \
	    [expr $x1 + $bd] [expr $y1 + $bd] 
}

proc CreateWindow { } {
    global name origX origY relX relY dimH dimW colorBg colorFg layoutMode
    global canvas frameWidth
    global currentWin newChild newParent

    set newParent $currentWin
    if { $currentWin == "" } {
	Message "Please double click on the window you want to \
		create the new window in"
    }
    set w .createWindow
    toplevel $w
    
    if { $layoutMode(newParent) != "custom" } {
	CreatePropertiesDialog $w newChild 0
    } else {
	CreatePropertiesDialog $w newChild 1
    }
    SetDefaultValues 
    set newChild $name(newChild)

    ControlPropertyEdit $w newChild

    puts "newChild = $newChild"
    # check if it has children
    set isFrame [LM numChildren $newParent]

    if { ! $isFrame } {
	DeepenFrame $canvas $newParent $colorBg(newParent) $frameWidth
    }
    if { $layoutMode(newParent) == "custom" } {
	PositionRect 
    }
    set but [Buttons $w [list Cancel Configure Ok]]
    
    
    catch { destroy $w }
    
    if { $but == 0 } {
	AbortCreation $isFrame 
	return
    } elseif { $but == 2 } {
	if { $newChild == "" } {
	    dialog .errorLM  "LM Error Message" \
		    "No Window Name specified" "" 0 "Ok"
	    AbortCreation $isFrame
	    return
	}
	global standalone
	if { !$standalone } {
	    global tdata
	    if { $tdata(newChild) == "" } {
		dialog .errorLM "LM Error Message" \
			"No TData specified" "" 0 "Ok"
		AbortCreation $isFrame
		return
	    }
	}
	puts "newChild = $newChild. name(newchild) = $name(newChild)"
	if { $newChild != $name(newChild) } {
	    DoRename $newChild $name(newChild)
	}
	ConfigureWin $newChild newChild
	catch { $canvas dtag newRect }
	WinTreeAddChild $newParent $newChild 
	DoActualCreateWindow  newChild
    }
    if { !$standalone } {
	global tdata autoTData
	# Create DEVise view
	SendCommandToDEVise "DEViseCreateView $name(newChild) \
		$colorBg(newChild)\
		$tdata(newChild) $autoTData(newChild)"
	global datdirLM
	LM setTData $newChild $datdirLM/$tdata(newChild) \
		.LMCat.$tdata(newChild)
    }
    set newRect ""
    set newParent ""
}

proc AbortCreation { isFrame } {
    global canvas name
    catch { $canvas delete newRect }
    if { !$isFrame } {
	$canvas delete "Frame_$name(newParent)"
    }
    return 
}

proc PositionRect { } {
    global canvas 
    global newChild newParent
    global name relX relY dimH dimW colorBg colorFg layoutMode level
    
    DrawOutline $canvas newChild
#    DrawFixedFrame $canvas $name($w) $x0 $y0 $x1 $y1 $colorBg($w) 0
    $canvas addtag newRect withtag  $name(newChild)
}

proc DoActualCreateWindow { index } {
    global name 
    global origX origY relX relY 
    global dimH dimW colorBg colorFg layoutMode level parent
    global layoutRow layoutCol

    # for now ignore color
    # also origin should be relative to parent
    if { $parent($index) != "" } {
	set res [LM createWindow $name($index) \
		$origX($index) $origY($index) $relX($index) $relY($index) \
		$dimW($index) $dimH($index)\
		$colorBg($index) $colorFg($index) $parent($index)] 
    } else {
	set res [LM createWindow $name($index) \
		$origX($index) $origY($index) $relX($index) $relY($index) \
		$dimW($index) $dimH($index)\
		$colorBg($index) $colorFg($index)] 
    }
    
    if { $res != "Done" } {
	return
    }
    LM setLayoutProperties $name($index) $layoutMode($index) \
	    $layoutRow($index) $layoutCol($index)
    LM printWindow $name($index)

    SetSaveState 1
    
    return
}


proc DeleteWindow { } {
    global currentWin
    if { $currentWin == "Display" } {
	dialog .errorLM  "LM Error Message" \
		"Display cannot be deleted" "" 0 "Ok"
	return
    }
    set children [LM getChildren $currentWin]
    if { [llength $children] != 0 } {
	set mesg "Frame $currentWin has children : \
		Do you want to delete all child Frames also ? " 
	set but [dialog .errorLM "LM Error Message" $mesg "" 0 Cancel OK]
	if { $but == 0 } {
	    return
	}
    }
    global parent
    DoActualDeleteWindow $currentWin $parent(current) 1
    set currentWin Display
}



proc DoActualDeleteWindow { win parent remap } {
    foreach child [LM getChildren $win] {
	puts "$child"
	DoActualDeleteWindow $child $win 0
    }
    WinTreeDeleteChild $parent $win
    LM deleteWindow $win $remap
    UnMapWindow $win
    SetSaveState 1
}















