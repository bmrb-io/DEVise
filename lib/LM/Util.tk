# consists of some utility functions
# code borrowed partly from DEVise

############################################################

proc UniqueName {name} {
    while { [LM exists $name] } {
	set len [string length $name]
	set lastChar [string index $name [expr $len - 1]]
	if { [scan $lastChar "%d" temp] == 1 } {
	    # numeric for the last character
	    set name [format "%s%d" [string range $name 0 [expr $len - 2]] \
		    [expr $lastChar + 1]]
	} else {
	    set name "$name 2"
	}
    }
    return $name
}

############################################################

# Return line width of string. New lines are accounted for.
# For example, "abc\ndefg" has a line width of 4

proc LineWidth { txt } {
    set strLen [string length $txt]
    set width 0
    set curWidth 0
    for { set i 0} { $i < $strLen } {set i [expr $i+1] } {
	if { [string compare [string index $txt $i] \n] == 0 } {
	    if {$curWidth > $width} {
		set width $curWidth
	    }
	    set curWidth 0
	} else {
	    set curWidth [expr $curWidth+1]
	}
    }
    if {$curWidth > $width} {
	set width $curWidth
    }
    return $width
}

############################################################

# Return # of lines in string 
# For example, "abc\ndefg" has 2 lines

proc LineHeight { txt } {
    set strLen [string length $txt]
    set height 0
    for { set i 0} { $i < $strLen } {set i [expr $i+1] } {
	if { [string compare [string index $txt $i] \n] == 0 } {
	    set height [expr $height+1]
	}
    }
    set height [expr $height+1]
    return $height
}

############################################################

proc DoExit {} {
    set answer [ dialog .quit "Quit" \
	    "Are you sure you want to quit?" "" 0 \
	    { OK } { Cancel} ]
    if { $answer == 0 } {
	DEVise exit
	destroy .
    }
}

############################################################

proc getColor {varname} {
    global $varname DEViseColors

    if {[WindowVisible .getColor]} {
	return
    }

    toplevel .getColor
    wm title .getColor "Choose Color"
    wm geometry .getColor +100+100

    frame .getColor.top -relief groove -borderwidth 2
    frame .getColor.bot
    pack .getColor.top -side top -fill both -expand 1
    pack .getColor.bot -side top -pady 5m -fill x
    frame .getColor.bot.but
    pack .getColor.bot.but -side top

    set row -1
    set col -1
    set maxcol 8
    set size 5

    foreach val $DEViseColors {
	set cindex [lindex $val 0]
	set color [lindex $val 1]
	if {$col < 0} {
	    incr row
	    set col 0
	    frame .getColor.top.row$row
	    pack .getColor.top.row$row -side top -fill x -expand 1
	}
        if {$cindex >= 1000} {
            # for colors >= 1000, we want to display their names (e.g. "XOR")
            # instead of the color index values
            button .getColor.top.row$row.col$col -background black \
                    -activebackground black -width $size -text $color \
                    -command "set $varname $color; destroy .getColor"
        } else {
            button .getColor.top.row$row.col$col -background $color \
                    -activebackground $color -width $size -text $cindex \
                    -command "set $varname $color; destroy .getColor"
        }
        pack .getColor.top.row$row.col$col -side left -fill x -expand 1
	incr col
	if {$col >= $maxcol} {
	    set col -1
	}
    }
    
    # Add empty frames at end of last row
    for {} {$row >= 0 && $col >= 0 && $col < $maxcol} {incr col} {
	button .getColor.top.row$row.col$col -relief flat -width $size \
		-state disabled
	pack .getColor.top.row$row.col$col -side left -fill x -expand 1
    }

    button .getColor.bot.but.cancel -text Cancel -width 10 \
	    -command "set $varname cancel; destroy .getColor"
    pack .getColor.bot.but.cancel -side left

    tkwait visibility .getColor
    grab set .getColor
    tkwait window .getColor
}


proc ScaleUpper {val} {
    set scale {0 0.001 0.01 0.1 1 2 5 10 20 30 40 50 100 200 300 400 500
               1000 2000 3000 4000 5000 10000 50000 100000}
    foreach s $scale {
	if {$val < $s} {
	    # puts "$val, upper $s"
	    return $s
	}
    }
    return $val
}

proc ScaleLower {val} {
    set scale {0 0.001 0.01 0.1 1 2 5 10 20 30 40 50 100 200 300 400 500
               1000 2000 3000 4000 5000 10000 50000 100000}
    set prevs $val
    foreach s $scale {
	if {$val < $s} {
	    # puts "$val, lower $prevs"
	    return $prevs
	}
	set prevs $s
    }
    return $prevs
}

proc WindowVisible {w} {
    # see if $w already exists
    set err [catch {set state [wm state $w]}]
	
    if {$err} {
	return 0
    }

    if {$state == "iconic"} {
	wm deiconify $w
    } else {
	wm withdraw $w
	wm deiconify $w
    }

    return 1
}

proc WindowExists {w} {
    # see if $w already exists
    set err [catch {set state [wm state $w]}]
	
    if {$err} {
	return 0
    }

    return 1
}

############################################################

proc AbortProgram {reason} {
    if {[WindowVisible .abort]} {
	return
    }

    toplevel .abort
    wm title .abort "Internal Error"
    wm geometry .abort +100+100
    message .abort.msg -justify center -width 10c \
	    -text "An internal error has occurred. The error message is\
	           printed in the text window.\n\n\
		   If the error is reproducible, please send the error\
		   message along with a description of how the error\
		   can be produced to devise-sup@cs.wisc.edu.\n\n\
		   The program will now exit."
    button .abort.exit -text Exit -width 10 -command "destroy .abort"
    pack .abort.msg .abort.exit -side top -padx 5m -pady 3m

    tkwait visibility .abort
    grab set .abort
    tkwait window .abort
}
############################################################

proc  Max { a b } {
    if { $a > $b } {
	return $a
    } else {
	return $b
    }
}


proc Min { a b } {
    if { $a < $b } {
	return $a
    } else {
	return $b
    }
}


############################################################

proc Message { str } {
    toplevel .msg
    wm title .msg "LM Error Message"
    message .msg.txt -text "$str" -justify left -width 5c -relief raised \
	    -bd 2
    button  .msg.ok -text "Ok" -width 4 -command { destroy .msg }
    pack    .msg.txt -expand 1 -fill both
    pack    .msg.ok -side bottom 
}
