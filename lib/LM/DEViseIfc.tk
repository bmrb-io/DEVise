global autoSchema schemadir
if { [info exist env(LM_AUTO_SCM)] } {
    set autoSchema $schemadir/physical/$env(LM_AUTO_SCM)
} else {
    set autoSchema $schemadir/physical/CONTAINER_SCM 
}

proc DEViseCreateView { viewname bgcolor table isauto} {
    global autoSchema datdirLM 
    if { $isauto } {
	set retVal "[addQuotes $table] Table $autoSchema \
		$datdirLM/$table [addQuotes ""]"
	puts "retVal = $retVal"
	DEVise dteInsertCatalogEntry .LMCat $retVal
	set tdata .LMCat.$table
	set fp [open $datdirLM/$table w]
	close $fp
    } else {
	set tdata $table
    }
    set tdata_schema_pair [OpenAndDefineDataSources 0 $tdata]
    puts "tdata : $tdata_schema_pair"
    if { $tdata_schema_pair == "" } {
	puts "tdata = NULL "
	return
    } 
    set tdata [lindex $tdata_schema_pair 0]
    set schemaname [lindex $tdata_schema_pair 1]
    set is_dte_type [lindex $tdata_schema_pair  2]
    set topgrp [SelectTopGroup $schemaname]

    set grplist [DEVise getItems $schemaname $topgrp $topgrp]
    
    puts "grplist = $grplist"
    
    set attrList {}
    foreach itm $grplist {
	set attrList [lappend attrList [lindex $itm 0]]
    }
    puts $attrList

    if {$is_dte_type} {
	if {[lsearch [TdataSet] $tdata] < 0} {
	    set result [DEVise create tdata $tdata $tdata "$attrList" ]
	    set tdata $result
	    puts "tdata = $tdata"
	}
    }
   CreateViewMapping $viewname $bgcolor $schemaname $tdata $attrList $isauto
}

# Since the UpdateMappingDialog proc is quite cluttered up with stuff I 
# dont understand, I am creating this function. There is a lot of code
# repeated here. So someday this should be replaced with the UpdateMapping
# dialog function with appropriate changes. The main reason this is different
# is that the view has not been created yet and so its mapping is being
# created and not edited. 

proc CreateViewMapping { curView bgcolor \
	schemaname tdata attrList {isauto 0}} {
    global DEViseOldColors DEViseShapes
    if { !$isauto } {
	set w .editMapping
	BringUpMappingDialog .editMapping $curView
	
	if { ! [winfo exists $w] } {
	    return
	}
	$w.message.txt configure -text "Edit Mapping for : $curView"
	
	# Some defaults so that the dialog box doesnt seem empty :)
	set xParm "\$[lindex $attrList 0]"
	set yParm "\$[lindex $attrList 0]"
	set zParm 1
	set colorParm red
	set sizeParm 1
	set patternParm ""
	set orientParm ""
	set shapeParm "Bar"
	set shapeAttr0 ""
	set shapeAttr1 ""
	set shapeAttr2 ""
	set shapeAttr3 ""
	set shapeAttr4 ""
    } else { 
	# Defaults for auto mapping
	set xParm "\$x"
	set yParm "\$y"
	set zParm ""
	set colorParm red
	set sizeParm 1
	set patternParm ""
	set orientParm ""
	set shapeParm "View"
	set shapeAttr0 "\$shapeattr1"
	set shapeAttr1 "\$shapeattr2"
	set shapeAttr2 "\$shapeattr3"
	set shapeAttr3 ""
	set shapeAttr4 ""
    }
    set mappings [list \
	    [list X $xParm] \
	    [list Y $yParm] \
	    [list Z $zParm] \
	    [list Color $colorParm] \
	    [list Size $sizeParm] \
	    [list Pattern $patternParm] \
	    [list Orientation $orientParm] \
	    [list Shape $shapeParm ] \
	    [list "ShapeAttr0" $shapeAttr0] \
	    [list "ShapeAttr1" $shapeAttr1] \
	    [list "ShapeAttr2" $shapeAttr2] \
	    [list "ShapeAttr3" $shapeAttr3] \
	    [list "ShapeAttr4" $shapeAttr4]]
    
    set topgrp [SelectTopGroup $schemaname]
    foreach item $mappings {
	set itemname [lindex $item 0]
	set itemval [lindex $item 1]

	global mappingValue$itemname
	
	if { !$isauto } {
	    catch { destroy $w.mapping.value.p$itemname.menu.variable }
	    
	    setupAttrRadioMenu $w.mapping.value.p$itemname.menu.variable \
		    mappingValue$itemname "\$" $schemaname $topgrp $topgrp
	}
	set mappingValue$itemname $itemval
	puts "mappingValue$itemname = [deref mappingValue$itemname]"
    }

    if { !$isauto } {
	$w.but.apply configure -command \
		" DefineViewAndMapping {$curView} $bgcolor {$mappings} $tdata "
	UpdateShapeAttrs $w $shapeParm
    } else {
	puts "mappings = $mappings"
	DefineViewAndMapping $curView $bgcolor $mappings $tdata 1
    }
}

proc PrintNewMapping { mappings } {
    puts "----------mapping----------------"
    
    foreach item $mappings {
	set itemname [lindex $item 0]
	global mappingValue$itemname
	puts " $itemname = [deref mappingValue$itemname]"
    }
}

# The initial x and y chosen in the mapping dialog may be expressions!
proc DefineView { viewinstance bgcolor tdata x y } {
    set schema [DEVise getSchema $tdata]
    set colorAttr ""
    set sortedx 0
    set xlo ""
    set xhi ""
    
    # Find out type of X and whether it is sorted or not.
    # Also find out if there is a 'color' attribute.

    set xattr "_Unknown__"
    set yattr "_Unknown__"
    
    puts "x = $x , y = $y"
    
    foreach attr $schema {
	set attrName [lindex $attr 0]
	if { $attrName == $x } {
	    set xattr $attr
	} 
	if { $attrName == $y } {
	    set yattr $attr
	}
    }
    ProcessAttrInfo  $xattr xname xtype sortedx \
	    xhi xlo colorAttr "x" 0
    puts "$xname $xtype $sortedx $xhi $xlo $colorAttr"
    
    if {$sortedx > 0} {
        set sortedx SortedX
    } else {
        set sortedx Scatter
    }

    set view_exist 0
    set titletext ""
    set mmmtext ""
    set mmm_view ""

    set colorY ""
    ProcessAttrInfo $yattr yname type sorted yhi ylo colorY "y" 0
    puts "$yname $type $sorted $colorY $yhi $ylo"
    
    if { [lsearch [ViewSet] $viewinstance] >= 0 } {
	dialog .viewError "View Error"\
		"View $viewinstance exists already." "" 0 OK
	return 
    }
    
    set result [DEVise create view $sortedx $viewinstance \
	    $xlo $xhi $ylo $yhi $bgcolor]
    if { $result == "" } {
	dialog .viewError "View Error" \
		"Error creating view $viewinstance" "" 0 OK
	return 
    }
    # No special cases considered yet. DOnt understand them well enough
    
    # The following have been put as defaults. Dont really know if it is
    # in line with whatever convention is used. Could be done later.
    set titletext "$y vs. $x"
    DEVise setLabel $viewinstance 1 16 $titletext
    DEVise setAxisDisplay $viewinstance X 0
    DEVise setAxisDisplay $viewinstance Y 0
    DEVise clearViewHistory $viewinstance
    DEVise insertViewHistory $viewinstance $xlo $ylo $xhi $yhi 0
    
    puts "Created view $viewinstance"
}

proc DefineViewAndMapping { viewinstance bgcolor mappings tdata {isauto 0}} {
    set newmap ""
    foreach item $mappings {
	set itemname [lindex $item 0]
	global mappingValue$itemname
	lappend newmap [deref mappingValue$itemname]
    }
    set x [string trimleft $mappingValueX "$"]
    set y [string trimleft $mappingValueY "$"]
    puts "x = $x . y = $y "
    DefineView $viewinstance $bgcolor $tdata $x $y
    
    set mapname [format "%s_vs_%s" $y $x]
    
    if { [lsearch [DEVise get mapping] $mapname] < 0 } {
	set result [DEVise createMappingClass $mapname]
    }
    
    set mapinstance [UniqueName $tdata#$mapname]
    
    ## Dont take care of special cases here. We'll see later what todo 
    ## about them.

    set createCmd "DEVise create mapping $mapname $tdata \
	    $mapinstance {} $newmap"
    
    puts "$createCmd"
    set result [eval $createCmd]
    
    DEVise setPixelWidth $mapinstance 1
    
    # ask DEVise to insert $mapinstance into $viewinstance
    set result [DEVise insertMapping $viewinstance $mapinstance]
}


proc DEViseCreateXWindow { view x y w h} {
    set newwin [ DoCreateWindow "Select Window type" 1 $x $y $w $h ]
    puts "newwin = $newwin"

    DEVise insertWindow $view $newwin 
}






