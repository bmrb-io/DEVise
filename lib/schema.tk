#  ========================================================================
#  DEVise Data Visualization Software
#  (c) Copyright 1992-1996
#  By the DEVise Development Group
#  Madison, Wisconsin
#  All Rights Reserved.
#  ========================================================================
#
#  Under no circumstances is this software to be copied, distributed,
#  or altered in any way without prior permission from the DEVise
#  Development Group.

############################################################

#  $Id$

#  $Log$
#  Revision 1.15  1996/01/19 18:33:57  jussi
#  Several minor fixes.
#
#  Revision 1.14  1996/01/17 18:05:01  jussi
#  Default UserMode value is now set in control.tk.
#
#  Revision 1.13  1996/01/08 18:54:45  jussi
#  Cleaned up a bit the code and rearranged focus grabs. Removed some
#  bugs related to operating on new and old schemas with no hi or
#  lo values specified for some attributes.
#
#  Revision 1.12  1995/12/20 07:03:00  ravim
#  High and low values of attrs can be specified.
#
#  Revision 1.11  1995/12/15 03:38:20  ravim
#  User mode used for displaying schemas.
#
#  Revision 1.10  1995/12/12 01:46:29  ravim
#  Physical/Logical schema support.
#
#  Revision 1.9  1995/12/11 18:02:31  ravim
#  Enhanced schema creation. Now also displays list of attributes.
#
#  Revision 1.8  1995/11/30 02:21:06  ravim
#  Changed some colors and removed debugging puts.
#
#  Revision 1.7  1995/11/20 22:18:35  jussi
#  Changed from datadir to schemadir.
#
#  Revision 1.6  1995/11/19 06:03:24  ravim
#  Initial version of user/superuser modes and handling of logical/physical
#  schemas.
#
#  Revision 1.5  1995/11/01 01:37:55  ravim
#  Several minor changes.
#
#  Revision 1.4  1995/10/25 19:21:46  ravim
#  Added new types.
#
#  Revision 1.3  1995/10/17 05:16:32  ravim
#  Can define arbitrary group structures.
#
#  Revision 1.2  1995/10/11 17:08:10  ravim
#  Minor changes.
#
#  Revision 1.4  1995/10/11 17:02:38  ravim
#  Decoupled the main program. Uses datadir to display schema files.
#
#  Revision 1.3  1995/10/11 01:48:28  ravim
#  Added colors. Can modify attributes in place.
#
#  Revision 1.2  1995/10/04 20:48:33  ravim
#  Handled case when no schema file is selected.
#
# Revision 1.1  1995/10/03  03:40:53  ravim
# Initial revision
#

############################################################

set catalogFile $schemadir/catalog.tcl
if {![file exists $catalogFile]} {
    puts "Cannot read catalog file for physical to logical associations"
    exit 1
}
source $catalogFile

#-----------------------------------------------------------
#		PROCEDURES
#-----------------------------------------------------------

# Procedure called from the control panel - figures out which procedure
# to execute based on the user mode specified in the .rc file
proc SchemaBrowse {} {
    global UserMode

    if {$UserMode == 0} {
	SchemaSuperuser
    } else {
	SchemaUser
    }
}

proc SchemaEdit {mode} {
    if {$mode == 0} {
	SchemaSuperuser
    } else {
	SchemaUser
    }
}

# Schema browser for  a normal user - can manipulate only the logical schema
proc SchemaUser {} {
    global schemadir physchema
    # Show a list of currently defined physical schemas and buttons to either
    # create a Open one of these

    toplevel .psch -bg red4
    wm title .psch "Current Schemas"
    wm geometry .psch +50+50

    frame .psch.top -relief raised -bg honeydew2
    frame .psch.mid -relief raised -bg honeydew2
    frame .psch.bot -relief raised -bg honeydew2
    pack .psch.top .psch.mid .psch.bot -side top -fill x -padx 1m -pady 1m

    # Label on top
    label .psch.top.label -text "Schemas" -bg honeydew2 -fg red4
    pack .psch.top.label

    # Listbox with scrollbar in the middle
    listbox .psch.mid.list -relief raised -bd 1 \
	    -yscrollcommand ".psch.mid.scroll set" \
	    -font 9x15 -selectmode single -bg honeydew2
    scrollbar .psch.mid.scroll -command ".psch.mid.list yview" -bg honeydew2
    pack .psch.mid.scroll -side right -fill y
    pack .psch.mid.list -fill x

    # Search for files in the schema/physical directory to populate the list
    set flist [glob $schemadir/physical/*]
    foreach fname $flist {
	.psch.mid.list insert end [file tail $fname]
    }    

    # Button to Open or Quit
    button .psch.bot.attr -text "Attributes" -bg gray75 -fg IndianRed4 \
	    -command {
	set physchema [.psch.mid.list get active]
	if {$physchema == ""} {
	    showmesg "Please choose a schema by clicking on the entry."
	} else {
	    displayattrs $physchema
	}
    }
    button .psch.bot.view -text "Views" -bg gray75 -fg IndianRed4 -command {
	set physchema [.psch.mid.list get active]
	if {$physchema == ""} {
	    showmesg "Please choose a schema by clicking on the entry."
	} else {
	    destroy .psch
	    displogical $physchema
	}
    }
    button .psch.bot.quit -text Quit -bg gray75 -fg IndianRed4 -command {
	destroy .psch
    }
    pack .psch.bot.attr .psch.bot.view .psch.bot.quit \
	    -side left -padx 3m -pady 1m -expand 1

    tkwait window .psch
}

########################################################
# Schema browser for the superuser - can change both physical and logical parts
proc SchemaSuperuser {} {
    global schemadir
    # Show a list of currently defined schemas and buttons to either
    # create a New one or Open an existing one

    toplevel .psch -bg red4
    wm title .psch "Physical Schemas"
    wm geometry .psch +50+50

    frame .psch.top -relief raised -bg honeydew2
    frame .psch.mid -relief raised -bg honeydew2
    frame .psch.bot -relief raised -bg honeydew2
    pack .psch.top .psch.mid .psch.bot -side top -fill x -padx 1m -pady 1m

    # Label on top
    label .psch.top.label -text "Schemas" -bg honeydew2 -fg red4
    pack .psch.top.label

    # Listbox with scrollbar in the middle
    listbox .psch.mid.list -relief raised -bd 1 \
	    -yscrollcommand ".psch.mid.scroll set" \
	    -font 9x15 -selectmode single -bg honeydew2
    scrollbar .psch.mid.scroll -command ".psch.mid.list yview" -bg honeydew2
    pack .psch.mid.scroll -side right -fill y
    pack .psch.mid.list -fill x

    # Search for files in the schema/physical directory to populate the list
    set flist [glob $schemadir/physical/*]
    foreach fname $flist {
	.psch.mid.list insert end [file tail $fname]
    }

    # Buttons at bottom
    button .psch.bot.new -text New -bg gray75 -fg IndianRed4 -command {
	destroy .psch
	newschema
    }
    button .psch.bot.open -text Open -bg gray75 -fg IndianRed4 -command {
	set sel [.psch.mid.list get active]
	if {$sel == ""} {
	    showmesg "Select the schema to edit by clicking once on the entry."
	} else {
	    destroy .psch
	    openschema $sel
	}
    }
    button .psch.bot.del -text Remove -bg gray75 -fg IndianRed4 -command {
	set sel [.psch.mid.list get active]
	if {$sel == ""} {
	    showmesg "Select the schema to remove by clicking once on the entry."
	} else {
	    dialog .rem "Remove Schema" \
		    "This will remove the schema and all defined views." \
		    "" 0 Yes No
	    if {$button == 0} {
		exec rm $schemadir/physical/$sel
		foreach log $Logical($sel) {
		    exec rm $schemadir/logical/$log
		}
		unset Logical($sel)
		writecatalog
		.psch.mid.list delete active
	    }
	}
    }

    button .psch.bot.quit -text Quit -bg gray75 -fg IndianRed4 -command {
	destroy .psch
    }
    pack .psch.bot.new .psch.bot.open .psch.bot.del .psch.bot.quit -side left \
	    -padx 3m -pady 1m -expand 1

    tkwait window .psch
}

#############################################################
# This procedure creates a window depicting all the fields for the schema
# and their values if any.
proc newschemawin {} {
    global sname ftype comm separ attrlist aname atype asort attrnum \
	    tgrps glist Logical

    # Count number of attributes
    set attrnum 0

    toplevel .newschema -bg red4
    wm title .newschema "Schema Description"
    wm geometry .newschema +50+50
    
    # Top level rows in the window
    frame .newschema.firstrow -relief raised -bg honeydew2
    frame .newschema.commseprow -relief raised  -bg honeydew2
    frame .newschema.opt -relief raised  -bg honeydew2
    frame .newschema.attr -relief raised -bg honeydew2
    pack .newschema.firstrow  .newschema.commseprow .newschema.attr \
	    .newschema.opt 	-side top -fill x -padx 1m -pady 1m
    
    #-----------------------------------------------------------
    # Within first row - name and type
    frame .newschema.fname -relief raised -bd 1 -bg honeydew2
    frame .newschema.ftype -relief raised -bd 1 -bg red4
    pack .newschema.fname .newschema.ftype -in .newschema.firstrow \
	    -side left -fill x -padx 3m -pady 1m
    
    label .newschema.fname.label -text "Schema Name " -bg honeydew2 -fg red4
    entry .newschema.fname.entry -width 25 -relief sunken -bd 2 \
	    -textvariable sname -bg bisque
    pack .newschema.fname.label .newschema.fname.entry -side left -padx 1m \
	    -pady 1m
    
    label .newschema.ftype.label -text "File Type"  -bg honeydew2 -fg red4
    radiobutton .newschema.ftype.ascii -text Ascii -variable ftype \
	    -value ascii -anchor nw -bg honeydew2
    radiobutton .newschema.ftype.binary -text Binary -variable ftype \
	    -value binary -anchor nw -bg honeydew2
    pack .newschema.ftype.label .newschema.ftype.ascii .newschema.ftype.binary \
	    -side top -fill x
    
    #-----------------------------------------------------------
    # Comment and separator characters
    frame .newschema.comm -relief raised -bg honeydew2
    frame .newschema.separ -relief raised -bg honeydew2
    pack .newschema.comm -side left  -in .newschema.commseprow \
	    -padx 3m -pady 1m 
    pack .newschema.separ -side right  -in .newschema.commseprow \
	    -padx 3m -pady 1m
    
    label .newschema.comm.label -text "Comment characters"  -bg honeydew2 -fg red4
    entry .newschema.comm.entry -width 5 -relief sunken -bd 2 \
	    -textvariable comm -bg bisque
    pack .newschema.comm.label .newschema.comm.entry -side left \
	    -padx 1m -pady 1m
    
    label .newschema.separ.label -text "Separator characters"  -bg honeydew2 -fg red4
    entry .newschema.separ.entry -width 5 -relief sunken -bd 2 \
	    -textvariable separ -bg bisque
    pack .newschema.separ.label .newschema.separ.entry -side left \
	    -padx 1m -pady 1m 
    
    #-----------------------------------------------------------
    # Attributes
    frame .newschema.attrlist -relief raised  -bg honeydew2
    frame .newschema.attradd -relief raised -bg honeydew2
    pack .newschema.attrlist -in .newschema.attr \
	    -side top -padx 3m -pady 1m -fill x
    pack .newschema.attradd -in .newschema.attr \
	    -side bottom -padx 3m -pady 1m -fill x
    
    label .newschema.attrlist.label -text "List of Attributes" -bg honeydew2 -fg red4
    label .newschema.attrlist.spec -text "Type      Order     Hi     Lo     Name" -bg honeydew2 -fg red4 -font 9x15
    pack .newschema.attrlist.label -side top -fill x
    pack .newschema.attrlist.spec -side top -anchor nw
    listbox .newschema.attrlist.list -relief raised -bd 1 \
	    -yscrollcommand ".newschema.attrlist.scroll set" \
	    -xscrollcommand ".newschema.attrlist.xscroll set" \
	    -font 9x15 -selectmode extended -bg honeydew2
    scrollbar .newschema.attrlist.scroll \
	    -command ".newschema.attrlist.list yview" -bg honeydew2
    scrollbar .newschema.attrlist.xscroll -orient horizontal \
	    -command ".newschema.attrlist.list xview" -bg honeydew2
    pack .newschema.attrlist.scroll -side right -fill y
    pack .newschema.attrlist.xscroll -side bottom -fill x
    pack .newschema.attrlist.list -fill x 
    
    # By default insert all elements of attrlist into the list
    foreach attr $attrlist {
	# Format before inserting
	set ttype [lindex $attr 0]
	set tsort [lindex $attr 1]
	set thival [lindex $attr 2]
	set tloval [lindex $attr 3]
	set tname [lindex $attr 4]
	set fstr [format "%-8s  %-8s  %-6s %-6s %s" $ttype $tsort $thival $tloval $tname]
	.newschema.attrlist.list insert end $fstr
	set attrnum [expr $attrnum+1]
    }
    
    frame .newschema.attrspec -relief raised -bg honeydew2
    frame .newschema.attrop -relief raised -bg honeydew2
    pack .newschema.attrspec .newschema.attrop \
	    -in .newschema.attradd -side top -fill x -padx 3m -pady 1m
    
    frame .newschema.attrname -relief raised -bd 1 -bg honeydew2
    frame .newschema.atype -relief raised -bd 1 -bg honeydew2
    frame .newschema.asort -relief raised -bd 1 -bg honeydew2
    frame .newschema.ahival -relief raised -bd 1 -bg honeydew2
    frame .newschema.aloval -relief raised -bd 1 -bg honeydew2
    pack .newschema.attrname .newschema.atype .newschema.asort \
	    .newschema.ahival .newschema.aloval \
	    -in .newschema.attrspec -side top -fill x -padx 3m -pady 1m
    
    label .newschema.attrname.label -text "Attribute Name " -bg honeydew2 -fg red4
    entry .newschema.attrname.entry -width 25 -relief sunken -bd 2 \
	    -textvariable aname -bg bisque
    pack .newschema.attrname.label .newschema.attrname.entry -side left -padx 3m \
	    -pady 1m
    
    label .newschema.ahival.label -text "Attribute High Value " -bg honeydew2 -fg red4
    entry .newschema.ahival.entry -width 25 -relief sunken -bd 2 \
	    -textvariable ahival -bg bisque
    pack .newschema.ahival.label .newschema.ahival.entry -side left -padx 3m \
	    -pady 1m
    
    label .newschema.aloval.label -text "Attribute Low Value  " -bg honeydew2 -fg red4
    entry .newschema.aloval.entry -width 25 -relief sunken -bd 2 \
	    -textvariable aloval -bg bisque
    pack .newschema.aloval.label .newschema.aloval.entry -side left -padx 3m \
	    -pady 1m
    
    
    label .newschema.atype.label -text "Type   " -bg honeydew2 -fg red4
    radiobutton .newschema.atype.double -text double -variable atype \
	    -value "double" -anchor nw -bg honeydew2
    radiobutton .newschema.atype.int -text int -variable atype \
	    -value "int" -anchor nw -bg honeydew2
    radiobutton .newschema.atype.string -text string -variable atype \
	    -value "string" -anchor nw -bg honeydew2
    radiobutton .newschema.atype.float -text float -variable atype \
	    -value "float" -anchor nw -bg honeydew2
    radiobutton .newschema.atype.date -text date -variable atype \
	    -value "date" -anchor nw -bg honeydew2
    pack .newschema.atype.label .newschema.atype.double .newschema.atype.int \
	    .newschema.atype.string .newschema.atype.float \
	    .newschema.atype.date  -side left -fill x -padx 1m 
    label .newschema.asort.label -text "Sorted "  -bg honeydew2 -fg red4
    radiobutton .newschema.asort.yes -text Yes -variable asort \
	    -value "sorted" -anchor nw -bg honeydew2
    radiobutton .newschema.asort.no -text No -variable asort \
	    -value "unsorted" -anchor nw -bg honeydew2
    pack .newschema.asort.label .newschema.asort.yes .newschema.asort.no \
	    -side left -fill x -padx 1m
    
    button .newschema.attrop.add -text "Add item" -bg gray75 -fg IndianRed4 -command {
	if {$ahival == ""} {
	    set ahival "none"
	}
	if {$aloval == ""} {
	    set aloval "none"
	}
	set aname [lindex [string trim $aname] 0]
	if {$aname == ""} {
	    showmesg "Attribute name has not been specified."
	    return
	}
	# Increment count
	set attrnum [expr $attrnum+1]
	# Insert into list and clear selection
	set fstr [format "%-8s  %-8s  %-6s %-6s %s" $atype $asort $ahival $aloval $aname]
	.newschema.attrlist.list insert end $fstr
	set aname ""
	set atype "double"
	set asort "unsorted"
	set ahival ""
	set aloval ""
    }
    button .newschema.attrop.delete -text "Delete item" -bg gray75 -fg IndianRed4\
	    -command {
	.newschema.attrlist.list delete active
	# Decrement count
	set attrnum [expr $attrnum-1]
    }
    # Set up key binding for modify list
    bind .newschema.attrlist.list <Double-1> {
	set attrl [.newschema.attrlist.list get active] 
	set atype [lindex $attrl 0]
	set asort [lindex $attrl 1] 
	set ahival [lindex $attrl 2]
	set aloval [lindex $attrl 3]
	set aname [lindex $attrl 4]
    }
    
    button .newschema.attrop.modify -text "Modify item" -bg gray75 -fg IndianRed4\
	    -command {
	set aname [lindex [string trim $aname] 0]
	if {$aname == ""} {
	    showmesg "Double-click on an item to select it."
	    return
	}
	if {$ahival == ""} {
	    set ahival "none"
	}
	if {$aloval == ""} {
	    set aloval "none"
	}
	set fstr [format "%-8s  %-8s  %-6s %-6s %s" $atype $asort $ahival $aloval $aname]
	.newschema.attrlist.list insert active $fstr
	.newschema.attrlist.list delete active
	# Clear selection
	set aname ""
	set atype "double"
	set asort "unsorted"
	set ahival ""
	set aloval ""
    }
    pack .newschema.attrop.add .newschema.attrop.delete \
	    .newschema.attrop.modify -side left -padx 3m -pady 1m -expand 1
    
    #-----------------------------------------------------------
    # Bottom portion of window
    button .newschema.opt.save -text Save -bg gray75 -fg IndianRed4 -command {
	if {$sname == ""} {
	    showmesg "No schema name specified."
	} else {
	    set attrlist {}
	    while {$attrnum > 0} {
		set attr [.newschema.attrlist.list get [expr $attrnum-1]]
		set attrnum [expr $attrnum-1]
		
		# Append to attrlist
		set attrlist [linsert $attrlist 0 $attr]
	    }
	    
	    # Write into a file 
	    writephysical $sname $ftype $comm $separ $attrlist
	    # Update catalog with this new physical schema (if new).
	    if {[info exists Logical($sname)] == 0} {
		# Since this is the initial version of the physical schema
		# we will create a default logical schema. This is simply
		# a file in the logical schema dir which has the same name
		# and points to this as its physical schema. No groups are
		# defined yet.
		writeDefaultLogical $sname
		set Logical($sname) [list $sname]
		writecatalog
	    }
	    destroy .newschema
	}
    }
    button .newschema.opt.quit -text Cancel -bg gray75 -fg IndianRed4 \
	    -command { destroy .newschema }
    pack .newschema.opt.save .newschema.opt.quit  -side left \
	    -padx 3m -pady 1m -expand 1
    
    tkwait window .newschema
}

#-----------------------------------------------------------
proc newschema {} {
    global sname ftype comm separ attrlist aname atype asort tgrps ahival aloval
    # First set up some global variables
    set sname ""
    set ftype ascii
    set comm "//"
    set separ " "
    set attrlist ""
    set aname ""
    set atype "double"
    set asort "unsorted"
    set tgrps ""
    set ahival ""
    set aloval ""

    # Call function to display the window
    newschemawin
}

#-----------------------------------------------------------
proc openschema {filename} {
    global sname ftype comm separ attrlist aname atype asort fsBox schemadir \
	    tgrps ahival aloval

    # Set some defaults
    set sname ""
    set ftype ascii
    set comm "//"
    set separ " "
    set attrlist ""
    set aname ""
    set atype double
    set asort unsorted
    set tgrps ""
    set ahival ""
    set aloval ""

    # Read the file and get the contents
    readphysical $filename

    # Call function to display the schema
    newschemawin
}


#-----------------------------------------------------------
# General function to display a message
proc showmesg {str} {
    toplevel .msg -bg red4
    wm title .msg Message
    wm geometry .msg +100+100
    
    frame .msg.str -relief raised -bd 1 -bg red4
    frame .msg.ok -relief raised -bg red4
    pack .msg.str .msg.ok -side top -fill x -padx 3m -pady 3m

    message .msg.str.msg -width 3i -text $str -bg red4 -fg white
    pack .msg.str.msg -side right -expand 1 -fill both -padx 3m -pady 3m

    button .msg.ok.but -text OK -bg white -fg red4 \
	    -command {destroy .msg}
    pack .msg.ok.but -side top -expand 1 -padx 3m -pady 1m

    tkwait visibility .msg
    grab set .msg
    tkwait window .msg
}

################################################################
proc writelogical {name} {
    global tgrps schemadir physchema

    set f [open $schemadir/logical/$name w]
    
    puts $f "physical $schemadir/physical/$physchema"

    foreach nm $tgrps {
	puts $f ""
	goutput $f $nm
    }

    close $f
}

proc writeDefaultLogical {sname} {
    global schemadir

    set f [open $schemadir/logical/$sname w]
    
    # Only one line in this default logical file
    puts $f "physical $schemadir/physical/$sname"
    close $f
}

proc writephysical {name type comm sep alist} {
    global schemadir

    set f [open $schemadir/physical/$name w]

    puts $f "type $name $type" 
    puts $f "comment $comm"
    puts $f "separator '$sep'"
    
    foreach attr $alist {
	set atype [lindex $attr 0]
	set asort [lindex $attr 1]
	set ahival [lindex $attr 2]
	set aloval [lindex $attr 3]
	set aname [lindex $attr 4]
	
	if {$asort != "unsorted"} {
	    puts -nonewline $f "sorted "
	}
	puts -nonewline $f "attr $aname $atype"
	if {$ahival != "none"} {
	    puts -nonewline $f " hi $ahival"
	}
	if {$aloval != "none"} {
	    puts -nonewline $f " lo $aloval"
	}
	puts $f ""
    }
    close $f
}

##################################################################
proc readlogical {filename} {
    global tgrps schemadir
    set tgrps ""

    # Open file for reading
    set f [open $schemadir/logical/$filename r]

    # First line specifies the physical schema
    set line [gets $f]

    # Group declarations
    set len [gets $f line]
    while {$len >= 0} {
	set nm [lindex $line 1]
	if {[lindex $line 0] == ""} {
	    # skip blank lines
	} else {
	    set tgrps [lappend tgrps $nm]
	    ginput $f $nm
	}
	set len [gets $f line]
    }
    # Close file
    close $f
}

proc readphysical {filename} {
    global sname ftype comm separ attrlist schemadir
    set attrlist ""

    # Open file for reading
    set f [open $schemadir/physical/$filename r]

    # First line is the schema name and type
    set line [gets $f]
    scan $line "type %s %s" sname ftype

    # Second line is comment
    set line [gets $f]
    scan $line "comment %s" comm

    # Third line is separator
    set line [gets $f]
    # everything between the 's is the separator
    set lstart [string first "'" $line]
    set lend [string last "'" $line]
    set lstart [expr $lstart+1]
    set lend [expr $lend-1]
    set separ [string range $line $lstart $lend]

    # Following are all attr declarations
    set len [gets $f line]
    set num 0
    while {$len != -1} {
	set first [lindex $line 0]
	if {$first != "sorted"} {
	    set scanstr "attr %s %s"
	    set sorted unsorted
	} else {
	    set scanstr "sorted attr %s %s"
	    set sorted sorted
	}
	set argstr "attrname attrtype"

	set hipos [lsearch $line "hi"]
	if {$hipos != -1} {
	    set histr " hi %s"
	    set scanstr $scanstr$histr
	    set histr " hival"
	    set argstr $argstr$histr
	}

	set lopos [lsearch $line "lo"]
	if {$lopos != -1} {
	    set lostr " lo %s"
	    set scanstr $scanstr$lostr
	    set lostr " loval"
	    set argstr $argstr$lostr
	}

	set hival "none"
	set loval "none"

	set cmd "scan \$line \"$scanstr\" $argstr"
	eval $cmd
	
	set attr [list $attrtype $sorted $hival $loval $attrname]
#	puts "Inserting .. $attr"
	set attrlist [linsert $attrlist $num $attr]
	set len [gets $f line]
	set num [expr $num+1]
    }

    close $f
    set sname $filename
}
###################################################################

proc gbrowse {} {
    global tgrps glist logschema physchema Logical attrlist iname

    toplevel .gbrowse -bg red4
    wm title .gbrowse "$physchema View : $logschema"
    wm geometry .gbrowse +50+50
    wm iconname .gbrowse "Groups"

    # Toplevel rows
    frame .gbrowse.attrs -relief raised -bg honeydew2
    frame .gbrowse.list -relief raised -bg honeydew2 
    frame .gbrowse.ops -relief raised -bg honeydew2 
    pack .gbrowse.attrs .gbrowse.list .gbrowse.ops \
	    -side top -fill x -padx 3m -pady 1m

    #----------------------------------------------------------
    # Create a listbox with all the attrs in the physical schema
    readphysical $physchema
    label .gbrowse.attrs.label -text "List of Attributes" -bg honeydew2 -fg red4
    pack .gbrowse.attrs.label -side top -fill x
    listbox .gbrowse.attrs.list -relief raised -bd 1 \
	    -yscrollcommand ".gbrowse.attrs.scroll set" \
	    -font 9x15 -selectmode single -bg honeydew2
    scrollbar .gbrowse.attrs.scroll -command ".gbrowse.attrs.list yview" \
	    -bg honeydew2
    pack .gbrowse.attrs.scroll -side right -fill y
    pack .gbrowse.attrs.list -fill x

    # Populate the list with all the attrs 
    foreach attr $attrlist {
	.gbrowse.attrs.list insert end [lindex $attr 4]
    }

    # Bind the mouse click on this list
    bind .gbrowse.attrs.list <Double-1> {
	set iname [.gbrowse.attrs.list get active]
    }

    #-----------------------------------------------------------
    # Create a listbox displaying list of groups
    #    CreateTextBitmap .gbrowse.list.label group.gif Groups
    label .gbrowse.list.label -text "List of Groups" -bg honeydew2 -fg red4
    pack .gbrowse.list.label -side top -fill x

    listbox .gbrowse.list.list -relief raised -bd 1 \
	    -yscrollcommand ".gbrowse.list.scroll set" \
	    -font 9x15 -selectmode single  -bg honeydew2
    scrollbar .gbrowse.list.scroll \
	    -command ".gbrowse.list.list yview" -bg honeydew2
    pack .gbrowse.list.scroll  -side right -fill y
    pack .gbrowse.list.list  -fill x 


    # Insert all existing top level groups into the listbox
    foreach nm $tgrps {
	.gbrowse.list.list insert end $nm
    }

    # Set up binding
    bind .gbrowse.list.list <Double-1> {
	set gname [.gbrowse.list.list get active]
    }


    # Panel for group name and panels for create, delete and modify
    frame .gbrowse.ops.name -relief raised -bg honeydew2 -bd 1
    frame .gbrowse.ops.op -relief raised -bg honeydew2 
    pack .gbrowse.ops.name .gbrowse.ops.op -side top -fill x \
	    -padx 3m -pady 1m

    label .gbrowse.ops.name.label -text "Group Name " -bg honeydew2 -fg red4
    entry .gbrowse.ops.name.entry -width 15 -relief sunken -bd 2 \
	    -textvariable gname -bg bisque
    pack .gbrowse.ops.name.label .gbrowse.ops.name.entry -side left \
	    -fill x -padx 1m -pady 1m -expand 1

    button .gbrowse.ops.op.create -text "Create" \
	    -bg gray75 -fg IndianRed4 	-command {
	if {$gname == ""} {
	    showmesg "Please specify the name of the group."
	} elseif {[info exists glist($gname)] == 1} {
	    showmesg "Group with this name already exists."
	    set gname ""
	} else {
	    set glist($gname) ""
	    dispgrp $gname
	}
    }
    button .gbrowse.ops.op.delete -text "Delete" \
	    -bg gray75 -fg IndianRed4	-command {
	if {$gname == ""} {
	    showmesg "Please specify the name of the group."
	} else {
	    # Search through tgrps and delete gname 
	    set idx [lsearch $tgrps $gname]
	    if {$idx == -1} {
		showmesg "Group with this name does not exist."
	    } else {
		set tgrps [lreplace $tgrps $idx $idx]
		delgrp $gname
		# Remove entry from the list box
		set i 0
		while {[.gbrowse.list.list get $i] != $gname} {
		    set i [expr $i+1]
		}
		.gbrowse.list.list delete $i
	    }
	    set gname ""
	}
    }
    button .gbrowse.ops.op.modify -text "Modify" \
	    -bg gray75 -fg IndianRed4	-command {
	if {$gname == ""} {
	    showmesg "Please specify the name of the group."
	} elseif {[lsearch $tgrps $gname] == -1} {
	    showmesg "Group with this name does not exist."
	} else {
	    dispgrp $gname
	}
    }
    button .gbrowse.ops.op.quit -text "Quit" \
	    -bg gray75 -fg IndianRed4	-command {
#	printgrps 
	writelogical $logschema
	# Update catalog if needed
	if {[lsearch $Logical($physchema) $logschema] == -1} {
	    set Logical($physchema) [lappend Logical($physchema) $logschema]
	    writecatalog
	}
	set logschema ""
	set physchema ""
	set tgrps ""
	destroy .gbrowse
    }
    pack .gbrowse.ops.op.create .gbrowse.ops.op.delete \
	    .gbrowse.ops.op.modify .gbrowse.ops.op.quit \
	    -side left -padx 3m -pady 1m -expand 1
}

proc dispgrp {gname } {
    global glist tgrps currgrp cnt iname
    # Displays the group information and allows modification

    set currgrp $gname 

    toplevel .grp -bg red4
    wm title .grp Group 
    wm geometry .grp +100+100

    frame .grp.list -relief raised -bg honeydew2
    frame .grp.ops -relief raised -bg honeydew2
    frame .grp.bot -relief raised -bg honeydew2
    pack .grp.list .grp.ops .grp.bot -side top -fill x -padx 3m -pady 1m

    # List showing current group structure
    label .grp.list.label -text "Display for Group : $gname" -bg honeydew2 -fg Red4
    pack .grp.list.label -side top -fill x

    listbox .grp.list.list -relief raised -bd 1 \
	    -yscrollcommand ".grp.list.scroll set" \
	    -font 9x15 -selectmode extended  -bg honeydew2
    scrollbar .grp.list.scroll \
	    -command ".grp.list.list yview" -bg honeydew2
    pack .grp.list.scroll  -side right -fill y
    pack .grp.list.list  -fill x 

    # Insert all the existing members of the group into the list
    glinsert $gname 0

    # Frame containing item and nested grp info
    frame .grp.curr -relief raised -bg honeydew2 
    pack .grp.curr -in .grp.ops -side top -fill x -padx 2m -pady 1m
    label .grp.curr.label -text "Current group " -bg honeydew2 -fg Red4
    entry .grp.curr.entry -width 25 -relief sunken -bd 2 \
	    -textvariable currgrp -bg bisque
    pack .grp.curr.label .grp.curr.entry -side left -padx 2m -expand 1

    frame .grp.item -relief raised -bg honeydew2 -bd 1
    frame .grp.ngrp -relief raised -bg honeydew2 -bd 1 
    pack .grp.item .grp.ngrp -in .grp.ops -side left -padx 2m -pady 1m \
	    -expand 1

    frame .grp.item.top -relief raised -bg honeydew2
    frame .grp.item.mid -relief raised -bg honeydew2
    frame .grp.item.bot -relief raised -bg honeydew2
    pack .grp.item.top .grp.item.mid .grp.item.bot -side top -fill x \
	    -padx 1m -pady 1m

    label .grp.item.top.label -text "Item" -bg honeydew2 -fg Red4
    pack .grp.item.top.label 
    
    label .grp.item.mid.label -text "Name " -bg honeydew2 -fg Red4
    entry .grp.item.mid.entry -width 25 -relief sunken -bd 2 \
	    -textvariable iname -bg bisque
    pack .grp.item.mid.label .grp.item.mid.entry -side left -fill x \
	    -padx 3m -pady 1m

    button .grp.item.bot.add -text "Insert" \
	    -bg gray75 -fg IndianRed4 -command {
	set iname [lindex [string trim $iname] 0]
	if {$iname == ""} {
	    showmesg "Please specify the name of the item."
	    return
	}
	if {$currgrp == ""} {
	    showmesg "Specify the current group into which the item would \
		    be inserted."
	    return
	}
	if {[info exists glist($currgrp)] == 0} {
	    showmesg "Current group $currgrp is invalid."
	    return
	}
	set elem [list $iname i]
	set glist($currgrp) [lappend glist($currgrp) $elem]
	# Now insert in the listbox
	set cnt -1
	endpos $gname $currgrp 
	# Actual position got by decrementing
	set cnt [expr $cnt-1]
	# Have to calculate prefix blanks before inserting into listbox
	set level [getLevel $gname $currgrp]
	set level [expr $level*2]
	set s s
	set prefix [format "%$level$s" " "]
	.grp.list.list insert $cnt $prefix$iname
	set iname ""
    }

    button .grp.item.bot.del -text "Delete" \
	    -bg gray75 -fg IndianRed4 -command {
	set iname [lindex [string trim $iname] 0]
	if {$iname == ""} {
	    showmesg "Please specify the name of the item."
	    return
	}
	set gr $gname
	set nm [gsearch $gname $iname]
	if {$nm == ""} {
	    showmesg "Item <$iname> does not exist."
	    return
	}
	set elem [list $iname i]
	set idx [lsearch $glist($nm) $elem]
	set glist($nm) [lreplace $glist($nm) $idx $idx]
	#  Also remove from the listbox
	set idx 0
	set elem [.grp.list.list get $idx]
	set elem [string trim $elem]
	while {$elem != $iname} {
	    set idx [expr $idx+1]
	    set elem [.grp.list.list get $idx]
	    set elem [string trim $elem]
	}
	.grp.list.list delete $idx
	set iname ""
    }
    pack .grp.item.bot.add  \
	    .grp.item.bot.del -side left -expand 1 -padx 3m -pady 1m

    frame .grp.ngrp.top -relief raised -bg honeydew2
    frame .grp.ngrp.mid -relief raised -bg honeydew2
    frame .grp.ngrp.bot -relief raised -bg honeydew2
    pack .grp.ngrp.top .grp.ngrp.mid .grp.ngrp.bot -side top -fill x \
	    -padx 1m -pady 1m

    label .grp.ngrp.top.label -text "Sub Group" -bg honeydew2 -fg Red4
    pack .grp.ngrp.top.label 
    
    label .grp.ngrp.mid.label -text "Name " -bg honeydew2 -fg Red4
    entry .grp.ngrp.mid.entry -width 25 -relief sunken -bd 2 \
	    -textvariable ngname -bg bisque
    pack .grp.ngrp.mid.label .grp.ngrp.mid.entry -side left -fill x \
	    -padx 3m -pady 1m

    button .grp.ngrp.bot.add -text "Create" \
	    -bg gray75 -fg IndianRed4 -command {
	set ngname [lindex [string trim $ngname] 0]
	if {$ngname == ""} {
	    showmesg "Please specify the name of the sub group."
	    return
	}
	if {[info exists glist($currgrp)] == 0} {
	    showmesg "Current group $currgrp is not valid."
	    return
	}
	set elem [list $ngname g]
	set glist($currgrp) [lappend glist($currgrp) $elem]
	set glist($ngname) ""
	set level [getLevel $gname $currgrp]
	set level [expr $level*2]
	set s s
	set prefix [format "%$level$s" " "]
	
	set cnt -1
	endpos $gname $currgrp
	# Actual position by subtracting 2
	set cnt [expr $cnt-2]
	
	set line "end group $ngname"
	.grp.list.list insert $cnt $prefix$line
	set line "begin group $ngname"
	.grp.list.list insert $cnt $prefix$line
	set nlist [lappend nlist $currgrp]
	set currgrp $ngname
	set ngname ""
    }
    button .grp.ngrp.bot.del -text "Delete" \
	    -bg gray75 -fg IndianRed4 -command {
	set ngname [lindex [string trim $ngname] 0]
	if {$ngname == ""} {
	    showmesg "Please specify the name of the sub group."
	    return
	}
	set outer [gsearch $gname $ngname]
	if {$outer == ""} {
	    showmesg "Subgroup $ngname is invalid."
	    return
	}
	set elem [list $ngname g]
	set idx [lsearch $glist($outer) $elem]
	set glist($outer) [lreplace $glist($outer) $idx $idx]
	delgrp $ngname
	# Now remove from the listbox
	set idx 0
	set elem [.grp.list.list get $idx]
	set elem [string trim $elem]
	set start "begin group $ngname"
	while {$elem != $start} {
	    set idx [expr $idx+1]
	    set elem [.grp.list.list get $idx]
	    set elem [string trim $elem]
	}
	set dest "end group $ngname"
	while {$elem != $dest} {
	    .grp.list.list delete $idx
	    set elem [.grp.list.list get $idx]
	    set elem [string trim $elem]
	}
	.grp.list.list delete $idx
	set ngname ""
    }
    pack .grp.ngrp.bot.add .grp.ngrp.bot.del \
	    -side left -expand 1 -padx 3m -pady 1m

    # Bind the mouse click on the listbox
    bind .grp.list.list <Double-1> {
	set selec [.grp.list.list get active]
	set selec [string trim $selec]
	set first [lindex $selec 0]
	if {$first == "begin"} {
	    set currgrp [lindex $selec 2]
	} elseif {$first == "end"} {
	    set currgrp [lindex $selec 2]
	} else {
	    set iname $first
	}
    }
	
    # Frame containing save and cancel buttons
    button .grp.bot.save -text "Save" \
	    -bg gray75 -fg IndianRed4 -command {
	destroy .grp
	# Insert gname into main group list if not already present
	set len [.gbrowse.list.list index end]
	set i 0
	while {($i < $len) && ([.gbrowse.list.list get $i] != $gname)} {
	    incr i
	}
	if {$i >= $len} {
	    set tgrps [lappend tgrps $gname]
	    .gbrowse.list.list insert end $gname
	}

	# reset nlist
	set nlist ""
	set ngname ""
	set iname ""
    }
    button .grp.bot.cancel -text "Cancel" \
	    -bg gray75 -fg IndianRed4 -command {
	destroy .grp
	set ngname ""
	set iname ""
    }
    pack .grp.bot.save .grp.bot.cancel -side left -expand 1 \
	    -padx 3m -pady 1m    
}

proc printgrps {} {
    global tgrps
    # Loop through all the top level groups 
    foreach top $tgrps {
	puts "Top level group-----------$top"
	printgrp $top
    }
}

proc printgrp {name} {
    global glist

    puts "Group $name"
    foreach elem $glist($name) {
	set nm [lindex $elem 0]
	set ty [lindex $elem 1]
	if {$ty == "i"} {
	    puts "Item $nm"
	} else {
	    printgrp $nm
	}
    }

    puts "End of group $name"
}

proc glinsert {name level} {
    global glist 

    # At this level the prefix consists of "level" spaces
    set s s
    set prefix [format "%$level$s" " "]

    # inserts members of the group into a listbox
    foreach elem $glist($name) {
	set nm [lindex $elem 0]
	set ty [lindex $elem 1]
	if {$ty == "i"} {
	    .grp.list.list insert end $prefix$nm
	} else {
	    set line "begin group $nm"
	    .grp.list.list insert end $prefix$line
	    glinsert $nm [expr $level+2]
	    set line "end group $nm"
	    .grp.list.list insert end $prefix$line
	}
    }
}

proc goutput {f name} {
    global glist

    # output the group structure for nm to file f

    puts $f "group $name"
    foreach elem $glist($name) {
	set nm [lindex $elem 0]
	set ty [lindex $elem 1]
	if {$ty == "i"} {
	    puts $f "item $nm"
	} else {
	    goutput $f $nm
	}
    }

    puts $f "endgroup"
}

proc ginput {f name} {
    global glist

    set glist($name) ""

    while {1} {
	set len [gets $f line]
	if {$len < 0} {
	    break
	}

	set line [string trim $line]
	if {$line == "" || $line == "endgroup"} {
	    break
	}

	set ty [lindex $line 0]
	set nm [lindex $line 1]
	if {$ty == "item"} {
	    set elem [list $nm i]
	    set glist($name) [lappend glist($name) $elem]
	} elseif {$ty == "group"} {
	    set elem [list $nm g]
	    set glist($name) [lappend glist($name) $elem]
	    ginput $f $nm
	} else {
	    puts "Unrecognized keyword $ty ignored."
	}
    }
}

proc delgrp {name} {
    global glist

    # delete all the members of the group
    
    foreach elem $glist($name) {
	set nm [lindex $elem 0]
	set ty [lindex $elem 1]
	if {$ty == "g"} {
	    delgrp $nm
	}
    }
    unset glist($name)
}


proc gsearch {gnm inm} {
    global glist

    # Searches for the item "inm" in the group "gnm". It recursively
    # traverses the nested sub groups and returns the name of the 
    # immediate outer group in which the item is found.
    # Returns null string if the item is not found

    foreach elem $glist($gnm) {
	set nm [lindex $elem 0]
	if {$nm == $inm} {
	    return $gnm
	}
	set ty [lindex $elem 1]
	if {$ty == "g"} {
	    set ret [gsearch $nm $inm]
	    if {$ret != ""} {
		return $ret
	    }
	}
    }

    return ""
}

proc endpos {gnm ngnm} {
    global glist cnt

    # This function returns the "flattened" position of the item "inm"
    # within the group "gnm". This would be the line number of this
    # item within the listbox displaying the group
    # Returns 0 if the item was not found, 1 if found

    foreach elem $glist($gnm) {
	set cnt [expr $cnt+1]
	set nm [lindex $elem 0]
	set ty [lindex $elem 1]
	if {$ty == "g"} {
	    set ret [endpos $nm $ngnm]
	    if {$ret == 1} {
		return 1
	    }
	}

	if {$nm == $ngnm} {
	    return 1
	}

    }
    set cnt [expr $cnt+1]
    return 0
}

proc begpos {gnm ngnm} {
    global glist cnt

    # This function returns the "flattened" position of the item "inm"
    # within the group "gnm". This would be the line number of this
    # item within the listbox displaying the group
    # Returns 0 if the item was not found, 1 if found

    foreach elem $glist($gnm) {
	set cnt [expr $cnt+1]
	set nm [lindex $elem 0]
	set ty [lindex $elem 1]
	if {$nm == $ngnm} {
	    return 1
	}
	if {$ty == "g"} {
	    set ret [endpos $nm $ngnm]
	    if {$ret == 1} {
		return 1
	    }
	}

    }
    set cnt [expr $cnt+1]
    return 0
}

#########################################################################
proc writecatalog {} {
    global Logical schemadir

    set f [open $schemadir/catalog.tcl w]
    puts $f "# Association between physical and logical schemas"
    puts $f ""

    foreach itm [lsort [array names Logical]] {
	puts $f "set \"Logical($itm)\" \{$Logical($itm)\}"
    }
    close $f
}

##########################################################################

proc displogical {pname} {
    global schemadir tgrps logschema Logical physchema button

    set physchema $pname
    
    # Display the logical schema corr. to the passed physical schema
    toplevel .lsch -bg red4
    wm title .lsch "Current Views"
    wm geometry .lsch +50+50

    frame .lsch.top -relief raised -bg honeydew2
    frame .lsch.mid -relief raised -bg honeydew2
    frame .lsch.bot -relief raised -bg honeydew2
    frame .lsch.ent -relief raised -bg honeydew2
    pack .lsch.top .lsch.mid .lsch.ent .lsch.bot \
	    -side top -fill x -padx 1m -pady 1m

    # Entry for schema name
    label .lsch.ent.label -text "Schema name : " -bg honeydew2 -fg red4
    entry .lsch.ent.entry -width 25 -relief sunken -bd 2 \
	    -textvariable logschema -bg bisque
    pack .lsch.ent.label .lsch.ent.entry -side left -padx 1m 

    # Label on top
    label .lsch.top.label -text "$pname   Schemas" -bg honeydew2 -fg red4
    pack .lsch.top.label

    # Listbox with scrollbar in the middle
    listbox .lsch.mid.list -relief raised -bd 1 \
	    -yscrollcommand ".lsch.mid.scroll set" \
	    -font 9x15 -selectmode single -bg honeydew2
    scrollbar .lsch.mid.scroll -command ".lsch.mid.list yview" -bg honeydew2
    pack .lsch.mid.scroll -side right -fill y
    pack .lsch.mid.list -fill x

    # bind mouse click on the listbox
    bind .lsch.mid.list <Double-1> {
	set logschema [.lsch.mid.list get active]
    }

    # Populate the listbox based on the Logical array values
    if {[info exists Logical($pname)] == 0} {
	set Logical($pname) ""
    }
    foreach itm $Logical($pname) {
	.lsch.mid.list insert end $itm
    }

    # Button to create a New one, Open or Quit
    button .lsch.bot.new -text New -bg gray75 -fg IndianRed4 -command {
	if {$logschema == ""} {
	    showmesg "Please type in the name of the schema to be created."
	} else {
	    set tgrps ""
	    destroy .lsch
	    gbrowse
	}
    }
    button .lsch.bot.open -text Open -bg gray75 -fg IndianRed4 -command {
	if {$logschema == ""} {
	    showmesg "Please choose a schema by clicking on the entry."
	} else {
	    destroy .lsch
	    readlogical $logschema
	    gbrowse
	}
    }

    button .lsch.bot.del -text Remove -bg gray75 -fg IndianRed4 -command {
	if {$logschema == ""} {
	    showmesg "Please select the view to remove by clicking on \
		    the entry."
	} else {
	    dialog .rem "Remove View" \
		    "This will remove the view permanently. Proceed ? " \
		    "" 0 Yes No
	    if {$button == 0} {
		set idx [lsearch $Logical($physchema) $logschema]
		if {$idx == -1} {
		    dialog .note "Unknown View" \
			    " The view does not exist. Cannot remove it." \
			    "" 0 OK
		    return
		}
		set Logical($physchema) [lreplace $Logical($physchema) $idx $idx]
		writecatalog
		# Remove the entry from the listbox 
		set len [.lsch.mid.list index end]
		set i 0
		while {[.lsch.mid.list get $i] != $logschema} {
		    incr i
		}
		.lsch.mid.list delete $i
		exec rm $schemadir/logical/$logschema
		set logschema ""
	    }
	}
    }
    button .lsch.bot.quit -text Quit -bg gray75 -fg IndianRed4 -command {
	destroy .lsch
    }
    pack .lsch.bot.new .lsch.bot.open .lsch.bot.del .lsch.bot.quit \
	    -side left -padx 3m -pady 1m -expand 1

    # Finally grab focus
    tkwait visibility .lsch
    grab set .lsch
    tkwait window .lsch
}

proc displayattrs {pname} {
    global attrlist

    # destroy .slist window if it already exists
    catch {destroy .slist}

    # Create a window with a listbox showing the names of all the attrs
    # in the physical schema pname
    
    toplevel .slist -bg red4
    wm title .slist "Attributes in $pname"
    wm geometry .slist +100+100
    wm iconname .slist "$pname"

    frame .slist.top -relief raised -bg honeydew2
    frame .slist.bot -relief raised -bg honeydew2
    pack .slist.top .slist.bot -fill x -padx 1m -pady 1m

    # label + listbox +scroll
    label .slist.top.label -text "List of attributes" -bg honeydew2 -fg red4
    pack .slist.top.label -side top -fill x 
    listbox .slist.top.list -relief raised -bd 1 \
	    -yscrollcommand ".slist.top.scroll set" \
	    -font 9x15 -selectmode single -bg honeydew2
    scrollbar .slist.top.scroll -command ".slist.top.list yview" \
	    -bg honeydew2
    pack .slist.top.scroll -side right -fill y
    pack .slist.top.list -fill x

    # Populate the list
    readphysical $pname
    foreach attr $attrlist {
	.slist.top.list insert end [lindex $attr 4]
    }

    # OK button
    button .slist.bot.ok -text OK -bg gray75 -fg IndianRed4 -command {
	destroy .slist
    }
    pack .slist.bot.ok

    tkwait window .slist
}


proc getLevel {gnm ngnm} {
    global glist

    foreach elem $glist($gnm) {
	set nm [lindex $elem 0]
	set ty [lindex $elem 1]
	if {$nm == $ngnm} {
	    return 1
	}

	if {$ty == "g"} {
	    set ret [getLevel $nm $ngnm]
	    if {$ret >= 1} {
		return [expr $ret+1]
	    }
	}
    }
    return 0
}
