#  ========================================================================
#  DEVise Data Visualization Software
#  (c) Copyright 1992-1996
#  By the DEVise Development Group
#  Madison, Wisconsin
#  All Rights Reserved.
#  ========================================================================
#
#  Under no circumstances is this software to be copied, distributed,
#  or altered in any way without prior permission from the DEVise
#  Development Group.

############################################################

#  $Id$

#  $Log$
#  Revision 1.26  1997/02/03 04:12:40  donjerko
#  Catalog management moved to DTE
#
#  Revision 1.25.4.1  1997/02/09 20:14:20  wenger
#  Fixed bug 147 (or at least some instances of it) -- found a bug in the
#  query processor that caused it to miss records it should have found;
#  fixed bugs 151 and 153.
#
#  Revision 1.25  1997/01/17 20:32:31  wenger
#  Fixed bugs 088, 121, 122; put workaround in place for bug 123; added
#  simulation of XOR drawing in PSWindowRep; removed diagnostic output
#  from Tcl/Tk code; removed (at least for now) the ETk interface from
#  the cslib versions of WindowRep classes so that the cslib will link
#  okay; cslib server now tests XOR drawing.
#
#  Revision 1.24  1996/12/15 07:01:38  donjerko
#  Added the window to create an index on streams.
#
#  Revision 1.23  1996/11/18 18:13:32  donjerko
#  Added final touches for DTE
#
#  Revision 1.22  1996/11/03 02:41:52  kmurli
#  Modified to include the query schema level. Also modified to include DQL
#  processing
#
#  Revision 1.21  1996/10/28 23:20:03  flisakow
#   Allows the entry of a tab in the Whitespace field, though the focus
#   still changes to the next window.
#
#  Revision 1.20  1996/10/23 22:51:08  flisakow
#  Added an array, "hiddendata" to store attributes that we don't wish to
#  show in the listbox.  Used it to store the strlen for strings, and
#  added an entry field to display/change it.
#
#  Revision 1.19  1996/07/11 17:26:14  wenger
#  Devise now writes headers to some of the files it writes;
#  DataSourceSegment class allows non-fixed data length with non-zero
#  offset; GUI for editing schema files can deal with comment lines;
#  added targets to top-level makefiles to allow more flexibility.
#
#  Revision 1.18  1996/04/30 15:52:17  jussi
#  Removed all custom color settings (-bg and -fg). The schema
#  browser and editor now uses the global/default colors.
#
#  Revision 1.17  1996/03/24 19:09:41  jussi
#  Added support for separator/whitespace and composite attributes.
#
#  Revision 1.16  1996/01/23 20:52:07  jussi
#  Minor improvement.
#
#  Revision 1.15  1996/01/19 18:33:57  jussi
#  Several minor fixes.
#
#  Revision 1.14  1996/01/17 18:05:01  jussi
#  Default UserMode value is now set in control.tk.
#
#  Revision 1.13  1996/01/08 18:54:45  jussi
#  Cleaned up a bit the code and rearranged focus grabs. Removed some
#  bugs related to operating on new and old schemas with no hi or
#  lo values specified for some attributes.
#
#  Revision 1.12  1995/12/20 07:03:00  ravim
#  High and low values of attrs can be specified.
#
#  Revision 1.11  1995/12/15 03:38:20  ravim
#  User mode used for displaying schemas.
#
#  Revision 1.10  1995/12/12 01:46:29  ravim
#  Physical/Logical schema support.
#
#  Revision 1.9  1995/12/11 18:02:31  ravim
#  Enhanced schema creation. Now also displays list of attributes.
#
#  Revision 1.8  1995/11/30 02:21:06  ravim
#  Changed some colors and removed debugging puts.
#
#  Revision 1.7  1995/11/20 22:18:35  jussi
#  Changed from datadir to schemadir.
#
#  Revision 1.6  1995/11/19 06:03:24  ravim
#  Initial version of user/superuser modes and handling of logical/physical
#  schemas.
#
#  Revision 1.5  1995/11/01 01:37:55  ravim
#  Several minor changes.
#
#  Revision 1.4  1995/10/25 19:21:46  ravim
#  Added new types.
#
#  Revision 1.3  1995/10/17 05:16:32  ravim
#  Can define arbitrary group structures.
#
#  Revision 1.2  1995/10/11 17:08:10  ravim
#  Minor changes.
#
#  Revision 1.4  1995/10/11 17:02:38  ravim
#  Decoupled the main program. Uses datadir to display schema files.
#
#  Revision 1.3  1995/10/11 01:48:28  ravim
#  Added colors. Can modify attributes in place.
#
#  Revision 1.2  1995/10/04 20:48:33  ravim
#  Handled case when no schema file is selected.
#
# Revision 1.1  1995/10/03  03:40:53  ravim
# Initial revision
#

############################################################

set catalogFile $schemadir/catalog.tcl
if {![file exists $catalogFile]} {
    puts "Cannot read catalog file for physical to logical associations"
    exit 1
}
source $catalogFile

set queryCatalogFile $schemadir/Querycatalog.tcl
if {![file exists $queryCatalogFile]} {
    puts "Cannot read Query catalog file for logical to query associations"
    exit 1
}
source $queryCatalogFile

#-----------------------------------------------------------
#		PROCEDURES
#-----------------------------------------------------------

# Procedure called from the control panel - figures out which procedure
# to execute based on the user mode specified in the .rc file
proc SchemaBrowse {} {
    global UserMode
    SchemaEdit $UserMode
}

proc SchemaEdit {mode} {
    if {$mode == 0} {
		SchemaSuperuser
    } elseif {$mode == 1} {
		SchemaUser
    } else {
		SchemaQuery
	}
}

# Schema browser for  a normal user - can manipulate only the logical schema
proc SchemaUser {} {
    global schemadir physchema
    # Show a list of currently defined physical schemas and buttons to either
    # create a Open one of these

    toplevel .psch
    wm title .psch "Current Schemas"
    wm geometry .psch +50+50

    frame .psch.top -relief raised
    frame .psch.mid -relief raised
    frame .psch.bot -relief raised
    pack .psch.top .psch.mid .psch.bot -side top -fill x -padx 1m -pady 1m

    # Label on top
    label .psch.top.label -text "Schemas"
    pack .psch.top.label

    # Listbox with scrollbar in the middle
    listbox .psch.mid.list -relief raised -bd 1 \
	    -yscrollcommand ".psch.mid.scroll set" \
	    -font 9x15 -selectmode single
    scrollbar .psch.mid.scroll -command ".psch.mid.list yview"
    pack .psch.mid.scroll -side right -fill y
    pack .psch.mid.list -fill x

    # Search for files in the schema/physical directory to populate the list
    set flist [glob $schemadir/physical/*]
    foreach fname $flist {
	.psch.mid.list insert end [file tail $fname]
    }    

    # Button to Open or Quit
    button .psch.bot.attr -text "Attributes" \
	    -command {
	set physchema [.psch.mid.list get active]
	if {$physchema == ""} {
	    showmesg "Please choose a schema by clicking on the entry."
	} else {
	    displayattrs $physchema
	}
    }
    button .psch.bot.view -text "Views" -command {
	set physchema [.psch.mid.list get active]
	if {$physchema == ""} {
	    showmesg "Please choose a schema by clicking on the entry."
	} else {
	    destroy .psch
	    displogical $physchema
	}
    }
    button .psch.bot.quit -text Quit -command {
	destroy .psch
    }
    pack .psch.bot.attr .psch.bot.view .psch.bot.quit \
	    -side left -padx 3m -pady 1m -expand 1

    tkwait window .psch
}

proc SchemaQuery {} {
    global schemadir physchema
    # Show a list of currently defined physical schemas and buttons to either
    # create a Open one of these

    toplevel .psch
    wm title .psch "Current Schemas"
    wm geometry .psch +50+50

    frame .psch.top -relief raised
    frame .psch.mid -relief raised
    frame .psch.bot -relief raised
    pack .psch.top .psch.mid .psch.bot -side top -fill x -padx 1m -pady 1m

    # Label on top
    label .psch.top.label -text "Schemas"
    pack .psch.top.label

    # Listbox with scrollbar in the middle
    listbox .psch.mid.list -relief raised -bd 1 \
	    -yscrollcommand ".psch.mid.scroll set" \
	    -font 9x15 -selectmode single
    scrollbar .psch.mid.scroll -command ".psch.mid.list yview"
    pack .psch.mid.scroll -side right -fill y
    pack .psch.mid.list -fill x

    # Search for files in the schema/physical directory to populate the list
    set flist [glob $schemadir/physical/*]
    foreach fname $flist {
	.psch.mid.list insert end [file tail $fname]
    }    

    # Button to Open or Quit
    button .psch.bot.attr -text "Attributes" \
	    -command {
	set physchema [.psch.mid.list get active]
	if {$physchema == ""} {
	    showmesg "Please choose a schema by clicking on the entry."
	} else {
	    displayattrs $physchema
	}
    }
    button .psch.bot.view -text "Views" -command {
	set physchema [.psch.mid.list get active]
	if {$physchema == ""} {
	    showmesg "Please choose a schema by clicking on the entry."
	} else {
	    destroy .psch
	    dispQuerylogical $physchema
	}
    }
    button .psch.bot.quit -text Quit -command {
	destroy .psch
    }
    pack .psch.bot.attr .psch.bot.view .psch.bot.quit \
	    -side left -padx 3m -pady 1m -expand 1

    tkwait window .psch
}
########################################################
# Schema browser for the superuser - can change both physical and logical parts
proc SchemaSuperuser {} {
    global schemadir
    # Show a list of currently defined schemas and buttons to either
    # create a New one or Open an existing one

    toplevel .psch
    wm title .psch "Physical Schemas"
    wm geometry .psch +50+50

    frame .psch.top -relief raised
    frame .psch.mid -relief raised
    frame .psch.bot -relief raised
    pack .psch.top .psch.mid .psch.bot -side top -fill x -padx 1m -pady 1m

    # Label on top
    label .psch.top.label -text "Schemas"
    pack .psch.top.label

    # Listbox with scrollbar in the middle
    listbox .psch.mid.list -relief raised -bd 1 \
	    -yscrollcommand ".psch.mid.scroll set" \
	    -font 9x15 -selectmode single
    scrollbar .psch.mid.scroll -command ".psch.mid.list yview"
    pack .psch.mid.scroll -side right -fill y
    pack .psch.mid.list -fill x

    # Search for files in the schema/physical directory to populate the list
    set flist [glob $schemadir/physical/*]
    foreach fname $flist {
	.psch.mid.list insert end [file tail $fname]
    }

    # Buttons at bottom
    button .psch.bot.new -text New -command {
	destroy .psch
	newschema
    }
    button .psch.bot.open -text Open -command {
	set sel [.psch.mid.list get active]
	if {$sel == ""} {
	    showmesg "Select the schema to edit by clicking once on the entry."
	} else {
	    destroy .psch
	    openschema $sel
	}
    }
    button .psch.bot.del -text Remove -command {
	set sel [.psch.mid.list get active]
	if {$sel == ""} {
	    showmesg "Select the schema to remove by clicking once on the entry."
	} else {
	    dialog .rem "Remove Schema" \
		    "This will remove the schema and all defined views." \
		    "" 0 Yes No
	    if {$button == 0} {
		exec rm $schemadir/physical/$sel
		foreach log $Logical($sel) {
		    exec rm $schemadir/logical/$log
		}
		unset Logical($sel)
		writecatalog
		.psch.mid.list delete active
	    }
	}
    }

    button .psch.bot.quit -text Quit -command {
	destroy .psch
    }
    pack .psch.bot.new .psch.bot.open .psch.bot.del .psch.bot.quit -side left \
	    -padx 3m -pady 1m -expand 1

    tkwait window .psch
}

#############################################################
# Called whenever the type field is changed.
proc ChgType {name element op} {
    upvar $name x

    if {$x == "string"} {
        .newschema.astrlen.label configure -fg white
        .newschema.astrlen.entry configure -state normal
    } else {
        .newschema.astrlen.label configure -fg gray
        .newschema.astrlen.entry configure -state disabled
    }
}

#############################################################
# This procedure creates a window depicting all the fields for the schema
# and their values if any.
proc newschemawin {} {
    global sname ftype comm issepar issepartext separ attrlist aname acomp
    global atype astrlen asort attrnum tgrps glist Logical

    # Count number of attributes
    set attrnum 0

    toplevel .newschema
    wm title .newschema "Schema Description"
    wm geometry .newschema +50+50
    
    # Top level rows in the window
    frame .newschema.firstrow -relief raised
    frame .newschema.commseprow -relief raised
    frame .newschema.opt -relief raised
    frame .newschema.attr -relief raised
    pack .newschema.firstrow  .newschema.commseprow .newschema.attr \
	    .newschema.opt 	-side top -fill x -padx 1m -pady 1m
    
    #-----------------------------------------------------------
    # Within first row - name and type
    frame .newschema.fname -relief raised -bd 1
    frame .newschema.ftype -relief raised -bd 1
    pack .newschema.fname .newschema.ftype -in .newschema.firstrow \
	    -side left -fill x -padx 3m -pady 1m
    
    label .newschema.fname.label -text "Schema Name "
    entry .newschema.fname.entry -width 25 -relief sunken -bd 2 \
	    -textvariable sname
    pack .newschema.fname.label .newschema.fname.entry -side left -padx 1m \
	    -pady 1m
    
    label .newschema.ftype.label -text "File Type"
    radiobutton .newschema.ftype.ascii -text Ascii -variable ftype \
	    -value ascii -anchor nw
    radiobutton .newschema.ftype.binary -text Binary -variable ftype \
	    -value binary -anchor nw
    pack .newschema.ftype.label .newschema.ftype.ascii .newschema.ftype.binary \
	    -side top -fill x
    
    #-----------------------------------------------------------
    # Comment and separator characters
    frame .newschema.comm -relief raised
    frame .newschema.separ -relief raised
    pack .newschema.comm -side left  -in .newschema.commseprow \
	    -padx 3m -pady 1m 
    pack .newschema.separ -side right  -in .newschema.commseprow \
	    -padx 3m -pady 1m
    
    label .newschema.comm.label -text "Comment characters"
    entry .newschema.comm.entry -width 5 -relief sunken -bd 2 \
	    -textvariable comm
    pack .newschema.comm.label .newschema.comm.entry -side left \
	    -padx 1m -pady 1m
    
    menubutton .newschema.separ.button -relief raised \
	    -textvariable issepartext -menu .newschema.separ.button.menu \
	    -width 12
    menu .newschema.separ.button.menu -tearoff 0
    .newschema.separ.button.menu add radiobutton -label "Separator" \
	    -variable issepar -value 1 -command {
	set issepartext "Separator"
    }
    .newschema.separ.button.menu add radiobutton -label "Whitespace" \
	    -variable issepar -value 0 -command {
	set issepartext "Whitespace"
    }
    set issepartext "Separator"
    if {!$issepar} {
	set issepartext "Whitespace"
    }
    entry .newschema.separ.entry -width 15 -relief sunken -bd 2 \
	    -textvariable separ
    bind .newschema.separ.entry <Tab> { set separ "$separ\	'" }

    pack .newschema.separ.button .newschema.separ.entry -side left \
	    -padx 1m -pady 1m 
    
    #-----------------------------------------------------------
    # Attributes
    frame .newschema.attrlist -relief raised
    frame .newschema.attradd -relief raised
    pack .newschema.attrlist -in .newschema.attr \
	    -side top -padx 3m -pady 1m -fill x
    pack .newschema.attradd -in .newschema.attr \
	    -side bottom -padx 3m -pady 1m -fill x
    
    label .newschema.attrlist.label -text "List of Attributes"
#TEMPTEMP -- change order here
    label .newschema.attrlist.spec \
	    -text "Comp Sort Type   Hi    Lo    Name" \
	    -font 9x15
    pack .newschema.attrlist.label -side top -fill x
    pack .newschema.attrlist.spec -side top -anchor nw
    listbox .newschema.attrlist.list -relief raised -bd 1 \
	    -yscrollcommand ".newschema.attrlist.scroll set" \
	    -xscrollcommand ".newschema.attrlist.xscroll set" \
	    -font 9x15 -selectmode extended
    scrollbar .newschema.attrlist.scroll \
	    -command ".newschema.attrlist.list yview"
    scrollbar .newschema.attrlist.xscroll -orient horizontal \
	    -command ".newschema.attrlist.list xview"
    pack .newschema.attrlist.scroll -side right -fill y
    pack .newschema.attrlist.xscroll -side bottom -fill x
    pack .newschema.attrlist.list -fill x 
    
    # By default insert all elements of attrlist into the list
    foreach attr $attrlist {
	# Format before inserting
	set ttype [lindex $attr 0]
	set tsort [lindex $attr 1]
	set thival [lindex $attr 2]
	set tloval [lindex $attr 3]
	set tname [lindex $attr 4]
	set tcomp [lindex $attr 5]
	set tstrlen [lindex $attr 6]
	set fstr [format "%-3.3s  %-3.3s  %-6.6s %-5s %-5s %s" \
		$tcomp $tsort $ttype $thival $tloval $tname]
	.newschema.attrlist.list insert end $fstr

        # Save hidden data in a global array
        global hiddendata
        set hiddendata($tname,strlen) $tstrlen

	set attrnum [expr $attrnum+1]
    }
    
    frame .newschema.attrspec -relief raised
    frame .newschema.attrop -relief raised
    pack .newschema.attrspec .newschema.attrop \
	    -in .newschema.attradd -side top -fill x -padx 3m -pady 1m
    
    frame .newschema.attrname -relief raised -bd 1
    frame .newschema.atype -relief raised -bd 1
    frame .newschema.astrlen -relief raised -bd 1
    frame .newschema.asort -relief raised -bd 1
    frame .newschema.aloval -relief raised -bd 1
    frame .newschema.ahival -relief raised -bd 1
    pack .newschema.attrname .newschema.atype .newschema.astrlen \
            .newschema.asort .newschema.aloval .newschema.ahival \
	    -in .newschema.attrspec -side top -fill x -padx 3m -pady 1m
    
    label .newschema.attrname.label -text "Attribute Name "
    entry .newschema.attrname.entry -width 25 -relief sunken -bd 2 \
	    -textvariable aname
    pack .newschema.attrname.label .newschema.attrname.entry -side left \
	    -padx 3m -pady 1m
    
    label .newschema.aloval.label -text "Attribute Low Value  "
    entry .newschema.aloval.entry -width 25 -relief sunken -bd 2 \
	    -textvariable aloval
    pack .newschema.aloval.label .newschema.aloval.entry -side left \
	    -padx 3m -pady 1m

    label .newschema.ahival.label -text "Attribute High Value "
    entry .newschema.ahival.entry -width 25 -relief sunken -bd 2 \
	    -textvariable ahival
    pack .newschema.ahival.label .newschema.ahival.entry -side left \
	    -padx 3m -pady 1m
    
    label .newschema.atype.label -text "Type   "
    radiobutton .newschema.atype.double -text double -variable atype \
	    -value "double" -anchor nw
    radiobutton .newschema.atype.int -text int -variable atype \
	    -value "int" -anchor nw
    radiobutton .newschema.atype.string -text string -variable atype \
	    -value "string" -anchor nw
    radiobutton .newschema.atype.float -text float -variable atype \
	    -value "float" -anchor nw
    radiobutton .newschema.atype.date -text date -variable atype \
	    -value "date" -anchor nw
    pack .newschema.atype.label .newschema.atype.double .newschema.atype.int \
	    .newschema.atype.string .newschema.atype.float \
	    .newschema.atype.date  -side left -fill x -padx 1m 

    label .newschema.astrlen.label -text "Size   " -fg gray
    entry .newschema.astrlen.entry -width 25 -relief sunken -bd 2 \
         -textvariable astrlen -state disabled
    set astrlen ""
    pack .newschema.astrlen.label .newschema.astrlen.entry -side left \
	    -padx 3m -pady 1m
    trace variable atype w ChgType

    label .newschema.asort.label -text "Sorted "
    radiobutton .newschema.asort.yes -text Yes -variable asort \
	    -value Yes -anchor nw
    radiobutton .newschema.asort.no -text No -variable asort \
	    -value No -anchor nw
    pack .newschema.asort.label .newschema.asort.yes .newschema.asort.no \
	 -side left -fill x -padx 1m
    
    label .newschema.asort.label2 -text "Composite "
    radiobutton .newschema.asort.yes2 -text Yes -variable acomp \
	    -value Yes -anchor nw
    radiobutton .newschema.asort.no2 -text No -variable acomp \
	    -value No -anchor nw
    pack .newschema.asort.no2 .newschema.asort.yes2 .newschema.asort.label2 \
	 -side right -fill x -padx 1m

    button .newschema.attrop.add -text "Add item" -command {
	if {$ahival == ""} {
	    set ahival "none"
	}
	if {$aloval == ""} {
	    set aloval "none"
	}
	set aname [lindex [string trim $aname] 0]
	if {$aname == ""} {
	    showmesg "Attribute name has not been specified."
	    return
	}
	# Increment count
	set attrnum [expr $attrnum+1]
	# Insert into list and clear selection
#TEMPTEMP -- change order here
	set fstr [format "%-3.3s  %-3.3s  %-6.6s %-5s %-5s %s" \
		$acomp $asort $atype $ahival $aloval $aname]
	.newschema.attrlist.list insert end $fstr
        set hiddendata($aname,strlen) $astrlen

	set aname ""
	set acomp No
	set atype "double"
	set astrlen ""
	set asort No
	set ahival ""
	set aloval ""
    }

    button .newschema.attrop.delete -text "Delete item" -command {
	.newschema.attrlist.list delete active
	# Decrement count
	set attrnum [expr $attrnum-1]
    }
    # Set up key binding for modify list
    bind .newschema.attrlist.list <Double-1> {
	set attrl [.newschema.attrlist.list get active] 
	set acomp [lindex $attrl 0]
	set asort [lindex $attrl 1] 
	set atype [lindex $attrl 2]
	set ahival [lindex $attrl 3]
	set aloval [lindex $attrl 4]
	set aname [lindex $attrl 5]

        global hiddendata
	set astrlen $hiddendata($aname,strlen)
        if { $astrlen == 0 } {
            set astrlen ""
        }
    }
    
    button .newschema.attrop.modify -text "Modify item" -command {
	set aname [lindex [string trim $aname] 0]
	if {$aname == ""} {
	    showmesg "Double-click on an item to select it."
	    return
	}
	if {$ahival == ""} {
	    set ahival "none"
	}
	if {$aloval == ""} {
	    set aloval "none"
	}

        set hiddendata($aname,strlen) $astrlen

	set fstr [format "%-3.3s  %-3.3s  %-6.6s %-5s %-5s %s" \
		$acomp $asort $atype $ahival $aloval $aname]
	.newschema.attrlist.list insert active $fstr
	.newschema.attrlist.list delete active
	# Clear selection
	set aname ""
	set acomp No
	set atype "double"
	set astrlen ""
	set asort No
	set ahival ""
	set aloval ""
    }
    pack .newschema.attrop.add .newschema.attrop.delete \
	    .newschema.attrop.modify -side left -padx 3m -pady 1m -expand 1
    
    #-----------------------------------------------------------
    # Bottom portion of window
    button .newschema.opt.save -text Save -command {
	if {$sname == ""} {
	    showmesg "No schema name specified."
	} else {
	    set attrlist {}
	    while {$attrnum > 0} {
		set attr [.newschema.attrlist.list get [expr $attrnum-1]]
		set attrnum [expr $attrnum-1]

                global hiddendata
                set tname [lindex $attr 5]
                set tstrlen $hiddendata($tname,strlen)
                if {$tstrlen > 0} {
                    set attr "$attr $tstrlen"
                }
		
		# Append to attrlist
		set attrlist [linsert $attrlist 0 $attr]
	    }
	    
	    # Write into a file 
	    writephysical $sname $ftype $comm $issepar $separ $attrlist
	    # Update catalog with this new physical schema (if new).
	    if {[info exists Logical($sname)] == 0} {
		# Since this is the initial version of the physical schema
		# we will create a default logical schema. This is simply
		# a file in the logical schema dir which has the same name
		# and points to this as its physical schema. No groups are
		# defined yet.
		writeDefaultLogical $sname
		set Logical($sname) [list $sname]
		writecatalog
	    }
            trace vdelete atype w ChgType
	    destroy .newschema
	}
    }

    button .newschema.opt.quit -text Cancel -command {
            trace vdelete atype w ChgType
            destroy .newschema
    }

    pack .newschema.opt.save .newschema.opt.quit  -side left \
	    -padx 3m -pady 1m -expand 1
    
    # modified by DD so that it works with FSBox

    tkwait visibility .newschema
    grab .newschema

    tkwait window .newschema
}

#-----------------------------------------------------------
proc newschema {} {
    global sname ftype comm issepar separ attrlist aname acomp
    global atype astrlen asort tgrps ahival aloval

    # First set up some global variables
    set sname ""
    set ftype ascii
    set comm "//"
    set issepar 1
    set separ "' '"
    set attrlist ""
    set aname ""
    set acomp No
    set atype "double"
    set astrlen 0
    set asort No
    set tgrps ""
    set ahival ""
    set aloval ""

    # Call function to display the window
    newschemawin
}

#-----------------------------------------------------------
proc openschema {filename} {
    global sname ftype comm issepar separ attrlist aname acomp
    global atype asort tgrps ahival aloval fsBox schemadir

    # Set some defaults
    set sname ""
    set ftype ascii
    set comm "//"
    set issepar 1
    set separ "' '"
    set attrlist ""
    set aname ""
    set acomp No
    set atype "double"
    set astrlen ""
    set asort No
    set tgrps ""
    set ahival ""
    set aloval ""

    # Read the file and get the contents
    readphysical $filename

    # Call function to display the schema
    newschemawin
}

#-----------------------------------------------------------
# General function to display a message
proc showmesg {str} {
    toplevel .msg
    wm title .msg Message
    wm geometry .msg +100+100
    
    frame .msg.str -relief raised -bd 1
    frame .msg.ok -relief raised
    pack .msg.str .msg.ok -side top -fill x -padx 3m -pady 3m

    message .msg.str.msg -width 3i -text $str
    pack .msg.str.msg -side right -expand 1 -fill both -padx 3m -pady 3m

    button .msg.ok.but -text OK -command {destroy .msg}
    pack .msg.ok.but -side top -expand 1 -padx 3m -pady 1m

    tkwait visibility .msg
    grab set .msg
    tkwait window .msg
}

################################################################
proc writelogical {name} {
    global tgrps schemadir physchema

    set f [open $schemadir/logical/$name w]

    set header [DEVise getFileHeader logSchema]
    puts $f $header
    unset header
    
    puts $f "physical $schemadir/physical/$physchema"

    foreach nm $tgrps {
	puts $f ""
	goutput $f $nm
    }

    close $f
}

proc writeQuerylogical {viewName query} {
    global schemadir 

    set f [open $schemadir/query/$viewName w]

#   set header [DEVise getFileHeader querySchema]
#   puts $f $header
#   unset header
#   
#   puts $f "logical $schemadir/logical/$logschema"
	
	puts $f "where"
	puts $f $query

    close $f
}

proc writeDefaultLogical {sname} {
    global schemadir

    set f [open $schemadir/logical/$sname w]

    set header [DEVise getFileHeader logSchema]
    puts $f $header
    unset header

    # Only one line in this default logical file
    puts $f "physical $schemadir/physical/$sname"
    close $f
}

proc writephysical {name type comm issep sep alist} {
    global schemadir

    set f [open $schemadir/physical/$name w]

    set header [DEVise getFileHeader physSchema]
    puts $f $header
    unset header

    if {$comm == ""} {
	set comm "//"
    }
    if {$sep == ""} {
	set sep "' '"
    }

    puts $f "type $name $type" 
    puts $f "comment $comm"
    if {$issep} {
	puts $f "separator $sep"
    } else {
	puts $f "whitespace $sep"
    }
    foreach attr $alist {
	set acomp [lindex $attr 0]
	set asort [lindex $attr 1]
	set atype [lindex $attr 2]
	set ahival [lindex $attr 3]
	set aloval [lindex $attr 4]
	set aname [lindex $attr 5]
	set astrlen [lindex $attr 6]

	if {$asort == "Yes"} {
	    puts -nonewline $f "sorted "
	}
	if {$acomp == "Yes"} {
	    puts -nonewline $f "compattr "
	} else {
	    puts -nonewline $f "attr "
	}
	puts -nonewline $f "$aname $atype"
	if {$atype == "string"} {
	    puts -nonewline $f " $astrlen"
	}
	if {$ahival != "none"} {
	    puts -nonewline $f " hi $ahival"
	}
	if {$aloval != "none"} {
	    puts -nonewline $f " lo $aloval"
	}
	puts $f ""
    }
    close $f
}

##################################################################
proc readlogical {filename} {
    global tgrps schemadir
    set tgrps ""

    # Open file for reading
    set f [open $schemadir/logical/$filename r]

    # First line specifies the physical schema
    set line ""
    readSchemaLine $f line

    # Group declarations
    set len [readSchemaLine $f line]
    while {$len >= 0} {
	set nm [lindex $line 1]
	set tgrps [lappend tgrps $nm]
	ginput $f $nm
	set len [readSchemaLine $f line]
    }
    # Close file
    close $f
}

proc readQuerylogical {filename} {
    
	global tgrps schemadir logicalAttrlist physchema attrlist
	set tgrps ""
	
	set logicalAttrlist ""

    # Open file for reading
    set f [open $schemadir/logical/$filename r]

    # First line specifies the physical schema

    set line ""
    readSchemaLine $f line
	
    # Group declarations
    set len [readSchemaLine $f line]
    while {$len >= 0} {
		set type [lindex $line 0]
		if { $type == "group" } {
		} else {
			set nm [lindex $line 1] 
			if { [lsearch $logicalAttrlist $nm] == -1} {
				set logicalAttrlist [linsert $logicalAttrlist 0 $nm]
			}
		}
		set len [readSchemaLine $f line]
    }

	if { $logicalAttrlist == "" } {
		# read the physical schema and fill up the attribute list..	
		readphysical $physchema
		foreach attr $attrlist {
			set logicalAttrlist [linsert $logicalAttrlist 0 [lindex $attr 4]]
		}
	}	
    # Close file
    close $f
}

proc readQuery {filename} {
    global schemadir query
	
	set query ""
    # Open file for reading
    set f [open $schemadir/query/$filename r]

    # First line specifies the logical schema
	set line ""
    readSchemaLine $f line
	
	set line ""
	readSchemaLine $f query 
	
	# Close file
    close $f
}
proc readphysical {filename} {
    global sname ftype comm issepar separ attrlist schemadir
    set attrlist ""

    # Open file for reading
    set f [open $schemadir/physical/$filename r]

    # First line is the schema name and type
    set line ""
    readSchemaLine $f line
    scan $line "type %s %s" sname ftype

    # Second line is comment
    readSchemaLine $f line
    scan $line "comment %s" comm

    # Third line is separator or whitespace
    readSchemaLine $f line
    set issepar 1
    if {[lindex $line 0] == "whitespace"} {
	set issepar 0
    }
    # everything between the 's is the separator
    set lstart [string first "'" $line]
    set lend [string last "'" $line]
    set separ [string range $line $lstart $lend]

    # Following are all attr declarations
    set len [readSchemaLine $f line]
    set num 0
    while {$len != -1} {

	set sorted No
	if {[lindex $line 0] == "sorted"} {
	    set sorted Yes
	    set line [lrange $line 1 end]
	}

	set acomp No
	if {[lindex $line 0] == "compattr"} {
	    set acomp Yes
	}
	set line [lrange $line 1 end]

	set scanstr "%s %s"
	set argstr "attrname attrtype"

	set strpos [lsearch $line "string"]
	if {$strpos != -1} {
	    set scanstr "$scanstr %d"
	    set argstr "$argstr astrlen"
	}
	set hipos [lsearch $line "hi"]
	if {$hipos != -1} {
	    set scanstr "$scanstr hi %s"
	    set argstr "$argstr hival"
	}
	set lopos [lsearch $line "lo"]
	if {$lopos != -1} {
	    set scanstr "$scanstr lo %s"
	    set argstr "$argstr loval"
	}

	set astrlen 0
	set hival "none"
	set loval "none"

	set cmd "scan \$line \"$scanstr\" $argstr"
	eval $cmd
	
	set attr [list $attrtype $sorted $hival $loval $attrname $acomp \
		$astrlen]

	#puts "ATTR LIST Inserting .. $attr"

	set attrlist [linsert $attrlist $num $attr]
	set len [readSchemaLine $f line]
	set num [expr $num+1]
    }

    close $f
    set sname $filename
}

###################################################################

# Read a line from a schema file, skipping blank and comment lines.
proc readSchemaLine { fileId bufRef } {
    upvar $bufRef buf

    set len 0
    set buf ""
    while {[lindex $buf 0] == "" || [string range $buf 0 0] == "#"} {
        set len [gets $fileId buf]
	if {$len == -1} {
	    return $len
	}
    }

    return $len
}

###################################################################

proc gbrowse {} {
    global tgrps glist logschema physchema Logical attrlist iname

    toplevel .gbrowse
    wm title .gbrowse "$physchema View : $logschema"
    wm geometry .gbrowse +50+50
    wm iconname .gbrowse "Groups"

    # Toplevel rows
    frame .gbrowse.attrs -relief raised
    frame .gbrowse.list -relief raised
    frame .gbrowse.ops -relief raised
    pack .gbrowse.attrs .gbrowse.list .gbrowse.ops \
	    -side top -fill x -padx 3m -pady 1m

    #----------------------------------------------------------
    # Create a listbox with all the attrs in the physical schema
    readphysical $physchema
    label .gbrowse.attrs.label -text "List of Attributes"
    pack .gbrowse.attrs.label -side top -fill x
    listbox .gbrowse.attrs.list -relief raised -bd 1 \
	    -yscrollcommand ".gbrowse.attrs.scroll set" \
	    -font 9x15 -selectmode single
    scrollbar .gbrowse.attrs.scroll -command ".gbrowse.attrs.list yview"
    pack .gbrowse.attrs.scroll -side right -fill y
    pack .gbrowse.attrs.list -fill x

    # Populate the list with all the attrs 
    foreach attr $attrlist {
	.gbrowse.attrs.list insert end [lindex $attr 4]
    }

    # Bind the mouse click on this list
    bind .gbrowse.attrs.list <Double-1> {
	set iname [.gbrowse.attrs.list get active]
    }

    #-----------------------------------------------------------
    # Create a listbox displaying list of groups
    #    CreateTextBitmap .gbrowse.list.label group.gif Groups
    label .gbrowse.list.label -text "List of Groups"
    pack .gbrowse.list.label -side top -fill x

    listbox .gbrowse.list.list -relief raised -bd 1 \
	    -yscrollcommand ".gbrowse.list.scroll set" \
	    -font 9x15 -selectmode single
    scrollbar .gbrowse.list.scroll \
	    -command ".gbrowse.list.list yview"
    pack .gbrowse.list.scroll  -side right -fill y
    pack .gbrowse.list.list  -fill x 


    # Insert all existing top level groups into the listbox
    foreach nm $tgrps {
	.gbrowse.list.list insert end $nm
    }

    # Set up binding
    bind .gbrowse.list.list <Double-1> {
	set gname [.gbrowse.list.list get active]
    }


    # Panel for group name and panels for create, delete and modify
    frame .gbrowse.ops.name -relief raised -bd 1
    frame .gbrowse.ops.op -relief raised
    pack .gbrowse.ops.name .gbrowse.ops.op -side top -fill x \
	    -padx 3m -pady 1m

    label .gbrowse.ops.name.label -text "Group Name "
    entry .gbrowse.ops.name.entry -width 15 -relief sunken -bd 2 \
	    -textvariable gname
    pack .gbrowse.ops.name.label .gbrowse.ops.name.entry -side left \
	    -fill x -padx 1m -pady 1m -expand 1

    button .gbrowse.ops.op.create -text "Create" -command {
	if {$gname == ""} {
	    showmesg "Please specify the name of the group."
	} elseif {[info exists glist($gname)] == 1} {
	    showmesg "Group with this name already exists."
	    set gname ""
	} else {
	    set glist($gname) ""
	    dispgrp $gname
	}
    }
    button .gbrowse.ops.op.delete -text "Delete" -command {
	if {$gname == ""} {
	    showmesg "Please specify the name of the group."
	} else {
	    # Search through tgrps and delete gname 
	    set idx [lsearch $tgrps $gname]
	    if {$idx == -1} {
		showmesg "Group with this name does not exist."
	    } else {
		set tgrps [lreplace $tgrps $idx $idx]
		delgrp $gname
		# Remove entry from the list box
		set i 0
		while {[.gbrowse.list.list get $i] != $gname} {
		    set i [expr $i+1]
		}
		.gbrowse.list.list delete $i
	    }
	    set gname ""
	}
    }
    button .gbrowse.ops.op.modify -text "Modify" -command {
	if {$gname == ""} {
	    showmesg "Please specify the name of the group."
	} elseif {[lsearch $tgrps $gname] == -1} {
	    showmesg "Group with this name does not exist."
	} else {
	    dispgrp $gname
	}
    }
    button .gbrowse.ops.op.quit -text "Quit" -command {
#	printgrps 
	writelogical $logschema
	# Update catalog if needed
	if {[lsearch $Logical($physchema) $logschema] == -1} {
	    set Logical($physchema) [lappend Logical($physchema) $logschema]
	    writecatalog
	}
	set logschema ""
	set physchema ""
	set tgrps ""
	destroy .gbrowse
    }
    pack .gbrowse.ops.op.create .gbrowse.ops.op.delete \
	    .gbrowse.ops.op.modify .gbrowse.ops.op.quit \
	    -side left -padx 3m -pady 1m -expand 1
}

proc qbrowse {_isSingle {_viewName ""} {logicalAttrlist ""}
		{_from ""} {_select ""} {_as ""} {_where ""}} {
	global schemadir

	global isSingle
 	set isSingle $_isSingle

	global viewName
 	set viewName $_viewName

	global from select as where
	set from $_from
	set select $_select
	set as $_as
	set where $_where

	puts "select = $select"
	global fromCnt attrCnt

	global q_retVal

	set fromCnt 1
	set attrCnt 1

    toplevel .gbrowse
    wm title .gbrowse "View Definition"
    wm geometry .gbrowse +50+50
    wm iconname .gbrowse "Groups"

    frame .gbrowse.fname -relief raised -bd 1

    label .gbrowse.fname.label -text "View Name "
    entry .gbrowse.fname.entry -width 25 -relief sunken -bd 2 \
	    -textvariable viewName

#   label .gbrowse.ops.select.label -text "SELECT "
#   entry .gbrowse.ops.select.entry -width 100 -relief sunken -bd 2 \
#	    -textvariable select 
    
    # Toplevel rows
    frame .gbrowse.attrs -relief raised
    frame .gbrowse.list -relief raised
    frame .gbrowse.ops -relief raised
    pack .gbrowse.fname .gbrowse.attrs .gbrowse.list .gbrowse.ops \
	    -side top -fill x -padx 3m -pady 1m

    pack .gbrowse.fname.label .gbrowse.fname.entry -side left -padx 1m \
 	    -pady 1m

    #----------------------------------------------------------
    # Create a listbox with all the attrs in the logical schema
	
	label .gbrowse.attrs.label -text "Available Attributes"
    pack .gbrowse.attrs.label -side top -fill x
    listbox .gbrowse.attrs.list -relief raised -bd 1 \
	    -yscrollcommand ".gbrowse.attrs.scroll set" \
	    -font 9x15 -selectmode single
    scrollbar .gbrowse.attrs.scroll -command ".gbrowse.attrs.list yview"
    pack .gbrowse.attrs.scroll -side right -fill y
    pack .gbrowse.attrs.list -fill x

    # Populate the list with all the attrs 
    foreach attr $logicalAttrlist {
	  .gbrowse.attrs.list insert end "t.$attr" 
	  if {$select == ""} {
		  append select "t.$attr"
	  } else {
	  	 append select ", t.$attr"
	  }
	  if {$as == ""} {
		  append as $attr
	  } else {
	  	 append as ", $attr"
	  }
    }

    # Bind the mouse click on this list
    bind .gbrowse.attrs.list <Double-1> {
	  set where  "$where [.gbrowse.attrs.list get active] "
    }

    
	frame .gbrowse.ops.from -relief raised -bd 1
	frame .gbrowse.ops.select -relief raised -bd 1
	frame .gbrowse.ops.as -relief raised -bd 1
	frame .gbrowse.ops.where -relief raised -bd 1
	
    frame .gbrowse.ops.op -relief raised
    if {!$isSingle} {
    		pack .gbrowse.ops.from -side top
	}

    pack .gbrowse.ops.select .gbrowse.ops.as .gbrowse.ops.where -side top 

    pack .gbrowse.ops.op -side top -fill x -padx 3m -pady 1m

    label .gbrowse.ops.from.label -text "FROM "
    entry .gbrowse.ops.from.entry -width 85 -relief sunken -bd 2 \
	    -textvariable from 
    button .gbrowse.ops.from.selbox -text "Select..." -width 10 -command {
         set table [selectStream]
		if {$from == ""} {
			append from "$table as t$fromCnt"
		} else {
			append from ", $table as t$fromCnt"
		}
	    set attrs [DEVise dteListAttributes $table]
	    foreach attr $attrs {
	    		set fullAttr "t$fromCnt.$attr"
	    		set attrName "attr$attrCnt"
			incr attrCnt
			.gbrowse.attrs.list insert end $fullAttr 
			if {$select == ""} {
				append select $fullAttr
			} else {
				append select ", $fullAttr"
			}
			if {$as == ""} {
				append as $attrName
			} else {
				append as ", $attrName"
			}
	    }
	    incr fromCnt
    }

    label .gbrowse.ops.select.label -text "SELECT "
    entry .gbrowse.ops.select.entry -width 100 -relief sunken -bd 2 \
	    -textvariable select 

    label .gbrowse.ops.as.label -text "AS "
    entry .gbrowse.ops.as.entry -width 100 -relief sunken -bd 2 \
	    -textvariable as 

    label .gbrowse.ops.where.label -text "WHERE "
    entry .gbrowse.ops.where.entry -width 100 -relief sunken -bd 2 \
	    -textvariable where 

    pack .gbrowse.ops.from.label .gbrowse.ops.from.entry \
         .gbrowse.ops.from.selbox -side left \
	    -fill x -padx 1m -pady 1m -expand 1
    pack .gbrowse.ops.select.label .gbrowse.ops.select.entry -side left \
	    -fill x -padx 1m -pady 1m -expand 1
    pack .gbrowse.ops.as.label .gbrowse.ops.as.entry -side left \
	    -fill x -padx 1m -pady 1m -expand 1
    pack .gbrowse.ops.where.label .gbrowse.ops.where.entry -side left \
	    -fill x -padx 1m -pady 1m -expand 1
    
    button .gbrowse.ops.op.and -text "AND" -command {
	    set where "$where AND " 
    }
    button .gbrowse.ops.op.or -text "OR" -command {
	    set where "$where OR " 
    }
    button .gbrowse.ops.op.lbrac -text "(" -command {
	    set where "$where ( " 
    }
    button .gbrowse.ops.op.rbrac -text ")" -command {
	    set where "$where ) " 
    }
    button .gbrowse.ops.op.albrac -text "<" -command {
	    set where "$where < " 
    }
    button .gbrowse.ops.op.arbrac -text ">" -command {
	    set where "$where > " 
    }
    button .gbrowse.ops.op.eq -text "=" -command {
	    set where "$where = " 
    }
    button .gbrowse.ops.op.ne -text "!=" -command {
	    set where "$where != " 
    }
    
    pack .gbrowse.ops.op.and .gbrowse.ops.op.or \
	    .gbrowse.ops.op.lbrac\
	    .gbrowse.ops.op.rbrac .gbrowse.ops.op.albrac \
	    .gbrowse.ops.op.arbrac .gbrowse.ops.op.eq\
	    .gbrowse.ops.op.ne \
	    -side left -padx 3m -pady 1m -expand 1

	frame .gbrowse.but -relief groove -borderwidth 2
	button .gbrowse.but.display -text "Display" -width 10 -command {
		global displayImmediately
		set displayImmediately 1
		if {[qbrowseOKAction] == "OK"} {
			destroy .gbrowse
		}
	}
	button .gbrowse.but.ok -text "OK" -width 10 -command {
		global displayImmediately
		set displayImmediately 0
		if {[qbrowseOKAction] == "OK"} {
			destroy .gbrowse
		}
    }

	button .gbrowse.but.cancel -text "Cancel" -width 10 -command {
		set q_retVal ""
		destroy .gbrowse
	}

	pack .gbrowse.but -side top -fill x
	if {!$isSingle} {
		pack .gbrowse.but.display .gbrowse.but.ok .gbrowse.but.cancel \
		          -side left -padx 7m -pady 2m -expand 1
	} else {
		pack .gbrowse.but.ok .gbrowse.but.cancel \
			-side left -padx 7m -pady 2m -expand 1
	}

 	tkwait visibility .gbrowse
 	grab .gbrowse
	tkwait window .gbrowse
	return $q_retVal
}

proc qbrowseOKAction {} {
	global viewName from isSingle select as where q_retVal

	if {$viewName == "" || ($from == "" && !$isSingle) || 
		$select == "" || $as == ""} {
		dialog .noName "Missing Information" \
			"Please Enter All Required Information." "" 0 OK
		return ""
	}
	set q_retVal [list $viewName $from $select $as $where]
	return "OK"
}

proc saveViewFile {fileName select as where} {

	set f [open $fileName w]

#   set header [DEVise getFileHeader schemaCat]
#   puts $f $header
#   unset header

#   puts $f "# Association between physical and logical schemas"
#   puts $f ""

	set w_as [split $as ,]
	puts $f [llength $w_as]
	foreach itm $w_as {
		puts $f " $itm"
	}
	puts $f [addQuotes $select]
	puts $f [addQuotes $where]
	close $f
	return $fileName
}

proc dispgrp {gname } {
    global glist tgrps currgrp cnt iname
    # Displays the group information and allows modification

    set currgrp $gname 

    toplevel .grp
    wm title .grp Group 
    wm geometry .grp +100+100

    frame .grp.list -relief raised
    frame .grp.ops -relief raised
    frame .grp.bot -relief raised
    pack .grp.list .grp.ops .grp.bot -side top -fill x -padx 3m -pady 1m

    # List showing current group structure
    label .grp.list.label -text "Display for Group : $gname"
    pack .grp.list.label -side top -fill x

    listbox .grp.list.list -relief raised -bd 1 \
	    -yscrollcommand ".grp.list.scroll set" \
	    -font 9x15 -selectmode extended
    scrollbar .grp.list.scroll -command ".grp.list.list yview"
    pack .grp.list.scroll  -side right -fill y
    pack .grp.list.list  -fill x 

    # Insert all the existing members of the group into the list
    glinsert $gname 0

    # Frame containing item and nested grp info
    frame .grp.curr -relief raised
    pack .grp.curr -in .grp.ops -side top -fill x -padx 2m -pady 1m
    label .grp.curr.label -text "Current group "
    entry .grp.curr.entry -width 25 -relief sunken -bd 2 \
	    -textvariable currgrp
    pack .grp.curr.label .grp.curr.entry -side left -padx 2m -expand 1

    frame .grp.item -relief raised -bd 1
    frame .grp.ngrp -relief raised -bd 1 
    pack .grp.item .grp.ngrp -in .grp.ops -side left -padx 2m -pady 1m \
	    -expand 1

    frame .grp.item.top -relief raised
    frame .grp.item.mid -relief raised
    frame .grp.item.bot -relief raised
    pack .grp.item.top .grp.item.mid .grp.item.bot -side top -fill x \
	    -padx 1m -pady 1m

    label .grp.item.top.label -text "Item"
    pack .grp.item.top.label 
    
    label .grp.item.mid.label -text "Name "
    entry .grp.item.mid.entry -width 25 -relief sunken -bd 2 \
	    -textvariable iname
    pack .grp.item.mid.label .grp.item.mid.entry -side left -fill x \
	    -padx 3m -pady 1m

    button .grp.item.bot.add -text "Insert" -command {
	set iname [lindex [string trim $iname] 0]
	if {$iname == ""} {
	    showmesg "Please specify the name of the item."
	    return
	}
	if {$currgrp == ""} {
	    showmesg "Specify the current group into which the item would \
		    be inserted."
	    return
	}
	if {[info exists glist($currgrp)] == 0} {
	    showmesg "Current group $currgrp is invalid."
	    return
	}
	set elem [list $iname i]
	set glist($currgrp) [lappend glist($currgrp) $elem]
	# Now insert in the listbox
	set cnt -1
	endpos $gname $currgrp 
	# Actual position got by decrementing
	set cnt [expr $cnt-1]
	# Have to calculate prefix blanks before inserting into listbox
	set level [getLevel $gname $currgrp]
	set level [expr $level*2]
	set s s
	set prefix [format "%$level$s" " "]
	.grp.list.list insert $cnt $prefix$iname
	set iname ""
    }

    button .grp.item.bot.del -text "Delete" -command {
	set iname [lindex [string trim $iname] 0]
	if {$iname == ""} {
	    showmesg "Please specify the name of the item."
	    return
	}
	set gr $gname
	set nm [gsearch $gname $iname]
	if {$nm == ""} {
	    showmesg "Item <$iname> does not exist."
	    return
	}
	set elem [list $iname i]
	set idx [lsearch $glist($nm) $elem]
	set glist($nm) [lreplace $glist($nm) $idx $idx]
	#  Also remove from the listbox
	set idx 0
	set elem [.grp.list.list get $idx]
	set elem [string trim $elem]
	while {$elem != $iname} {
	    set idx [expr $idx+1]
	    set elem [.grp.list.list get $idx]
	    set elem [string trim $elem]
	}
	.grp.list.list delete $idx
	set iname ""
    }
    pack .grp.item.bot.add  \
	    .grp.item.bot.del -side left -expand 1 -padx 3m -pady 1m

    frame .grp.ngrp.top -relief raised
    frame .grp.ngrp.mid -relief raised
    frame .grp.ngrp.bot -relief raised
    pack .grp.ngrp.top .grp.ngrp.mid .grp.ngrp.bot -side top -fill x \
	    -padx 1m -pady 1m

    label .grp.ngrp.top.label -text "Sub Group"
    pack .grp.ngrp.top.label 
    
    label .grp.ngrp.mid.label -text "Name "
    entry .grp.ngrp.mid.entry -width 25 -relief sunken -bd 2 \
	    -textvariable ngname
    pack .grp.ngrp.mid.label .grp.ngrp.mid.entry -side left -fill x \
	    -padx 3m -pady 1m

    button .grp.ngrp.bot.add -text "Create" -command {
	set ngname [lindex [string trim $ngname] 0]
	if {$ngname == ""} {
	    showmesg "Please specify the name of the sub group."
	    return
	}
	if {[info exists glist($currgrp)] == 0} {
	    showmesg "Current group $currgrp is not valid."
	    return
	}
	set elem [list $ngname g]
	set glist($currgrp) [lappend glist($currgrp) $elem]
	set glist($ngname) ""
	set level [getLevel $gname $currgrp]
	set level [expr $level*2]
	set s s
	set prefix [format "%$level$s" " "]
	
	set cnt -1
	endpos $gname $currgrp
	# Actual position by subtracting 2
	set cnt [expr $cnt-2]
	
	set line "end group $ngname"
	.grp.list.list insert $cnt $prefix$line
	set line "begin group $ngname"
	.grp.list.list insert $cnt $prefix$line
	set nlist [lappend nlist $currgrp]
	set currgrp $ngname
	set ngname ""
    }
    button .grp.ngrp.bot.del -text "Delete" -command {
	set ngname [lindex [string trim $ngname] 0]
	if {$ngname == ""} {
	    showmesg "Please specify the name of the sub group."
	    return
	}
	set outer [gsearch $gname $ngname]
	if {$outer == ""} {
	    showmesg "Subgroup $ngname is invalid."
	    return
	}
	set elem [list $ngname g]
	set idx [lsearch $glist($outer) $elem]
	set glist($outer) [lreplace $glist($outer) $idx $idx]
	delgrp $ngname
	# Now remove from the listbox
	set idx 0
	set elem [.grp.list.list get $idx]
	set elem [string trim $elem]
	set start "begin group $ngname"
	while {$elem != $start} {
	    set idx [expr $idx+1]
	    set elem [.grp.list.list get $idx]
	    set elem [string trim $elem]
	}
	set dest "end group $ngname"
	while {$elem != $dest} {
	    .grp.list.list delete $idx
	    set elem [.grp.list.list get $idx]
	    set elem [string trim $elem]
	}
	.grp.list.list delete $idx
	set ngname ""
    }
    pack .grp.ngrp.bot.add .grp.ngrp.bot.del \
	    -side left -expand 1 -padx 3m -pady 1m

    # Bind the mouse click on the listbox
    bind .grp.list.list <Double-1> {
	set selec [.grp.list.list get active]
	set selec [string trim $selec]
	set first [lindex $selec 0]
	if {$first == "begin"} {
	    set currgrp [lindex $selec 2]
	} elseif {$first == "end"} {
	    set currgrp [lindex $selec 2]
	} else {
	    set iname $first
	}
    }
	
    # Frame containing save and cancel buttons
    button .grp.bot.save -text "Save" -command {
	destroy .grp
	# Insert gname into main group list if not already present
	set len [.gbrowse.list.list index end]
	set i 0
	while {($i < $len) && ([.gbrowse.list.list get $i] != $gname)} {
	    incr i
	}
	if {$i >= $len} {
	    set tgrps [lappend tgrps $gname]
	    .gbrowse.list.list insert end $gname
	}

	# reset nlist
	set nlist ""
	set ngname ""
	set iname ""
    }
    button .grp.bot.cancel -text "Cancel" -command {
	destroy .grp
	set ngname ""
	set iname ""
    }
    pack .grp.bot.save .grp.bot.cancel -side left -expand 1 \
	    -padx 3m -pady 1m    
}

proc printgrps {} {
    global tgrps
    # Loop through all the top level groups 
    foreach top $tgrps {
	puts "Top level group-----------$top"
	printgrp $top
    }
}

proc printgrp {name} {
    global glist

    puts "Group $name"
    foreach elem $glist($name) {
	set nm [lindex $elem 0]
	set ty [lindex $elem 1]
	if {$ty == "i"} {
	    puts "Item $nm"
	} else {
	    printgrp $nm
	}
    }

    puts "End of group $name"
}

proc glinsert {name level} {
    global glist 

    # At this level the prefix consists of "level" spaces
    set s s
    set prefix [format "%$level$s" " "]

    # inserts members of the group into a listbox
    foreach elem $glist($name) {
	set nm [lindex $elem 0]
	set ty [lindex $elem 1]
	if {$ty == "i"} {
	    .grp.list.list insert end $prefix$nm
	} else {
	    set line "begin group $nm"
	    .grp.list.list insert end $prefix$line
	    glinsert $nm [expr $level+2]
	    set line "end group $nm"
	    .grp.list.list insert end $prefix$line
	}
    }
}

proc goutput {f name} {
    global glist

    # output the group structure for nm to file f

    puts $f "group $name"
    foreach elem $glist($name) {
	set nm [lindex $elem 0]
	set ty [lindex $elem 1]
	if {$ty == "i"} {
	    puts $f "item $nm"
	} else {
	    goutput $f $nm
	}
    }

    puts $f "endgroup"
}

proc ginput {f name} {
    global glist

    set glist($name) ""

    while {1} {
	set len [gets $f line]
	if {$len < 0} {
	    break
	}

	set line [string trim $line]
	if {$line == "" || $line == "endgroup"} {
	    break
	}

	set ty [lindex $line 0]
	set nm [lindex $line 1]
	if {$ty == "item"} {
	    set elem [list $nm i]
	    set glist($name) [lappend glist($name) $elem]
	} elseif {$ty == "group"} {
	    set elem [list $nm g]
	    set glist($name) [lappend glist($name) $elem]
	    ginput $f $nm
	} else {
	    puts "Unrecognized keyword $ty ignored."
	}
    }
}

proc delgrp {name} {
    global glist

    # delete all the members of the group
    
    foreach elem $glist($name) {
	set nm [lindex $elem 0]
	set ty [lindex $elem 1]
	if {$ty == "g"} {
	    delgrp $nm
	}
    }
    unset glist($name)
}


proc gsearch {gnm inm} {
    global glist

    # Searches for the item "inm" in the group "gnm". It recursively
    # traverses the nested sub groups and returns the name of the 
    # immediate outer group in which the item is found.
    # Returns null string if the item is not found

    foreach elem $glist($gnm) {
	set nm [lindex $elem 0]
	if {$nm == $inm} {
	    return $gnm
	}
	set ty [lindex $elem 1]
	if {$ty == "g"} {
	    set ret [gsearch $nm $inm]
	    if {$ret != ""} {
		return $ret
	    }
	}
    }

    return ""
}

proc endpos {gnm ngnm} {
    global glist cnt

    # This function returns the "flattened" position of the item "inm"
    # within the group "gnm". This would be the line number of this
    # item within the listbox displaying the group
    # Returns 0 if the item was not found, 1 if found

    foreach elem $glist($gnm) {
	set cnt [expr $cnt+1]
	set nm [lindex $elem 0]
	set ty [lindex $elem 1]
	if {$ty == "g"} {
	    set ret [endpos $nm $ngnm]
	    if {$ret == 1} {
		return 1
	    }
	}

	if {$nm == $ngnm} {
	    return 1
	}

    }
    set cnt [expr $cnt+1]
    return 0
}

proc begpos {gnm ngnm} {
    global glist cnt

    # This function returns the "flattened" position of the item "inm"
    # within the group "gnm". This would be the line number of this
    # item within the listbox displaying the group
    # Returns 0 if the item was not found, 1 if found

    foreach elem $glist($gnm) {
	set cnt [expr $cnt+1]
	set nm [lindex $elem 0]
	set ty [lindex $elem 1]
	if {$nm == $ngnm} {
	    return 1
	}
	if {$ty == "g"} {
	    set ret [endpos $nm $ngnm]
	    if {$ret == 1} {
		return 1
	    }
	}

    }
    set cnt [expr $cnt+1]
    return 0
}

#########################################################################
proc writecatalog {} {
    global Logical schemadir

    set f [open $schemadir/catalog.tcl w]

    set header [DEVise getFileHeader schemaCat]
    puts $f $header
    unset header

    puts $f "# Association between physical and logical schemas"
    puts $f ""

    foreach itm [lsort [array names Logical]] {
	puts $f "set \"Logical($itm)\" \{$Logical($itm)\}"
    }
    close $f
}

proc writeQuerycatalog {} {
    global Query schemadir

    set f [open $schemadir/Querycatalog.tcl w]

    set header [DEVise getFileHeader schemaCat]
    puts $f $header
    unset header
    
	puts $f "# Association between logical and Query schemas"
    puts $f ""

    foreach itm [lsort [array names Query]] {
		if {[info exists Query($itm)]} {
			puts $f "set \"Query($itm)\" \{$Query($itm)\}"
		}
    }
    close $f
}
##########################################################################

proc displogical {pname} {
    global schemadir tgrps logschema Logical physchema button

    set physchema $pname
    
    # Display the logical schema corr. to the passed physical schema
    toplevel .lsch
    wm title .lsch "Current Views"
    wm geometry .lsch +50+50

    frame .lsch.top -relief raised
    frame .lsch.mid -relief raised
    frame .lsch.bot -relief raised
    frame .lsch.ent -relief raised
    pack .lsch.top .lsch.mid .lsch.ent .lsch.bot \
	    -side top -fill x -padx 1m -pady 1m

    # Entry for schema name
    label .lsch.ent.label -text "Schema name : "
    entry .lsch.ent.entry -width 25 -relief sunken -bd 2 \
	    -textvariable logschema
    pack .lsch.ent.label .lsch.ent.entry -side left -padx 1m 

    # Label on top
    label .lsch.top.label -text "$pname   Schemas"
    pack .lsch.top.label

    # Listbox with scrollbar in the middle
    listbox .lsch.mid.list -relief raised -bd 1 \
	    -yscrollcommand ".lsch.mid.scroll set" \
	    -font 9x15 -selectmode single
    scrollbar .lsch.mid.scroll -command ".lsch.mid.list yview"
    pack .lsch.mid.scroll -side right -fill y
    pack .lsch.mid.list -fill x

    # bind mouse click on the listbox
    bind .lsch.mid.list <Double-1> {
	set logschema [.lsch.mid.list get active]
    }

    # Populate the listbox based on the Logical array values
    if {[info exists Logical($pname)] == 0} {
	set Logical($pname) ""
    }
    foreach itm $Logical($pname) {
	.lsch.mid.list insert end $itm
    }

    # Button to create a New one, Open or Quit
    button .lsch.bot.new -text New -command {
	if {$logschema == ""} {
	    showmesg "Please type in the name of the schema to be created."
	} else {
	    set tgrps ""
	    destroy .lsch
	    gbrowse
	}
    }
    button .lsch.bot.open -text Open -command {
	if {$logschema == ""} {
	    showmesg "Please choose a schema by clicking on the entry."
	} else {
	    destroy .lsch
	    readlogical $logschema
	    gbrowse
	}
    }

    button .lsch.bot.del -text Remove -command {
	if {$logschema == ""} {
	    showmesg "Please select the view to remove by clicking on \
		    the entry."
	} else {
	    dialog .rem "Remove View" \
		    "This will remove the view permanently. Proceed ? " \
		    "" 0 Yes No
	    if {$button == 0} {
		set idx [lsearch $Logical($physchema) $logschema]
		if {$idx == -1} {
		    dialog .note "Unknown View" \
			    " The view does not exist. Cannot remove it." \
			    "" 0 OK
		    return
		}
		set Logical($physchema) [lreplace $Logical($physchema) $idx $idx]
		writecatalog
		# Remove the entry from the listbox 
		set len [.lsch.mid.list index end]
		set i 0
		while {[.lsch.mid.list get $i] != $logschema} {
		    incr i
		}
		.lsch.mid.list delete $i
		exec rm $schemadir/logical/$logschema
		set logschema ""
	    }
	}
    }
    button .lsch.bot.quit -text Quit -command {
	destroy .lsch
    }
    pack .lsch.bot.new .lsch.bot.open .lsch.bot.del .lsch.bot.quit \
	    -side left -padx 3m -pady 1m -expand 1

    # Finally grab focus
    tkwait visibility .lsch
    grab set .lsch
    tkwait window .lsch
}

proc dispQuerylogical {pname} {
    global schemadir tgrps logschema Logical physchema button

    set physchema $pname
    
    # Display the logical schema corr. to the passed physical schema
    toplevel .lsch
    wm title .lsch "Current Views"
    wm geometry .lsch +50+50

    frame .lsch.top -relief raised
    frame .lsch.mid -relief raised
    frame .lsch.bot -relief raised
    frame .lsch.ent -relief raised
    pack .lsch.top .lsch.mid .lsch.ent .lsch.bot \
	    -side top -fill x -padx 1m -pady 1m

    # Entry for schema name
    #label .lsch.ent.label -text "Schema name : "
	#entry .lsch.ent.entry -width 25 -relief sunken -bd 2 \
	#    -textvariable logschema
	#pack .lsch.ent.label .lsch.ent.entry -side left -padx 1m 

    # Label on top
    label .lsch.top.label -text "$pname  Views"
    pack .lsch.top.label

    # Listbox with scrollbar in the middle
    listbox .lsch.mid.list -relief raised -bd 1 \
	    -yscrollcommand ".lsch.mid.scroll set" \
	    -font 9x15 -selectmode single
    scrollbar .lsch.mid.scroll -command ".lsch.mid.list yview"
    pack .lsch.mid.scroll -side right -fill y
    pack .lsch.mid.list -fill x

    # bind mouse click on the listbox
    #bind .lsch.mid.list <Double-1> {
	#set logschema [.lsch.mid.list get active]
    #}

    # Populate the listbox based on the Logical array values
    if {[info exists Logical($pname)] == 0} {
		set Logical($pname) ""
    }
    foreach itm $Logical($pname) {
	.lsch.mid.list insert end $itm
    }

    # Button to Open or Quit
    button .lsch.bot.open -text Queries -command {
		
		set logschema [.lsch.mid.list get active]
		if {$logschema == ""} {
	    showmesg "Please type in the name of the schema to be chosen."
		} else {
	    	set tgrps ""
	    	destroy .lsch
			# pass the physical and logical schemas
	    	dispQuery $physchema $logschema
		}
    }

    button .lsch.bot.quit -text Quit -command {
	destroy .lsch
    }
    pack .lsch.bot.open .lsch.bot.quit \
	    -side left -padx 3m -pady 1m -expand 1

    # Finally grab focus
    tkwait visibility .lsch
    grab set .lsch
    tkwait window .lsch
}

proc dispQuery {pname lname} {

    global schemadir Query button

    set physchema $pname
    set logschema $lname
    
    # Display the query schemas corr. to the passed logical schema
    toplevel .lsch
    wm title .lsch "Current Queries"
    wm geometry .lsch +50+50

    frame .lsch.top -relief raised
    frame .lsch.mid -relief raised
    frame .lsch.bot -relief raised
    frame .lsch.ent -relief raised
    pack .lsch.top .lsch.mid .lsch.ent .lsch.bot \
	    -side top -fill x -padx 1m -pady 1m

    # Entry for schema name
    label .lsch.ent.label -text "Query name : "
    entry .lsch.ent.entry -width 25 -relief sunken -bd 2 \
	    -textvariable queryName 
    pack .lsch.ent.label .lsch.ent.entry -side left -padx 1m 

    # Label on top
    label .lsch.top.label -text "$pname   Queries"
    pack .lsch.top.label

    # Listbox with scrollbar in the middle
    listbox .lsch.mid.list -relief raised -bd 1 \
	    -yscrollcommand ".lsch.mid.scroll set" \
	    -font 9x15 -selectmode single
    scrollbar .lsch.mid.scroll -command ".lsch.mid.list yview"
    pack .lsch.mid.scroll -side right -fill y
    pack .lsch.mid.list -fill x

    # bind mouse click on the listbox
    bind .lsch.mid.list <Double-1> {
	set queryName [.lsch.mid.list get active]
    }

    # Populate the listbox based on the Logical array values
    if {[info exists Query($pname,$lname)] == 0} {
		set Query($pname,$lname) ""
    }
    foreach itm $Query($pname,$lname) {
	.lsch.mid.list insert end $itm
    }

    # Button to create a New one, Open or Quit
    button .lsch.bot.new -text New -command {
	if {$queryName == ""} {
	    showmesg "Please type in the name of the query to be created."
	} else {
	    set tgrps ""
	    destroy .lsch
		set query ""
	    qbrowse 
	}
    }
    button .lsch.bot.open -text Open -command {
	if {$queryName == ""} {
	    showmesg "Please choose a query by clicking on the entry."
	} else {
	    destroy .lsch
	    readQuery $queryName
	    qbrowse 
	}
    }
    button .lsch.bot.del -text Remove -command {
	if {$queryName == ""} {
	    showmesg "Please select the to remove by clicking on \
		    the entry."
	} else {
	    dialog .rem "Remove Query " \
		    "This will remove the query permanently. Proceed ? " \
		    "" 0 Yes No
	    if {$button == 0} {
		set idx [lsearch $Query($physchema,$logschema) $queryName]
		if {$idx == -1} {
		    dialog .note "Unknown Query" \
			    " The query does not exist. Cannot remove it." \
			    "" 0 OK
		    return
		}
		set Query($physchema,$logschema) [lreplace $Query($physchema,$logschema) $idx $idx]
		writeQuerycatalog
		# Remove the entry from the listbox 
		set len [.lsch.mid.list index end]
		set i 0
		while {[.lsch.mid.list get $i] != $queryName} {
		    incr i
		}
		.lsch.mid.list delete $i
		exec rm $schemadir/query/$queryName
		set queryName ""
	    }
	}
    }
    button .lsch.bot.quit -text Quit -command {
	destroy .lsch
    }
    pack .lsch.bot.new .lsch.bot.open .lsch.bot.del .lsch.bot.quit \
	    -side left -padx 3m -pady 1m -expand 1


    # Finally grab focus
    tkwait visibility .lsch
    grab set .lsch
    tkwait window .lsch
}
proc displayattrs {pname} {
    global attrlist

    # destroy .slist window if it already exists
    catch {destroy .slist}

    # Create a window with a listbox showing the names of all the attrs
    # in the physical schema pname
    
    toplevel .slist
    wm title .slist "Attributes in $pname"
    wm geometry .slist +100+100
    wm iconname .slist "$pname"

    frame .slist.top -relief raised
    frame .slist.bot -relief raised
    pack .slist.top .slist.bot -fill x -padx 1m -pady 1m

    # label + listbox +scroll
    label .slist.top.label -text "List of attributes"
    pack .slist.top.label -side top -fill x 
    listbox .slist.top.list -relief raised -bd 1 \
	    -yscrollcommand ".slist.top.scroll set" \
	    -font 9x15 -selectmode single
    scrollbar .slist.top.scroll -command ".slist.top.list yview"
    pack .slist.top.scroll -side right -fill y
    pack .slist.top.list -fill x

    # Populate the list
    readphysical $pname
    foreach attr $attrlist {
	.slist.top.list insert end [lindex $attr 4]
    }

    # OK button
    button .slist.bot.ok -text OK -command {
	destroy .slist
    }
    pack .slist.bot.ok

    tkwait window .slist
}


proc getLevel {gnm ngnm} {
    global glist

    foreach elem $glist($gnm) {
	set nm [lindex $elem 0]
	set ty [lindex $elem 1]
	if {$nm == $ngnm} {
	    return 1
	}

	if {$ty == "g"} {
	    set ret [getLevel $nm $ngnm]
	    if {$ret >= 1} {
		return [expr $ret+1]
	    }
	}
    }
    return 0
}
