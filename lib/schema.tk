#  ========================================================================
#  DEVise Data Visualization Software
#  (c) Copyright 1992-1995
#  By the DEVise Development Group
#  Madison, Wisconsin
#  All Rights Reserved.
#  ========================================================================
#
#  Under no circumstances is this software to be copied, distributed,
#  or altered in any way without prior permission from the DEVise
#  Development Group.

############################################################

#  $Id$

#  $Log$
#  Revision 1.7  1995/11/20 22:18:35  jussi
#  Changed from datadir to schemadir.
#
#  Revision 1.6  1995/11/19 06:03:24  ravim
#  Initial version of user/superuser modes and handling of logical/physical
#  schemas.
#
#  Revision 1.5  1995/11/01 01:37:55  ravim
#  Several minor changes.
#
#  Revision 1.4  1995/10/25 19:21:46  ravim
#  Added new types.
#
#  Revision 1.3  1995/10/17 05:16:32  ravim
#  Can define arbitrary group structures.
#
#  Revision 1.2  1995/10/11 17:08:10  ravim
#  Minor changes.
#
#  Revision 1.4  1995/10/11 17:02:38  ravim
#  Decoupled the main program. Uses datadir to display schema files.
#
#  Revision 1.3  1995/10/11 01:48:28  ravim
#  Added colors. Can modify attributes in place.
#
#  Revision 1.2  1995/10/04 20:48:33  ravim
#  Handled case when no schema file is selected.
#
# Revision 1.1  1995/10/03  03:40:53  ravim
# Initial revision
#

############################################################

set catalogFile $schemadir/schema/catalog.tcl
if {![file exists $catalogFile]} {
    puts "Cannot read catalog file for physical to logical associations"
    exit 1
}
source $catalogFile

#-----------------------------------------------------------
#		PROCEDURES
#-----------------------------------------------------------

# Schema browser for  a normal user - can manipulate only the logical schema
proc SchemaUser {} {
    global schemadir physchema
    # Show a list of currently defined physical schemas and buttons to either
    # create a Open one of these

    toplevel .psch -bg red4
    wm title .psch "Current Schemas"
    wm iconname .psch "Schemas"

    frame .psch.top -relief raised -bg honeydew2
    frame .psch.mid -relief raised -bg honeydew2
    frame .psch.bot -relief raised -bg honeydew2
    pack .psch.top .psch.mid .psch.bot -side top -fill x -padx 1m -pady 1m

    # Label on top
    label .psch.top.label -text "Schemas" -bg honeydew2 -fg red4
    pack .psch.top.label

    # Listbox with scrollbar in the middle
    listbox .psch.mid.list -relief raised -bd 1 \
	    -yscrollcommand ".psch.mid.scroll set" \
	    -font 9x15 -selectmode single -bg honeydew2
    scrollbar .psch.mid.scroll -command ".psch.mid.list yview" -bg honeydew2
    pack .psch.mid.scroll -side right -fill y
    pack .psch.mid.list -fill x

    # Search for files in the schema/physical directory to populate the list
    set flist [glob $schemadir/schema/physical/*]
    foreach fname $flist {
	.psch.mid.list insert end [file tail $fname]
    }    

    # Button to Open or Quit
    button .psch.bot.open -text Open -bg gray75 -fg IndianRed4 -command {
	set physchema [.psch.mid.list get active]
	if {$physchema == ""} {
	    showmesg "Please choose a schema by clicking on the entry"
	} else {
	    destroy .psch
	    displogical $physchema
	}
    }
    button .psch.bot.quit -text Quit -bg gray75 -fg IndianRed4 -command {
	destroy .psch
    }
    pack .psch.bot.open .psch.bot.quit -side left -padx 3m -pady 1m -expand 1

    # Finally grab focus
    tkwait visibility .psch
    grab set .psch
    tkwait window .psch
}

########################################################
# Schema browser for the superuser - can change both physical and logical parts
proc SchemaSuperuser {} {
    global schemadir
    # Show a list of currently defined schemas and buttons to either
    # create a New one or Open an existing one

    toplevel .psch -bg red4
    wm title .psch "Physical Schemas"
    wm iconname .psch "Schemas"

    frame .psch.top -relief raised -bg honeydew2
    frame .psch.mid -relief raised -bg honeydew2
    frame .psch.bot -relief raised -bg honeydew2
    pack .psch.top .psch.mid .psch.bot -side top -fill x -padx 1m -pady 1m

    # Label on top
    label .psch.top.label -text "Schemas" -bg honeydew2 -fg red4
    pack .psch.top.label

    # Listbox with scrollbar in the middle
    listbox .psch.mid.list -relief raised -bd 1 \
	    -yscrollcommand ".psch.mid.scroll set" \
	    -font 9x15 -selectmode single -bg honeydew2
    scrollbar .psch.mid.scroll -command ".psch.mid.list yview" -bg honeydew2
    pack .psch.mid.scroll -side right -fill y
    pack .psch.mid.list -fill x

    # Search for files in the schema/physical directory to populate the list
    set flist [glob $schemadir/schema/physical/*]
    foreach fname $flist {
	.psch.mid.list insert end [file tail $fname]
    }

    # Buttons at bottom
    button .psch.bot.new -text New -bg gray75 -fg IndianRed4 -command {
	destroy .psch
	newschema
    }
    button .psch.bot.open -text Open -bg gray75 -fg IndianRed4 -command {
	set sel [.psch.mid.list get active]
	if {$sel == ""} {
	    showmesg "Select the schema to edit by clicking once on the entry."
	} else {
	    destroy .psch
	    openschema $sel
	}
    }
    button .psch.bot.quit -text Quit -bg gray75 -fg IndianRed4 -command {
	destroy .psch
    }
    pack .psch.bot.new .psch.bot.open .psch.bot.quit -side left \
	    -padx 3m -pady 1m -expand 1

    # Finally grab focus
    tkwait visibility .psch
    grab set .psch
    tkwait window .psch
}

#############################################################
# This procedure creates a window depicting all the fields for the schema
# and their values if any.
proc newschemawin {} {
global sname ftype comm separ attrlist aname atype asort attrnum \
	tgrps glist Logical

# Count number of attributes
set attrnum 0

toplevel .newschema -bg red4
wm title .newschema "Schema Description"
wm iconname .newschema "Schema"

# Top level rows in the window
frame .newschema.firstrow -relief raised -bg honeydew2
frame .newschema.commseprow -relief raised  -bg honeydew2
frame .newschema.opt -relief raised  -bg honeydew2
frame .newschema.attr -relief raised -bg honeydew2
pack .newschema.firstrow  .newschema.commseprow .newschema.attr \
	.newschema.opt 	-side top -fill x -padx 1m -pady 1m

#-----------------------------------------------------------
# Within first row - name and type
frame .newschema.fname -relief raised -bd 1 -bg honeydew2
frame .newschema.ftype -relief raised -bd 1 -bg red4
pack .newschema.fname .newschema.ftype -in .newschema.firstrow \
	-side left -fill x -padx 3m -pady 1m

label .newschema.fname.label -text "Schema Name " -bg honeydew2 -fg red4
entry .newschema.fname.entry -width 25 -relief sunken -bd 2 \
	-textvariable sname -bg bisque
pack .newschema.fname.label .newschema.fname.entry -side left -padx 1m \
	-pady 1m

label .newschema.ftype.label -text "File Type"  -bg honeydew2 -fg red4
radiobutton .newschema.ftype.ascii -text Ascii -variable ftype \
	-value ascii -anchor nw -bg honeydew2
radiobutton .newschema.ftype.binary -text Binary -variable ftype \
	-value binary -anchor nw -bg honeydew2
pack .newschema.ftype.label .newschema.ftype.ascii .newschema.ftype.binary \
	-side top -fill x

#-----------------------------------------------------------
# Comment and separator characters
frame .newschema.comm -relief raised -bg honeydew2
frame .newschema.separ -relief raised -bg honeydew2
pack .newschema.comm -side left  -in .newschema.commseprow \
	-padx 3m -pady 1m 
pack .newschema.separ -side right  -in .newschema.commseprow \
	-padx 3m -pady 1m

label .newschema.comm.label -text "Comment characters"  -bg honeydew2 -fg red4
entry .newschema.comm.entry -width 5 -relief sunken -bd 2 \
	-textvariable comm -bg bisque
pack .newschema.comm.label .newschema.comm.entry -side left \
	-padx 1m -pady 1m

label .newschema.separ.label -text "Separator characters"  -bg honeydew2 -fg red4
entry .newschema.separ.entry -width 5 -relief sunken -bd 2 \
	-textvariable separ -bg bisque
pack .newschema.separ.label .newschema.separ.entry -side left \
	-padx 1m -pady 1m 

#-----------------------------------------------------------
# Attributes
frame .newschema.attrlist -relief raised  -bg honeydew2
frame .newschema.attradd -relief raised -bg honeydew2
pack .newschema.attrlist -in .newschema.attr \
	-side top -padx 3m -pady 1m -fill x
pack .newschema.attradd -in .newschema.attr \
	-side bottom -padx 3m -pady 1m -fill x

label .newschema.attrlist.label -text "List of Attributes" -bg honeydew2 -fg red4
label .newschema.attrlist.spec -text "Type      Order     Name" -bg honeydew2 -fg red4 -font 9x15
pack .newschema.attrlist.label -side top -fill x
pack .newschema.attrlist.spec -side top -anchor nw
listbox .newschema.attrlist.list -relief raised -bd 1 \
	-yscrollcommand ".newschema.attrlist.scroll set" \
	-xscrollcommand ".newschema.attrlist.xscroll set" \
	-font 9x15 -selectmode extended -bg honeydew2
scrollbar .newschema.attrlist.scroll \
	-command ".newschema.attrlist.list yview" -bg honeydew2
scrollbar .newschema.attrlist.xscroll -orient horizontal \
	-command ".newschema.attrlist.list xview" -bg honeydew2
pack .newschema.attrlist.scroll -side right -fill y
pack .newschema.attrlist.xscroll -side bottom -fill x
pack .newschema.attrlist.list -fill x 

# By default insert all elements of attrlist into the list
foreach attr $attrlist {
    # Format before inserting
    set ttype [lindex $attr 0]
    set tsort [lindex $attr 1]
    set tname [lindex $attr 2]
    set fstr [format "%-8s  %-8s  %s" $ttype $tsort $tname]
    .newschema.attrlist.list insert end $fstr
    set attrnum [expr $attrnum+1]
}

frame .newschema.attrspec -relief raised -bg honeydew2
frame .newschema.attrop -relief raised -bg honeydew2
pack .newschema.attrspec .newschema.attrop \
	-in .newschema.attradd -side top -fill x -padx 3m -pady 1m

frame .newschema.attrname -relief raised -bd 1 -bg honeydew2
frame .newschema.atype -relief raised -bd 1 -bg honeydew2
frame .newschema.asort -relief raised -bd 1 -bg honeydew2
pack .newschema.attrname .newschema.atype .newschema.asort \
	-in .newschema.attrspec -side top -fill x -padx 3m -pady 1m

label .newschema.attrname.label -text "Attribute Name " -bg honeydew2 -fg red4
entry .newschema.attrname.entry -width 25 -relief sunken -bd 2 \
	-textvariable aname -bg bisque
pack .newschema.attrname.label .newschema.attrname.entry -side left -padx 3m \
	-pady 1m


label .newschema.atype.label -text "Type   " -bg honeydew2 -fg red4
radiobutton .newschema.atype.double -text double -variable atype \
	-value "double" -anchor nw -bg honeydew2
radiobutton .newschema.atype.int -text int -variable atype \
	-value "int" -anchor nw -bg honeydew2
radiobutton .newschema.atype.string -text string -variable atype \
	-value "string" -anchor nw -bg honeydew2
radiobutton .newschema.atype.float -text float -variable atype \
	-value "float" -anchor nw -bg honeydew2
radiobutton .newschema.atype.date -text date -variable atype \
	-value "date" -anchor nw -bg honeydew2
pack .newschema.atype.label .newschema.atype.double .newschema.atype.int \
	.newschema.atype.string .newschema.atype.float \
	.newschema.atype.date  -side left -fill x -padx 1m 
label .newschema.asort.label -text "Sorted "  -bg honeydew2 -fg red4
radiobutton .newschema.asort.yes -text Yes -variable asort \
	-value "sorted" -anchor nw -bg honeydew2
radiobutton .newschema.asort.no -text No -variable asort \
	-value "unsorted" -anchor nw -bg honeydew2
pack .newschema.asort.label .newschema.asort.yes .newschema.asort.no \
	-side left -fill x -padx 1m

button .newschema.attrop.add -text "Add item" -bg gray75 -fg IndianRed4 -command {
    if {$aname == ""} {
	showmesg "Attribute name has not been specified. Cannot insert it \
		into the schema. "
    } else {
	# Increment count
	set attrnum [expr $attrnum+1]
	# Insert into list and clear selection
	set fstr [format "%-8s  %-8s  %s" $atype $asort $aname]
	.newschema.attrlist.list insert end $fstr
	set aname ""
	set atype "double"
	set asort "unsorted"
    }
}
button .newschema.attrop.delete -text "Delete item" -bg gray75 -fg IndianRed4\
	-command {
    .newschema.attrlist.list delete active
    # Decrement count
    set attrnum [expr $attrnum-1]
}
# Set up key binding for modify list
bind .newschema.attrlist.list <Double-1> {
    set attrl [.newschema.attrlist.list get active] 
    set atype [lindex $attrl 0]
    set asort [lindex $attrl 1] 
    set aname [lindex $attrl 2]
}
    
button .newschema.attrop.modify -text "Modify item" -bg gray75 -fg IndianRed4\
	-command {
    if {$aname == ""} {
	showmesg "Double click on an item to select it."
    } else {
	set fstr [format "%-8s  %-8s  %s" $atype $asort $aname]
	.newschema.attrlist.list insert active $fstr
	.newschema.attrlist.list delete active
	# Clear selection
	set aname ""
	set atype "double"
	set asort "unsorted"
    }
}
pack .newschema.attrop.add .newschema.attrop.delete \
	.newschema.attrop.modify -side left -padx 3m -pady 1m -expand 1

#-----------------------------------------------------------
# Bottom portion of window
button .newschema.opt.save -text Save -bg gray75 -fg IndianRed4 -command {
    if {$sname == ""} {
	showmesg "Schema name is not specified. Cannot save a schema \
		without a name."
    } else {
	# Print out everthing onto screen
#	puts "Schema Name : $sname "
#	puts "Type of file : $ftype"
#	puts "Comment chars : $comm "
#	puts "Separator chars : $separ"
#	puts "List of attrs"
	set attrlist {}
	while {$attrnum > 0} {
	    set attr [.newschema.attrlist.list get [expr $attrnum-1]]
#	    puts "Attr : $attr"
	    set attrnum [expr $attrnum-1]

	    # Append to attrlist
	    set attrlist [linsert $attrlist 0 $attr]
	}

	# Write into a file 
	writephysical $sname $ftype $comm $separ $attrlist
	# Update catalog with this new physical schema (if new).
	if {[info exists Logical($sname)] == 0} {
	    set Logical($sname) ""
	    writecatalog
	}
	destroy .newschema
    }
}
button .newschema.opt.quit -text Cancel -bg gray75 -fg IndianRed4 -command { 
    destroy .newschema }
pack .newschema.opt.save .newschema.opt.quit  -side left \
	-padx 3m -pady 1m -expand 1

#-----------------------------------------------------------
# Finally grab focus
tkwait visibility .newschema
grab set .newschema
tkwait window .newschema
}

#-----------------------------------------------------------
proc newschema {} {
    global sname ftype comm separ attrlist aname atype asort tgrps
    # First set up some global variables
    set sname ""
    set ftype ascii
    set comm "//"
    set separ " "
    set attrlist ""
    set aname ""
    set atype "double"
    set asort "unsorted"
    set tgrps ""

    # Call function to display the window
    newschemawin
}

#-----------------------------------------------------------
proc openschema {filename} {
    global sname ftype comm separ attrlist aname atype asort fsBox schemadir \
	    tgrps

    # Set some defaults
    set sname ""
    set ftype ascii
    set comm "//"
    set separ " "
    set attrlist ""
    set aname ""
    set atype double
    set asort unsorted
    set tgrps ""

    # Read the file and get the contents
    readphysical $filename

    # Call function to display the schema
    newschemawin
}


#-----------------------------------------------------------
# General function to display a message
proc showmesg {str} {
    toplevel .msg -bg red4
    wm title .msg Message
    wm iconname .msg Message
    
    frame .msg.str -relief raised -bd 1 -bg red4
    frame .msg.ok -relief raised -bg red4
    pack .msg.str .msg.ok -side top -fill x -padx 3m -pady 3m

    message .msg.str.msg -width 3i -text $str -bg red4 -fg white
    pack .msg.str.msg -side right -expand 1 -fill both -padx 3m -pady 3m

    button .msg.ok.but -text OK -bg white -fg red4 \
	    -command {destroy .msg}
    pack .msg.ok.but -side top -expand 1 -padx 3m -pady 1m

    tkwait visibility .msg
    grab set .msg
    tkwait window .msg
}

################################################################
proc writelogical {name} {
    global tgrps schemadir physchema

    set f [open $schemadir/schema/logical/$name w]
    
    # First output the physical schema name
    puts $f "physical $physchema"

    foreach nm $tgrps {
	goutput $f $nm
    }
    close $f
}

proc writephysical {name type comm sep alist} {
    global schemadir

    set f [open $schemadir/schema/physical/$name w]

    puts $f "type $name $type" 
    puts $f "comment $comm"
    puts $f "separator '$sep'"
    
    foreach attr $alist {
	set atype [lindex $attr 0]
	set asort [lindex $attr 1]
	set aname [lindex $attr 2]
	
	if {$asort != "unsorted"} {
	    puts -nonewline $f "sorted "
	}
	puts $f "attr $aname $atype"
    }
    close $f
}

##################################################################
proc readlogical {filename} {
    global tgrps schemadir

    # Open file for reading
    set f [open $schemadir/schema/logical/$filename r]

    # First line specifies the physical schema
    set line [gets $f]

    # Group declarations
    set len [gets $f line]
    while {$len != -1} {
	set nm [lindex $line 1]
	set tgrps [lappend tgrps $nm]
	ginput $f $nm
	set len [gets $f line]
    }
    # Close file
    close $f
}

proc readphysical {filename} {
    global sname ftype comm separ attrlist schemadir
    set attrlist ""

    # Open file for reading
    set f [open $schemadir/schema/physical/$filename r]

    # First line is the schema name and type
    set line [gets $f]
    scan $line "type %s %s" sname ftype

    # Second line is comment
    set line [gets $f]
    scan $line "comment %s" comm

    # Third line is separator
    set line [gets $f]
    # everything between the 's is the separator
    set lstart [string first "'" $line]
    set lend [string last "'" $line]
    set lstart [expr $lstart+1]
    set lend [expr $lend-1]
    set separ [string range $line $lstart $lend]

    # Following are all attr declarations
    set len [gets $f line]
    set num 0
    while {$len != -1} {
	set first [lindex $line 0]
	if {$first != "sorted"} {
	    scan $line "attr %s %s" attrname attrtype
	    set attr [list $attrtype unsorted $attrname] 
	} else {
	    scan $line "sorted attr %s %s" attrname attrtype
	    set attr [list $attrtype sorted $attrname]
	}

#	puts "Inserting .. $attr"
	set attrlist [linsert $attrlist $num $attr]
	set len [gets $f line]
	set num [expr $num+1]
    }
    # Close file
    close $f
}
###################################################################

proc gbrowse {} {
    global tgrps glist resgrp logschema physchema Logical

    toplevel .gbrowse -bg red4
    wm title .gbrowse "Group Browser"
    wm iconname .gbrowse "Groups"

    # Toplevel rows
    frame .gbrowse.list -relief raised -bg honeydew2 
    frame .gbrowse.ops -relief raised -bg honeydew2 
    pack .gbrowse.list .gbrowse.ops -side top -fill x -padx 3m -pady 1m

    #-----------------------------------------------------------
    # Create a listbox displaying list of groups
    #    CreateTextBitmap .gbrowse.list.label group.gif Groups
    label .gbrowse.list.label -text "List of Groups" -bg honeydew2 -fg red4
    pack .gbrowse.list.label -side top -fill x

    listbox .gbrowse.list.list -relief raised -bd 1 \
	    -yscrollcommand ".gbrowse.list.scroll set" \
	    -font 9x15 -selectmode extended  -bg honeydew2
    scrollbar .gbrowse.list.scroll \
	    -command ".gbrowse.list.list yview" -bg honeydew2
    pack .gbrowse.list.scroll  -side right -fill y
    pack .gbrowse.list.list  -fill x 


    # Insert all existing top level groups into the listbox
    foreach nm $tgrps {
	.gbrowse.list.list insert end $nm
    }

    # Set up binding
    bind .gbrowse.list.list <Double-1> {
	set gname [.gbrowse.list.list get active]
    }


    # Panel for group name and panels for create, delete and modify
    frame .gbrowse.ops.name -relief raised -bg honeydew2 -bd 1
    frame .gbrowse.ops.op -relief raised -bg honeydew2 
    pack .gbrowse.ops.name .gbrowse.ops.op -side top -fill x \
	    -padx 3m -pady 1m

    label .gbrowse.ops.name.label -text "Group Name " -bg honeydew2 -fg red4
    entry .gbrowse.ops.name.entry -width 15 -relief sunken -bd 2 \
	    -textvariable gname -bg bisque
    pack .gbrowse.ops.name.label .gbrowse.ops.name.entry -side left \
	    -fill x -padx 1m -pady 1m -expand 1

    button .gbrowse.ops.op.create -text "Create" \
	    -bg gray75 -fg IndianRed4 	-command {
	if {$gname == ""} {
	    showmesg "Please specify the name of the group"
	} elseif {[info exists glist($gname)] == 1} {
	    showmesg "Group with this name already exists."
	    set gname ""
	} else {
	    set glist($gname) ""
	    set resgrp ""
	    dispgrp $gname
	    if {$resgrp != ""} {
		set tgrps [lappend tgrps $resgrp]
		.gbrowse.list.list insert end $resgrp
	    } 
	    set gname ""
	}
    }
    button .gbrowse.ops.op.delete -text "Delete" \
	    -bg gray75 -fg IndianRed4	-command {
	if {$gname == ""} {
	    showmesg "Please specify the name of the group"
	} else {
	    # Search through tgrps and delete gname 
	    set idx [lsearch $tgrps $gname]
	    if {$idx == -1} {
		showmesg "Group with this name does not exist."
	    } else {
		set tgrps [lreplace $tgrps $idx $idx]
		delgrp $gname
		# Remove entry from the list box
		set i 0
		while {[.gbrowse.list.list get $i] != $gname} {
		    set i [expr $i+1]
		}
		.gbrowse.list.list delete $i
	    }
	    set gname ""
	}
    }
    button .gbrowse.ops.op.modify -text "Modify" \
	    -bg gray75 -fg IndianRed4	-command {
	if {$gname == ""} {
	    showmesg "Please specify the name of the group"
	} elseif {[lsearch $tgrps $gname] == -1} {
	    showmesg "Group with this name does not exist."
	} else {
	    dispgrp $gname
	    set gname ""
	}
    }
    button .gbrowse.ops.op.quit -text "Quit" \
	    -bg gray75 -fg IndianRed4	-command {
#	printgrps 
	writelogical $logschema
	# Update catalog if needed
	if {[lsearch $Logical($physchema) $logschema] == -1} {
	    set Logical($physchema) [lappend Logical($physchema) $logschema]
	    writecatalog
	}
	set logschema ""
	set physchema ""
	set tgrps ""
	destroy .gbrowse
    }
    pack .gbrowse.ops.op.create .gbrowse.ops.op.delete \
	    .gbrowse.ops.op.modify .gbrowse.ops.op.quit \
	    -side left -padx 3m -pady 1m -expand 1

    #-----------------------------------------------------------
    # Finally grab focus
    tkwait visibility .gbrowse
    grab set .gbrowse
    tkwait window .gbrowse
}

proc dispgrp {gname } {
    global glist resgrp tgrps currgrp cnt
    # Displays the group information and allows modification

    set currgrp $gname 

    toplevel .grp -bg red4
    wm title .grp Group 
    wm iconname .grp Group

    frame .grp.list -relief raised -bg honeydew2
    frame .grp.ops -relief raised -bg honeydew2
    frame .grp.bot -relief raised -bg honeydew2
    pack .grp.list .grp.ops .grp.bot -side top -fill x -padx 3m -pady 1m

    # List showing current group structure
    label .grp.list.label -text "Display for Group : $gname" -bg honeydew2 -fg Red4
    pack .grp.list.label -side top -fill x

    listbox .grp.list.list -relief raised -bd 1 \
	    -yscrollcommand ".grp.list.scroll set" \
	    -font 9x15 -selectmode extended  -bg honeydew2
    scrollbar .grp.list.scroll \
	    -command ".grp.list.list yview" -bg honeydew2
    pack .grp.list.scroll  -side right -fill y
    pack .grp.list.list  -fill x 


    # Insert all the existing members of the group into the list
    glinsert $gname

    # Frame containing item and nested grp info
    frame .grp.curr -relief raised -bg honeydew2 
    pack .grp.curr -in .grp.ops -side top -fill x -padx 2m -pady 1m
    label .grp.curr.label -text "Current group " -bg honeydew2 -fg Red4
    entry .grp.curr.entry -width 25 -relief sunken -bd 2 \
	    -textvariable currgrp -bg bisque
    pack .grp.curr.label .grp.curr.entry -side left -padx 2m -expand 1

    frame .grp.item -relief raised -bg honeydew2 -bd 1
    frame .grp.ngrp -relief raised -bg honeydew2 -bd 1 
    pack .grp.item .grp.ngrp -in .grp.ops -side left -padx 2m -pady 1m \
	    -expand 1

    frame .grp.item.top -relief raised -bg honeydew2
    frame .grp.item.mid -relief raised -bg honeydew2
    frame .grp.item.bot -relief raised -bg honeydew2
    pack .grp.item.top .grp.item.mid .grp.item.bot -side top -fill x \
	    -padx 1m -pady 1m

    label .grp.item.top.label -text "Item" -bg honeydew2 -fg Red4
    pack .grp.item.top.label 
    
    label .grp.item.mid.label -text "Name " -bg honeydew2 -fg Red4
    entry .grp.item.mid.entry -width 25 -relief sunken -bd 2 \
	    -textvariable iname -bg bisque
    pack .grp.item.mid.label .grp.item.mid.entry -side left -fill x \
	    -padx 3m -pady 1m

    button .grp.item.bot.add -text "Insert" \
	    -bg gray75 -fg IndianRed4 -command {
	if {$iname == ""} {
	    showmesg "Please specify the name of the item."
	} elseif {$currgrp == ""} {
	    showmesg "Specify the current group into which the item would \
		    be inserted."
	} elseif {[info exists glist($currgrp)] == 0} {
		showmesg "Current group $currgrp is invalid."
	} else {
	    set elem [list $iname i]
	    set glist($currgrp) [lappend glist($currgrp) $elem]
	    # Now insert in the listbox
	    set cnt -1
	    endpos $gname $currgrp 
	    # Actual position got by decrementing
	    set cnt [expr $cnt-1]
	    .grp.list.list insert $cnt $iname
	    set iname ""
	}
    }

    button .grp.item.bot.del -text "Delete" \
	    -bg gray75 -fg IndianRed4 -command {
	if {$iname == ""} {
	    showmesg "Please specify the name of the item."
	} else {
	    set gr $gname
	    set nm [gsearch $gname $iname]
	    if {$nm == ""} {
		showmesg "Item <$iname> does not exist."
	    } else {
		set elem [list $iname i]
		set idx [lsearch $glist($nm) $elem]
		set glist($nm) [lreplace $glist($nm) $idx $idx]
		#  Also remove from the listbox
		set idx 0
		set elem [.grp.list.list get $idx]
		while {$elem != $iname} {
		    set idx [expr $idx+1]
		    set elem [.grp.list.list get $idx]
		}
		.grp.list.list delete $idx
	    }
	    set iname ""
	}
    }
    pack .grp.item.bot.add  \
	    .grp.item.bot.del -side left -expand 1 -padx 3m -pady 1m

    frame .grp.ngrp.top -relief raised -bg honeydew2
    frame .grp.ngrp.mid -relief raised -bg honeydew2
    frame .grp.ngrp.bot -relief raised -bg honeydew2
    pack .grp.ngrp.top .grp.ngrp.mid .grp.ngrp.bot -side top -fill x \
	    -padx 1m -pady 1m

    label .grp.ngrp.top.label -text "Sub Group" -bg honeydew2 -fg Red4
    pack .grp.ngrp.top.label 
    
    label .grp.ngrp.mid.label -text "Name " -bg honeydew2 -fg Red4
    entry .grp.ngrp.mid.entry -width 25 -relief sunken -bd 2 \
	    -textvariable ngname -bg bisque
    pack .grp.ngrp.mid.label .grp.ngrp.mid.entry -side left -fill x \
	    -padx 3m -pady 1m

    button .grp.ngrp.bot.add -text "Create" \
	    -bg gray75 -fg IndianRed4 -command {
	if {$ngname == ""} {
	    showmesg "Please specify the name of the sub group."
	} elseif {[info exists glist($currgrp)] == 0} {
	    showmesg "Current group $currgrp is not valid."
	} else {
	    set elem [list $ngname g]
	    set glist($currgrp) [lappend glist($currgrp) $elem]
	    set glist($ngname) ""
	    set cnt -1
	    endpos $gname $currgrp
	    # Actual position by subtracting 2
	    set cnt [expr $cnt-2]
	    .grp.list.list insert $cnt "end group $ngname"
	    .grp.list.list insert $cnt "begin group $ngname"
	    set nlist [lappend nlist $currgrp]
	    set currgrp $ngname
	    set ngname ""
	}
    }
    button .grp.ngrp.bot.del -text "Delete" \
	    -bg gray75 -fg IndianRed4 -command {
	if {$ngname == ""} {
	    showmesg "Please specify the name of the sub group."
	} else {
	    set outer [gsearch $gname $ngname]
	    if {$outer == ""} {
		showmesg "Subgroup $ngname is invalid."
	    } else {
		set elem [list $ngname g]
		set idx [lsearch $glist($outer) $elem]
		set glist($outer) [lreplace $glist($outer) $idx $idx]
		delgrp $ngname
		# Now remove from the listbox
		set idx 0
		set elem [.grp.list.list get $idx]
		set start "begin group $ngname"
		while {$elem != $start} {
		    set idx [expr $idx+1]
		    set elem [.grp.list.list get $idx]
		}
		set dest "end group $ngname"
		while {$elem != $dest} {
		    .grp.list.list delete $idx
		    set elem [.grp.list.list get $idx]
		}
		.grp.list.list delete $idx
		set ngname ""
	    }
	}
    }
    pack .grp.ngrp.bot.add .grp.ngrp.bot.del \
	    -side left -expand 1 -padx 3m -pady 1m

    # Bind the double-click on the listbox
    bind .grp.list.list <Double-1> {
	set selec [.grp.list.list get active]
	set first [lindex $selec 0]
	if {$first == "begin"} {
	    set ngname [lindex $selec 2]
	} elseif {$first == "end"} {
	    set ngname [lindex $selec 2]
	} else {
	    set iname $first
	}
    }
	
    # Frame containing save and cancel buttons
    button .grp.bot.save -text "Save" \
	    -bg gray75 -fg IndianRed4 -command {
	destroy .grp
	# Finally return the group name
	set resgrp $gname
	# reset nlist
	set nlist ""
	set ngname ""
	set iname ""
    }
    button .grp.bot.cancel -text "Cancel" \
	    -bg gray75 -fg IndianRed4 -command {
	destroy .grp
	# Return empty string
	set resgrp ""
	set ngname ""
	set iname ""
    }
    pack .grp.bot.save .grp.bot.cancel -side left -expand 1 \
	    -padx 3m -pady 1m    

    # Finally grab focus
    tkwait visibility .grp
    grab set .grp
    tkwait window .grp
}


proc printgrps {} {
    global tgrps
    # Loop through all the top level groups 
    foreach top $tgrps {
	puts "Top level group-----------$top"
	printgrp $top
    }
}

proc printgrp {name} {
    global glist

    puts "Group $name"
    foreach elem $glist($name) {
	set nm [lindex $elem 0]
	set ty [lindex $elem 1]
	if {$ty == "i"} {
	    puts "Item $nm"
	} else {
	    printgrp $nm
	}
    }

    puts "End of group $name"
}

proc glinsert {name} {
    global glist 
    # inserts members of the group into a listbox
    
    foreach elem $glist($name) {
	set nm [lindex $elem 0]
	set ty [lindex $elem 1]
	if {$ty == "i"} {
	    .grp.list.list insert end $nm
	} else {
	    .grp.list.list insert end "begin group $nm"
	    glinsert $nm
	    .grp.list.list insert end "end group $nm"
	}
    }
}

proc goutput {f name} {
    global glist

    # output the group structure for nm to file f

    puts $f "group $name"
    foreach elem $glist($name) {
	set nm [lindex $elem 0]
	set ty [lindex $elem 1]
	if {$ty == "i"} {
	    puts $f "item $nm"
	} else {
	    goutput $f $nm
	}
    }

    puts $f "endgroup"
}

proc ginput {f name} {
    global glist

    set glist($name) ""
    # input  the group structure for nm from file f
    set len [gets $f line]

    while {$line != "endgroup"} {
	set ty [lindex $line 0]
	set nm [lindex $line 1]
	if {$ty == "item"} {
	    set elem [list $nm i]
	    set glist($name) [lappend glist($name) $elem]
	} else {
	    set elem [list $nm g]
	    set glist($name) [lappend glist($name) $elem]
	    ginput $f $nm
	}
	set len [gets $f line]
    }
}

proc delgrp {name} {
    global glist

    # delete all the members of the group
    
    foreach elem $glist($name) {
	set nm [lindex $elem 0]
	set ty [lindex $elem 1]
	if {$ty == "g"} {
	    delgrp $nm
	}
    }
    unset glist($name)
}


proc gsearch {gnm inm} {
    global glist

    # Searches for the item "inm" in the group "gnm". It recursively
    # traverses the nested sub groups and returns the name of the 
    # immediate outer group in which the item is found.
    # Returns null string if the item is not found

    foreach elem $glist($gnm) {
	set nm [lindex $elem 0]
	if {$nm == $inm} {
	    return $gnm
	}
	set ty [lindex $elem 1]
	if {$ty == "g"} {
	    set ret [gsearch $nm $inm]
	    if {$ret != ""} {
		return $ret
	    }
	}
    }

    return ""
}

proc endpos {gnm ngnm} {
    global glist cnt

    # This function returns the "flattened" position of the item "inm"
    # within the group "gnm". This would be the line number of this
    # item within the listbox displaying the group
    # Returns 0 if the item was not found, 1 if found

    foreach elem $glist($gnm) {
	set cnt [expr $cnt+1]
	set nm [lindex $elem 0]
	set ty [lindex $elem 1]
	if {$ty == "g"} {
	    set ret [endpos $nm $ngnm]
	    if {$ret == 1} {
		return 1
	    }
	}

	if {$nm == $ngnm} {
	    return 1
	}

    }
    set cnt [expr $cnt+1]
    return 0
}

proc begpos {gnm ngnm} {
    global glist cnt

    # This function returns the "flattened" position of the item "inm"
    # within the group "gnm". This would be the line number of this
    # item within the listbox displaying the group
    # Returns 0 if the item was not found, 1 if found

    foreach elem $glist($gnm) {
	set cnt [expr $cnt+1]
	set nm [lindex $elem 0]
	set ty [lindex $elem 1]
	if {$nm == $ngnm} {
	    return 1
	}
	if {$ty == "g"} {
	    set ret [endpos $nm $ngnm]
	    if {$ret == 1} {
		return 1
	    }
	}

    }
    set cnt [expr $cnt+1]
    return 0
}

#########################################################################
proc writecatalog {} {
    global Logical schemadir

    set f [open $schemadir/schema/catalog.tcl w]
    puts $f "# Association between physical and logical schemas"
    puts $f ""

    foreach itm [lsort [array names Logical]] {
	puts $f "set \"Logical($itm)\" \{$Logical($itm)\}"
    }
    close $f
}

##########################################################################

proc displogical {pname} {
    global schemadir tgrps logschema Logical
    
    # Display the logical schema corr. to the passed physical schema
    toplevel .lsch -bg red4
    wm title .lsch "Current Views"
    wm iconname .lsch "Schemas"

    frame .lsch.top -relief raised -bg honeydew2
    frame .lsch.mid -relief raised -bg honeydew2
    frame .lsch.bot -relief raised -bg honeydew2
    frame .lsch.ent -relief raised -bg honeydew2
    pack .lsch.top .lsch.mid .lsch.ent .lsch.bot \
	    -side top -fill x -padx 1m -pady 1m

    # Entry for schema name
    label .lsch.ent.label -text "Schema name : " -bg honeydew2 -fg red4
    entry .lsch.ent.entry -width 25 -relief sunken -bd 2 \
	    -textvariable logschema -bg bisque
    pack .lsch.ent.label .lsch.ent.entry -side left -padx 1m 

    # Label on top
    label .lsch.top.label -text "$pname   Schemas" -bg honeydew2 -fg red4
    pack .lsch.top.label

    # Listbox with scrollbar in the middle
    listbox .lsch.mid.list -relief raised -bd 1 \
	    -yscrollcommand ".lsch.mid.scroll set" \
	    -font 9x15 -selectmode single -bg honeydew2
    scrollbar .lsch.mid.scroll -command ".lsch.mid.list yview" -bg honeydew2
    pack .lsch.mid.scroll -side right -fill y
    pack .lsch.mid.list -fill x

    # bind double-click on the listbox
    bind .lsch.mid.list <Double-1> {
	set logschema [.lsch.mid.list get active]
    }

    # Populate the listbox based on the Logical array values
    if {[info exists Logical($pname)] == 0} {
	set Logical($pname) ""
    }
    foreach itm $Logical($pname) {
	.lsch.mid.list insert end $itm
    }

    # Button to create a New one, Open or Quit
    button .lsch.bot.new -text New -bg gray75 -fg IndianRed4 -command {
	if {$logschema == ""} {
	    showmesg "Please type in the name of the schema to be created"
	} else {
	    set tgrps ""
	    destroy .lsch
	    gbrowse
	}
    }
    button .lsch.bot.open -text Open -bg gray75 -fg IndianRed4 -command {
	if {$logschema == ""} {
	    showmesg "Please choose a schema by clicking on the entry"
	} else {
	    destroy .lsch
	    readlogical $logschema
	    gbrowse
	}
    }
    button .lsch.bot.quit -text Quit -bg gray75 -fg IndianRed4 -command {
	destroy .lsch
    }
    pack .lsch.bot.new .lsch.bot.open .lsch.bot.quit \
	    -side left -padx 3m -pady 1m -expand 1

    # Finally grab focus
    tkwait visibility .lsch
    grab set .lsch
    tkwait window .lsch
}
