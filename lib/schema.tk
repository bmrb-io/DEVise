#  ========================================================================
#  DEVise Data Visualization Software
#  (c) Copyright 1992-1995
#  By the DEVise Development Group
#  Madison, Wisconsin
#  All Rights Reserved.
#  ========================================================================
#
#  Under no circumstances is this software to be copied, distributed,
#  or altered in any way without prior permission from the DEVise
#  Development Group.

############################################################

#  $Id$

#  $Log$
#  Revision 1.2  1995/10/11 17:08:10  ravim
#  Minor changes.
#
#  Revision 1.4  1995/10/11 17:02:38  ravim
#  Decoupled the main program. Uses datadir to display schema files.
#
#  Revision 1.3  1995/10/11 01:48:28  ravim
#  Added colors. Can modify attributes in place.
#
#  Revision 1.2  1995/10/04 20:48:33  ravim
#  Handled case when no schema file is selected.
#
# Revision 1.1  1995/10/03  03:40:53  ravim
# Initial revision
#

############################################################

#-----------------------------------------------------------
#		PROCEDURES
#-----------------------------------------------------------

# This procedure creates a window depicting all the fields for the schema
# and their values if any.
proc newschemawin {} {
global sname ftype comm separ attrlist aname atype asort attrnum \
	tgrps glist

# Count number of attributes
set attrnum 0

toplevel .newschema -bg DarkRed
wm title .newschema "Schema Description"
wm iconname .newschema "Schema"

# Top level rows in the window
frame .newschema.firstrow -relief raised -bg honeydew2
frame .newschema.commseprow -relief raised  -bg honeydew2
frame .newschema.opt -relief raised  -bg honeydew2
frame .newschema.attr -relief raised -bg honeydew2
pack .newschema.firstrow .newschema.attr  .newschema.commseprow\
	.newschema.opt 	-side top -fill x -padx 1m -pady 1m

#-----------------------------------------------------------
# Within first row - name and type
frame .newschema.fname -relief raised -bd 1 -bg honeydew2
frame .newschema.ftype -relief raised -bd 1 -bg DarkRed
pack .newschema.fname .newschema.ftype -in .newschema.firstrow \
	-side left -fill x -padx 3m -pady 1m

label .newschema.fname.label -text "Schema Name " -bg honeydew2 -fg red
entry .newschema.fname.entry -width 25 -relief sunken -bd 2 \
	-textvariable sname -bg bisque
pack .newschema.fname.label .newschema.fname.entry -side left -padx 1m \
	-pady 1m

label .newschema.ftype.label -text "File Type"  -bg honeydew2 -fg red
radiobutton .newschema.ftype.ascii -text Ascii -variable ftype \
	-value ascii -anchor nw -bg honeydew2
radiobutton .newschema.ftype.binary -text Binary -variable ftype \
	-value binary -anchor nw -bg honeydew2
pack .newschema.ftype.label .newschema.ftype.ascii .newschema.ftype.binary \
	-side top -fill x

#-----------------------------------------------------------
# Comment and separator characters
frame .newschema.comm -relief raised -bg honeydew2
frame .newschema.separ -relief raised -bg honeydew2
pack .newschema.comm -side left  -in .newschema.commseprow \
	-padx 3m -pady 1m 
pack .newschema.separ -side right  -in .newschema.commseprow \
	-padx 3m -pady 1m

label .newschema.comm.label -text "Comment characters"  -bg honeydew2 -fg red
entry .newschema.comm.entry -width 5 -relief sunken -bd 2 \
	-textvariable comm -bg bisque
pack .newschema.comm.label .newschema.comm.entry -side left \
	-padx 1m -pady 1m

label .newschema.separ.label -text "Separator characters"  -bg honeydew2 -fg red
entry .newschema.separ.entry -width 5 -relief sunken -bd 2 \
	-textvariable separ -bg bisque
pack .newschema.separ.label .newschema.separ.entry -side left \
	-padx 1m -pady 1m 

#-----------------------------------------------------------
# Attributes
frame .newschema.attrlist -relief raised  -bg honeydew2
frame .newschema.attradd -relief raised -bg honeydew2
pack .newschema.attrlist -in .newschema.attr \
	-side top -padx 3m -pady 1m -fill x
pack .newschema.attradd -in .newschema.attr \
	-side bottom -padx 3m -pady 1m -fill x

label .newschema.attrlist.label -text "List of Attributes" -bg honeydew2 -fg red
pack .newschema.attrlist.label -side top -fill x
listbox .newschema.attrlist.list -relief raised -bd 1 \
	-yscrollcommand ".newschema.attrlist.scroll set" \
	-font 9x15 -selectmode extended -bg honeydew2
scrollbar .newschema.attrlist.scroll \
	-command ".newschema.attrlist.list yview" -bg honeydew2
pack .newschema.attrlist.scroll -side right -fill y
pack .newschema.attrlist.list -fill x

# By default insert all elements of attrlist into the list
foreach attr $attrlist {
    # Format before inserting
    set tname [lindex $attr 0]
    set ttype [lindex $attr 1]
    set tsort [lindex $attr 2]
    set fstr [format "%-15s  %-8s  %s" $tname $ttype $tsort]
    .newschema.attrlist.list insert end $fstr
    set attrnum [expr $attrnum+1]
}

frame .newschema.attrspec -relief raised -bg honeydew2
frame .newschema.attrop -relief raised -bg honeydew2
pack .newschema.attrspec .newschema.attrop \
	-in .newschema.attradd -side left -fill y -expand 1 -padx 3m -pady 1m
frame .newschema.attrname -relief raised -bd 1 -bg honeydew2
frame .newschema.attrtype -relief raised  -bg honeydew2
pack .newschema.attrname .newschema.attrtype \
	-in .newschema.attrspec -side top -fill x -padx 3m -pady 1m

label .newschema.attrname.label -text "Attribute Name " -bg honeydew2 -fg red
entry .newschema.attrname.entry -width 15 -relief sunken -bd 2 \
	-textvariable aname -bg bisque
pack .newschema.attrname.label .newschema.attrname.entry -side left -padx 1m \
	-pady 1m

frame .newschema.atype -relief raised -bd 1 -bg DarkRed
frame .newschema.asort -relief raised -bd 1 -bg DarkRed
pack .newschema.atype -in .newschema.attrtype \
	-side left -padx 3m 
pack .newschema.asort -in .newschema.attrtype \
	-side left -padx 3m 

label .newschema.atype.label -text "Type" -bg honeydew2 -fg red
radiobutton .newschema.atype.double -text double -variable atype \
	-value "double" -anchor nw -bg honeydew2
radiobutton .newschema.atype.integer -text integer -variable atype \
	-value "integer" -anchor nw -bg honeydew2
radiobutton .newschema.atype.string -text string -variable atype \
	-value "string" -anchor nw -bg honeydew2
pack .newschema.atype.label .newschema.atype.double .newschema.atype.integer \
	.newschema.atype.string -side top -fill x
label .newschema.asort.label -text "Sorted"  -bg honeydew2 -fg red
radiobutton .newschema.asort.yes -text Yes -variable asort \
	-value "sorted" -anchor nw -bg honeydew2
radiobutton .newschema.asort.no -text No -variable asort \
	-value "unsorted" -anchor nw -bg honeydew2
pack .newschema.asort.label .newschema.asort.yes .newschema.asort.no \
	-side top -fill x

button .newschema.attrop.add -text "Add item" -bg gray75 -fg IndianRed4 -command {
    if {$aname == ""} {
	showmesg "Attribute name has not been specified. Cannot insert it \
		into the schema. "
    } else {
	# Increment count
	set attrnum [expr $attrnum+1]
	# Insert into list and clear selection
	set fstr [format "%-15s %-8s %s" $aname $atype $asort]
	.newschema.attrlist.list insert end $fstr
	set aname ""
	set atype "double"
	set asort "unsorted"
    }
}
button .newschema.attrop.delete -text "Delete item" -bg gray75 -fg IndianRed4\
	-command {
    .newschema.attrlist.list delete active
    # Decrement count
    set attrnum [expr $attrnum-1]
}
# Set up key binding for modify list
bind .newschema.attrlist.list <Double-Button-1> {
    set attrl [.newschema.attrlist.list get active]
    set aname [lindex $attrl 0]
    set atype [lindex $attrl 1]
    set asort [lindex $attrl 2]
}
    
button .newschema.attrop.modify -text "Modify item" -bg gray75 -fg IndianRed4\
	-command {
    set fstr [format "%-15s  %-8s  %s" $aname $atype $asort]
    .newschema.attrlist.list insert active $fstr
    .newschema.attrlist.list delete active
    # Clear selection
    set aname ""
    set atype "double"
    set asort "unsorted"
}
pack .newschema.attrop.add .newschema.attrop.delete \
	.newschema.attrop.modify -side top -padx 3m -pady 1m -expand 1

#-----------------------------------------------------------
# Bottom portion of window
button .newschema.opt.grp -text "Browse Groups" \
	-bg gray75 -fg IndianRed4 -command gbrowse
button .newschema.opt.save -text Save -bg gray75 -fg IndianRed4 -command {
    if {$sname == ""} {
	showmesg "Schema name is not specified. Cannot save a schema \
		without a name."
    } else {
	# Print out everthing onto screen
	puts "Schema Name : $sname "
	puts "Type of file : $ftype"
	puts "Comment chars : $comm "
	puts "Separator chars : $separ"
	puts "List of attrs"
	set attrlist {}
	while {$attrnum > 0} {
	    set attr [.newschema.attrlist.list get [expr $attrnum-1]]
	    puts "Attr : $attr"
	    set attrnum [expr $attrnum-1]

	    # Append to attrlist
	    set attrlist [linsert $attrlist 0 $attr]
	}

	# Write into a file 
	writefile $sname $ftype $comm $separ $attrlist
	destroy .newschema
    }
}
button .newschema.opt.quit -text Cancel -bg gray75 -fg IndianRed4 -command { 
    destroy .newschema }
pack .newschema.opt.grp .newschema.opt.save .newschema.opt.quit  -side left \
	-padx 3m -pady 1m -expand 1

#-----------------------------------------------------------
# Finally grab focus
tkwait visibility .newschema
grab set .newschema
tkwait window .newschema
}

#-----------------------------------------------------------
proc newschema {} {
    global sname ftype comm separ attrlist aname atype asort tgrps
    # First set up some global variables
    set sname ""
    set ftype ascii
    set comm "//"
    set separ " "
    set attrlist ""
    set aname ""
    set atype "double"
    set asort "unsorted"
    set tgrps ""

    # Call function to display the window
    newschemawin
}

#-----------------------------------------------------------
proc openschema {} {
    global sname ftype comm separ attrlist aname atype asort fsBox datadir \
	    tgrps

    # Display a file selection box and get the file name
    set fsBox(path) $datadir
    set fsBox(pattern) *.schema*
    set filename [FSBox "Select schema file"]
    # If no file selected, return
    if {$filename == ""} {
	return 
    }
    puts " File : $filename"

    # Set some defaults
    set sname ""
    set ftype ascii
    set comm "//"
    set separ " "
    set attrlist ""
    set aname ""
    set atype double
    set asort unsorted
    set tgrps ""

    # Read the file and get the contents
    readfile $filename

    # Call function to display the schema
    newschemawin
}


#-----------------------------------------------------------
# General function to display a message
proc showmesg {str} {
    toplevel .msg -bg honeydew2 
    wm title .msg Message
    wm iconname .msg Message
    
    frame .msg.str -relief raised -bd 1 -bg honeydew2
    frame .msg.ok -relief raised -bg honeydew2
    pack .msg.str .msg.ok -side top -fill x -padx 3m -pady 3m

    message .msg.str.msg -width 3i -text $str -bg honeydew2 -fg red
    pack .msg.str.msg -side right -expand 1 -fill both -padx 3m -pady 3m

    button .msg.ok.but -text OK -bg gray75 -fg IndianRed4 \
	    -command {destroy .msg}
    pack .msg.ok.but -side top -expand 1 -padx 3m -pady 1m

    tkwait visibility .msg
    grab set .msg
    tkwait window .msg
}


#-----------------------------------------------------------
# Procedure that creates the schema file
proc writefile {name type comm sep alist} {
    global tgrps glist 
    set f [open $name.schema w]

    puts $f "type $name $type" 
    puts $f "comment $comm"
    puts $f "separator '$sep'"
    
    foreach attr $alist {
	set aname [lindex $attr 0]
	set atype [lindex $attr 1]
	set asort [lindex $attr 2]
	
	if {$asort != "unsorted"} {
	    puts -nonewline $f "sorted "
	}
	puts $f "attr $aname $atype"
    }

    foreach nm $tgrps {
	goutput $f $nm
    }

    close $f
}

#-----------------------------------------------------------
proc readfile {filename} {
    global sname ftype comm separ attrlist tgrps
    set attrlist ""

    # Open file for reading
    set f [open $filename r]

    # First line is the schema name and type
    set line [gets $f]
    scan $line "type %s %s" sname ftype

    # Second line is comment
    set line [gets $f]
    scan $line "comment %s" comm

    # Third line is separator
    set line [gets $f]
    # everything between the 's is the separator
    set lstart [string first "'" $line]
    set lend [string last "'" $line]
    set lstart [expr $lstart+1]
    set lend [expr $lend-1]
    set separ [string range $line $lstart $lend]

    # Following are all attr declarations
    set len [gets $f line]
    set num 0
    while {$len != -1} {
	set first [lindex $line 0]
	if {$first == "group"} break

	if {$first != "sorted"} {
	    scan $line "attr %s %s" attrname attrtype
	    set attr [list $attrname $attrtype unsorted]
	} else {
	    scan $line "sorted attr %s %s" attrname attrtype
	    set attr [list $attrname $attrtype sorted]
	}

	puts "Inserting .. $attr"
	set attrlist [linsert $attrlist $num $attr]
	set len [gets $f line]
	set num [expr $num+1]
    }

    while {$len != -1} {
	set nm [lindex $line 1]
	set tgrps [lappend tgrps $nm]
	ginput $f $nm
	set len [gets $f line]
    }

    # Close file
    close $f
}

#--------------------------------------------------------------------
proc gbrowse {} {
    global tgrps glist resgrp

    toplevel .gbrowse -bg DarkRed
    wm title .gbrowse "Group Browser"
    wm iconname .gbrowse "Groups"

    # Toplevel rows
    frame .gbrowse.list -relief raised -bg honeydew2 
    frame .gbrowse.ops -relief raised -bg honeydew2 
    pack .gbrowse.list .gbrowse.ops -side top -fill x -padx 3m -pady 1m

    #-----------------------------------------------------------
    # Create a listbox displaying list of groups
    #    CreateTextBitmap .gbrowse.list.label group.gif Groups
    label .gbrowse.list.label -text "List of Groups" -bg honeydew2 -fg red
    pack .gbrowse.list.label -side top -fill x

    listbox .gbrowse.list.list -relief raised -bd 1 \
	    -yscrollcommand ".gbrowse.list.scroll set" \
	    -font 9x15 -selectmode extended  -bg honeydew2
    scrollbar .gbrowse.list.scroll \
	    -command ".gbrowse.list.list yview" -bg honeydew2
    pack .gbrowse.list.scroll  -side right -fill y
    pack .gbrowse.list.list  -fill x 


    # Insert all existing top level groups into the listbox
    foreach nm $tgrps {
	.gbrowse.list.list insert end $nm
    }


    # Panel for group name and panels for create, delete and modify
    frame .gbrowse.ops.name -relief raised -bg honeydew2 -bd 1
    frame .gbrowse.ops.op -relief raised -bg honeydew2 
    pack .gbrowse.ops.name .gbrowse.ops.op -side top -fill x \
	    -padx 3m -pady 1m

    label .gbrowse.ops.name.label -text "Group Name " -bg honeydew2 -fg red
    entry .gbrowse.ops.name.entry -width 15 -relief sunken -bd 2 \
	    -textvariable gname -bg bisque
    pack .gbrowse.ops.name.label .gbrowse.ops.name.entry -side left \
	    -fill x -padx 1m -pady 1m -expand 1

    button .gbrowse.ops.op.create -text "Create" \
	    -bg gray75 -fg IndianRed4 	-command {
	if {$gname == ""} {
	    showmesg "Please specify the name of the group"
	} elseif {[info exists glist($gname)] == 1} {
	    showmesg "Group with this name already exists."
	    set gname ""
	} else {
	    set glist($gname) ""
	    set resgrp ""
	    dispgrp $gname
	    if {$resgrp != ""} {
		set tgrps [lappend tgrps $resgrp]
		.gbrowse.list.list insert end $resgrp
	    } 
	    set gname ""
	}
    }
    button .gbrowse.ops.op.delete -text "Delete" \
	    -bg gray75 -fg IndianRed4	-command {
	if {$gname == ""} {
	    showmesg "Please specify the name of the group"
	} else {
	    # Search through tgrps and delete gname 
	    set idx [lsearch $tgrps $gname]
	    if {$idx == -1} {
		showmesg "Group with this name does not exist."
	    } else {
		set tgrps [lreplace $tgrps $idx $idx]
		delgrp $gname
		# Remove entry from the list box
		set i 0
		while {[.gbrowse.list.list get $i] != $gname} {
		    set i [expr $i+1]
		}
		.gbrowse.list.list delete $i
	    }
	    set gname ""
	}
    }
    button .gbrowse.ops.op.modify -text "Modify" \
	    -bg gray75 -fg IndianRed4	-command {
	if {$gname == ""} {
	    showmesg "Please specify the name of the group"
	} elseif {[lsearch $tgrps $gname] == -1} {
	    showmesg "Group with this name does not exist."
	} else {
	    dispgrp $gname
	    set gname ""
	}
    }
    button .gbrowse.ops.op.quit -text "Quit" \
	    -bg gray75 -fg IndianRed4	-command {
	printgrps 
	destroy .gbrowse
    }
    pack .gbrowse.ops.op.create .gbrowse.ops.op.delete \
	    .gbrowse.ops.op.modify .gbrowse.ops.op.quit \
	    -side left -padx 3m -pady 1m -expand 1

    #-----------------------------------------------------------
    # Finally grab focus
    tkwait visibility .gbrowse
    grab set .gbrowse
    tkwait window .gbrowse
}

proc dispgrp {gname } {
    global glist resgrp tgrps currgrp cnt
    # Displays the group information and allows modification

    set currgrp $gname 

    toplevel .grp -bg DarkRed
    wm title .grp Group 
    wm iconname .grp Group

    frame .grp.list -relief raised -bg honeydew2
    frame .grp.ops -relief raised -bg honeydew2
    frame .grp.bot -relief raised -bg honeydew2
    pack .grp.list .grp.ops .grp.bot -side top -fill x -padx 3m -pady 1m

    # List showing current group structure
    label .grp.list.label -text "Group : $gname" -bg honeydew2 -fg Red
    pack .grp.list.label -side top -fill x

    listbox .grp.list.list -relief raised -bd 1 \
	    -yscrollcommand ".grp.list.scroll set" \
	    -font 9x15 -selectmode extended  -bg honeydew2
    scrollbar .grp.list.scroll \
	    -command ".grp.list.list yview" -bg honeydew2
    pack .grp.list.scroll  -side right -fill y
    pack .grp.list.list  -fill x 


    # Insert all the existing members of the group into the list
    glinsert $gname

    # Frame containing item and nested grp info
    frame .grp.curr -relief raised -bg honeydew2 
    pack .grp.curr -in .grp.ops -side top -fill x -padx 2m -pady 1m
    label .grp.curr.label -text "Current group " -bg honeydew2 -fg Red
    entry .grp.curr.entry -width 10 -relief sunken -bd 2 \
	    -textvariable currgrp -bg bisque
    pack .grp.curr.label .grp.curr.entry -side left -padx 2m -expand 1

    frame .grp.item -relief raised -bg honeydew2 -bd 1
    frame .grp.ngrp -relief raised -bg honeydew2 -bd 1 
    pack .grp.item .grp.ngrp -in .grp.ops -side left -padx 2m -pady 1m \
	    -expand 1

    frame .grp.item.top -relief raised -bg honeydew2
    frame .grp.item.mid -relief raised -bg honeydew2
    frame .grp.item.bot -relief raised -bg honeydew2
    pack .grp.item.top .grp.item.mid .grp.item.bot -side top -fill x \
	    -padx 1m -pady 1m

    label .grp.item.top.label -text "Item" -bg honeydew2 -fg Red
    pack .grp.item.top.label 
    
    label .grp.item.mid.label -text "Name " -bg honeydew2 -fg Red
    entry .grp.item.mid.entry -width 10 -relief sunken -bd 2 \
	    -textvariable iname -bg bisque
    pack .grp.item.mid.label .grp.item.mid.entry -side left -fill x \
	    -padx 3m -pady 1m

    button .grp.item.bot.add -text "Insert" \
	    -bg gray75 -fg IndianRed4 -command {
	if {$iname == ""} {
	    showmesg "Please specify the name of the item."
	} elseif {$currgrp == ""} {
	    showmesg "Specify the current group into which the item would \
		    be inserted."
	} elseif {[info exists glist($currgrp)] == 0} {
		showmesg "Current group $currgrp is invalid."
	} else {
	    set elem [list $iname i]
	    set glist($currgrp) [lappend glist($currgrp) $elem]
	    # Now insert in the listbox
	    set cnt -1
	    gpos $gname $iname
	    .grp.list.list insert $cnt $iname
	    set iname ""
	}
    }

    button .grp.item.bot.del -text "Delete" \
	    -bg gray75 -fg IndianRed4 -command {
	if {$iname == ""} {
	    showmesg "Please specify the name of the item."
	} else {
	    set gr $gname
	    set nm [gsearch $gname $iname]
	    if {$nm == ""} {
		showmesg "Item <$iname> does not exist."
	    } else {
		set elem [list $iname i]
		set idx [lsearch $glist($nm) $elem]
		set glist($nm) [lreplace $glist($nm) $idx $idx]
		#  Also remove from the listbox
		set idx 0
		set elem [.grp.list.list get $idx]
		while {$elem != $iname} {
		    set idx [expr $idx+1]
		    set elem [.grp.list.list get $idx]
		}
		.grp.list.list delete $idx
	    }
	    set iname ""
	}
    }
    pack .grp.item.bot.add  \
	    .grp.item.bot.del -side left -expand 1 -padx 3m -pady 1m

    frame .grp.ngrp.top -relief raised -bg honeydew2
    frame .grp.ngrp.mid -relief raised -bg honeydew2
    frame .grp.ngrp.bot -relief raised -bg honeydew2
    pack .grp.ngrp.top .grp.ngrp.mid .grp.ngrp.bot -side top -fill x \
	    -padx 1m -pady 1m

    label .grp.ngrp.top.label -text "Nested Group" -bg honeydew2 -fg Red
    pack .grp.ngrp.top.label 
    
    label .grp.ngrp.mid.label -text "Name " -bg honeydew2 -fg Red
    entry .grp.ngrp.mid.entry -width 10 -relief sunken -bd 2 \
	    -textvariable ngname -bg bisque
    pack .grp.ngrp.mid.label .grp.ngrp.mid.entry -side left -fill x \
	    -padx 3m -pady 1m

    button .grp.ngrp.bot.add -text "Create" \
	    -bg gray75 -fg IndianRed4 -command {
	if {$ngname == ""} {
	    showmesg "Please specify the name of the nested group."
	} elseif {[info exists glist($currgrp)] == 0} {
	    showmesg "Current group $currgrp is not valid."
	} else {
	    set elem [list $ngname g]
	    set glist($currgrp) [lappend glist($currgrp) $elem]
	    set cnt -1
	    gpos $gname $ngname
	    .grp.list.list insert $cnt "end group $ngname"
	    .grp.list.list insert $cnt "begin group $ngname"
	    set nlist [lappend nlist $currgrp]
	    set currgrp $ngname
	    set glist($ngname) ""
	}
    }
    button .grp.ngrp.bot.del -text "Delete" \
	    -bg gray75 -fg IndianRed4 -command {
	if {$ngname == ""} {
	    showmesg "Please specify the name of the nested group."
	} else {
	    set outer [gsearch $gname $ngname]
	    if {$outer == ""} {
		showmesg "Nested group $ngname is invalid."
	    } else {
		set elem [list $ngname g]
		set idx [lsearch $glist($outer) $elem]
		set glist($outer) [lreplace $glist($outer) $idx $idx]
		delgrp $ngname
		# Now remove from the listbox
		set idx 0
		set elem [.grp.list.list get $idx]
		set start "begin group $ngname"
		while {$elem != $start} {
		    set idx [expr $idx+1]
		    set elem [.grp.list.list get $idx]
		}
		set dest "end group $ngname"
		while {$elem != $dest} {
		    .grp.list.list delete $idx
		    set elem [.grp.list.list get $idx]
		}
		.grp.list.list delete $idx
		set ngname ""
	    }
	}
    }
    pack .grp.ngrp.bot.add .grp.ngrp.bot.del \
	    -side left -expand 1 -padx 3m -pady 1m

    # Frame containing save and cancel buttons
    button .grp.bot.save -text "Save" \
	    -bg gray75 -fg IndianRed4 -command {
	destroy .grp
	# Finally return the group name
	set resgrp $gname
	# reset nlist
	set nlist ""
    }
    button .grp.bot.cancel -text "Cancel" \
	    -bg gray75 -fg IndianRed4 -command {
	destroy .grp
	# Return empty string
	set resgrp ""
    }
    pack .grp.bot.save .grp.bot.cancel -side left -expand 1 \
	    -padx 3m -pady 1m    

    # Finally grab focus
    tkwait visibility .grp
    grab set .grp
    tkwait window .grp
}


proc printgrps {} {
    global tgrps
    # Loop through all the top level groups 
    foreach top $tgrps {
	puts "Top level group-----------$top"
	printgrp $top
    }
}

proc printgrp {name} {
    global glist

    puts "Group $name"
    foreach elem $glist($name) {
	set nm [lindex $elem 0]
	set ty [lindex $elem 1]
	if {$ty == "i"} {
	    puts "Item $nm"
	} else {
	    printgrp $nm
	}
    }

    puts "End of group $name"
}

proc glinsert {name} {
    global glist 
    # inserts members of the group into a listbox
    
    foreach elem $glist($name) {
	set nm [lindex $elem 0]
	set ty [lindex $elem 1]
	if {$ty == "i"} {
	    .grp.list.list insert end $nm
	} else {
	    .grp.list.list insert end "begin group $nm"
	    glinsert $nm
	    .grp.list.list insert end "end group $nm"
	}
    }
}

proc goutput {f name} {
    global glist

    # output the group structure for nm to file f

    puts $f "group $name"
    foreach elem $glist($name) {
	set nm [lindex $elem 0]
	set ty [lindex $elem 1]
	if {$ty == "i"} {
	    puts $f "item $nm"
	} else {
	    goutput $f $nm
	}
    }

    puts $f "endgroup"
}

proc ginput {f name} {
    global glist

    set glist($name) ""
    # input  the group structure for nm from file f
    set len [gets $f line]

    while {$line != "endgroup"} {
	set ty [lindex $line 0]
	set nm [lindex $line 1]
	if {$ty == "item"} {
	    set elem [list $nm i]
	    set glist($name) [lappend glist($name) $elem]
	} else {
	    set elem [list $nm g]
	    set glist($name) [lappend glist($name) $elem]
	    ginput $f $nm
	}
	set len [gets $f line]
    }
}

proc delgrp {name} {
    global glist

    # delete all the members of the group
    
    foreach elem $glist($name) {
	set nm [lindex $elem 0]
	set ty [lindex $elem 1]
	if {$ty == "g"} {
	    delgrp $nm
	}
    }
    unset glist($name)
}


proc gsearch {gnm inm} {
    global glist

    # Searches for the item "inm" in the group "gnm". It recursively
    # traverses the nested sub groups and returns the name of the 
    # immediate outer group in which the item is found.
    # Returns null string if the item is not found

    foreach elem $glist($gnm) {
	set nm [lindex $elem 0]
	if {$nm == $inm} {
	    return $gnm
	}
	set ty [lindex $elem 1]
	if {$ty == "g"} {
	    set ret [gsearch $nm $inm]
	    if {$ret != ""} {
		return $ret
	    }
	}
    }

    return ""
}

proc gpos {gnm inm} {
    global glist cnt

    # This function returns the "flattened" position of the item "inm"
    # within the group "gnm". This would be the line number of this
    # item within the listbox displaying the group
    # Returns 0 if the item was not found, 1 if found

    foreach elem $glist($gnm) {
	set cnt [expr $cnt+1]
	set nm [lindex $elem 0]
	set ty [lindex $elem 1]
	if {$nm == $inm} {
	    return 1
	}
	if {$ty == "g"} {
	    set ret [gpos $nm $inm]
	    if {$ret == 1} {
		return 1
	    }
	}
    }
    set cnt [expr $cnt+1]
    return 0
}