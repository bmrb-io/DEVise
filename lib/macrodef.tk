#  ========================================================================
#  DEVise Data Visualization Software
#  (c) Copyright 1992-1996
#  By the DEVise Development Group
#  Madison, Wisconsin
#  All Rights Reserved.
#  ========================================================================
#
#  Under no circumstances is this software to be copied, distributed,
#  or altered in any way without prior permission from the DEVise
#  Development Group.

############################################################

#	$Id$

#	$Log$
#	Revision 1.26  1996/01/10 00:38:42  jussi
#	Added support for hi/lo values defined in schema.
#
#	Revision 1.25  1995/12/29 17:33:04  jussi
#	Changed format of view instance names created automatically.
#	Removed Double-Button-1 binding of group selection list.
#	Cleaned up code that initializes associative arrays.
#
#	Revision 1.24  1995/12/14 15:49:16  jussi
#	Added support for TileLayout with automatic or manual view layout
#	control.
#
#	Revision 1.23  1995/12/13 02:06:06  ravim
#	Changed criterion for not reloading the schema.
#
#	Revision 1.22  1995/12/04 18:28:15  jussi
#	Changed size of automatically created windows to depend on view
#	layout selected. For horizontal layout, the window is wide, for
#	vertical layout, it's tall.
#
#	Revision 1.21  1995/12/04 18:02:33  jussi
#	User can now choose to have a title, X axis, Y axis, X link enabled
#	or disabled in automatically generated views. Window name can be
#	specified too. Horizontal view layouts are available now.
#
#	Revision 1.20  1995/11/29 15:47:26  jussi
#	Removed constant size definition from some toplevel windows
#	because they will produce unexpected results on some window
#	managers.
#
#	Revision 1.19  1995/11/22 17:53:46  jussi
#	Added view type selection in automatic view generation. User can
#	now choose between a bar chart, an image, and a scatter plot.
#
#	Revision 1.18  1995/11/20 22:22:54  jussi
#	Changed sequence of caching data from tape to disk.
#	Restored missing history log.
#
#	Revision 1.17  1995/11/19 06:04:29  ravim
#	New way of displaying attributes and groups.
#
#	Revision 1.16  1995/11/18 01:49:46  ravim
#	Groups associated with schema. Also groups chosen at "Auto" stage.
#
#	Revision 1.15  1995/11/14 22:50:39  jussi
#	Interfaced new stream selection dialog into DefSource. Minor other
#	changes.
#
#	Revision 1.14  1995/11/07 20:24:48  jussi
#	Commented out some output statements.
#
#	Revision 1.13  1995/11/06 16:33:33  jussi
#	Increased minimum vertical size of .map window.
#
#	Revision 1.12  1995/10/29 01:01:12  ravim
#	Bug fix.
#
#	Revision 1.11  1995/10/27 21:05:03  ravim
#	Handles group names starting with capital letters.
#
#	Revision 1.10  1995/10/11 17:07:21  ravim
#	Minor changes.
#
#	Revision 1.9  1995/09/30 08:00:52  ravim
#	No changes - Ignore.
#
#	Revision 1.8  1995/09/30 07:59:18  ravim
#	Minor changes to group handling
#
#	Revision 1.7  1995/09/30 07:56:11  ravim
#	Initial implementation of schema browser - can create new schema files
#
#	Revision 1.6  1995/09/28 17:44:03  jussi
#	Included size, pattern, and orientation in all mapping definitions
#	although these are not used by DEVise currently. Minor other
#	touch-ups.
#
#	Revision 1.5  1995/09/27 17:20:34  ravim
#	Added support for groups in schemas.
#
#	Revision 1.4  1995/09/26 23:09:02  jussi
#	Added color/shape/size/pattern/orientation settings to view
#	definition.
#
#	Revision 1.3  1995/09/22 17:33:47  jussi
#	Added copyright message.
#
#	Revision 1.2  1995/09/21 15:36:27  jussi
#	Added small icons.
#
#	Revision 1.1  1995/09/13 14:24:07  jussi
#	Extracted macro definition code from control.tk.

############################################################

proc MacroDefInit {} {
    global macroSelectedColor macroUnselectedColor macroLinkColor
    global macroSelectColor macroMenuSelectColor macroActiveColor

    set macroSelectedColor LightBlue
    set macroUnselectedColor LightPink
    set macroLinkColor LightBlue
    set macroSelectColor #e6ceb1
    set macroMenuSelectColor white
    set macroActiveColor #e6ceb1

    MacroDefClear
}

############################################################

proc MacroDefStart {} {
    global tdatas schemas maps mappings views links windows modified

    # see if .map window already exists; if so, just return
    set err [catch {set exists [wm state .map]}]
    if {!$err} { wm deiconify .map; return }

    set tdatas ""
    catch {unset schemas}
    catch {unset maps}
    catch {unset mappings}
    catch {unset links}
    catch {unset windows}
    catch {unset views}

    foreach schema [DEVise get tdata] {
	set err [catch {set exists $maps($schema)}]
	if {$err > 0} { set maps($schema) "" }
	foreach tdata [DEVise get tdata $schema] {
	    set params [DEVise getCreateParam tdata $schema $tdata]
	    set filePath [lindex $params 0]
	    set fileAlias [lindex $params 1]
	    lappend tdatas [list $fileAlias $filePath]
	    set sdef [DEVise getSchema $tdata]
	    set schemas($tdata) [list $schema $sdef]
	}
    }

    foreach class [lsort [DEVise get "mapping"]] {
	foreach mapping [lsort [DEVise get "mapping" $class]] {
	    set params [DEVise getCreateParam "mapping" $class $mapping]
	    set tdata [lindex $params 0]
	    set schema [lindex $schemas($tdata) 0]
	    set mapname [lindex $params 1]
	    set firsthash [string first \# $mapname]
	    if {$firsthash >= 0} {
		incr firsthash
		set mapname [string range $mapname $firsthash end]
	    }
	    set x [string range [lindex $params 3] 1 end]
	    set y [string range [lindex $params 4] 1 end]
	    set color [lindex $params 5]
	    set size [lindex $params 6]
	    set pattern [lindex $params 7]
	    set orient [lindex $params 8]
	    set shape [lindex $params 9]
	    set shapeAttr0 [lindex $params 10]
	    set shapeAttr1 [lindex $params 11]
	    set defn [list $x $y $color $size $pattern $orient $shape \
		    $shapeAttr0 $shapeAttr1]
	    set mappings($mapname) $defn
	    if {[string first $mapname $maps($schema)] < 0} {
		lappend maps($schema) $mapname
	    }
	}
    }

    foreach class [lsort [DEVise get "window"]] {
	foreach window [lsort [DEVise get "window" $class]] {
	    set params [DEVise getCreateParam "window" $class $window]
	    set name [lindex $params 0]
	    set windows($name) [lrange $params 1 end]
	}
    }

    foreach class [lsort [DEVise get "link"]] {
	foreach link [lsort [DEVise get "link" $class]] {
	    set params [DEVise getCreateParam "link" $class $link]
	    set name [lindex $params 0]
	    set links($name) [lrange $params 1 end]
	}
    }

    foreach class [lsort [DEVise get "view"]] {
	foreach view [lsort [DEVise get "view" $class]] {
	    set params [DEVise getCreateParam "view" $class $view]
	    set name [lindex $params 0]
	    set views($name) [lrange $params 1 end]
	}
    }

    set modified 0
    MacroDef
}

############################################################

proc MacroDef {} {
    global tdatas schemas maps mappings views links windows
    global tdata window gdata view link none

    # see if .map window already exists; if so, just return
    set err [catch {set exists [wm state .map]}]
    if {!$err} { wm deiconify .map; return }

    set none "-- None --"

    toplevel .map
    wm title .map "Define Visualization"
    wm geometry .map +50+50
    selection clear .map

    frame .map.top
    frame .map.bot
    pack .map.top -side top -pady 3m -fill both -expand 1
    pack .map.bot -side top -pady 5m -fill x

    frame .map.bot.but
    pack .map.bot.but -side top

    button .map.bot.but.close -text Close -width 10 -command {
	destroy .map
    }
    button .map.bot.but.create -text Create -width 10 -command {
	MacroDefNewMapping
    }
    button .map.bot.but.auto -text "Auto..." -width 10 -command {
	MacroDefAuto $tdata
    }

    CreateBitmapButton .map.bot.but.help help.gif Help MacroDefHelp
#    button .map.bot.but.help -text Help -width 40 -command MacroDefHelp
    pack .map.bot.but.close .map.bot.but.create .map.bot.but.auto \
	    .map.bot.but.help -side left -padx 5m

    frame .map.left -relief groove -borderwidth 2
    frame .map.right -relief groove -borderwidth 2
    pack .map.left .map.right -in .map.top -side left \
	    -fill both -expand 1

    frame .map.tdata
    frame .map.window
    frame .map.gdata
    frame .map.view
    frame .map.link
    pack .map.tdata .map.window -in .map.left -side top -pady 3m \
	    -fill both -expand 1
    pack .map.gdata .map.view .map.link -in .map.right -side top -pady 3m \
	    -fill both -expand 1

    MacroDefTdata .map.tdata "$none"
    MacroDefWindows .map.window "$none"
    MacroDefMaps .map.gdata "$none"
    MacroDefViews .map.view "$none"
    MacroDefLinks .map.link "$none"

    tkwait visibility .map
}

############################################################

proc MacroDefNewMapping {} {
    global tdatas schemas maps mappings views links windows
    global tdata window gdata view link none

    if {$tdata == $none || $window == $none \
	|| $gdata == $none || $view == $none} {
	dialog .createError "Note" \
		"Please select a data source, a window,\n\
		a mapping and a view and then press Create." \
		"" 0 OK
	return
    }

    set x [lindex $mappings($gdata) 0]
    set y [lindex $mappings($gdata) 1]
    set color [lindex $mappings($gdata) 2]
    set size [lindex $mappings($gdata) 3]
    set pattern [lindex $mappings($gdata) 4]
    set orient [lindex $mappings($gdata) 5]
    set shape [lindex $mappings($gdata) 6]
    set shapeAttr0 ""
    set shapeAttr1 ""

    # ask DEVise to create view instance
    set sorted SortedX
    set viewname [UniqueName "$y vs. $x"]
    if {[lsearch [ViewSet] $viewname] >= 0} {
	dialog .viewError "View Error" \
		"View $viewname exists already." "" 0 OK
	return
    }
    set cmd [concat DEVise create view $sorted \{$viewname\} $views($view)]
    set result [eval $cmd]
    if {$result == ""} {
	dialog .viewError "View Error" \
		"Error creating view $viewname" "" 0 OK
	return
    }

    if {[lsearch [DEVise get mapping] $gdata] < 0} {
	# ask DEVise to create interpreted mapping
	# parameter format: x y color size pattern orientation shape
	set result [DEVise createInterp $tdata $gdata "" \$$x \$$y \
		$color $size $pattern $orient $shape $shapeAttr0 $shapeAttr1]
    }

    set mapinstance "$tdata#$gdata" 
    if {[lsearch [GdataSet] $mapinstance] < 0} {
	# ask DEVise to create an instance of mapping
	set result [DEVise create mapping $gdata $tdata $mapinstance \
		"" \$$x \$$y $color $size $pattern $orient $shape \
		$shapeAttr0 $shapeAttr1]
	DEVise setPixelWidth $mapinstance 1
    }

    # ask DEVise to insert $viewname into $mapinstance
    set result [DEVise insertMapping $viewname $mapinstance]
    # seems that there's no error code returned

    # ask DEVise to insert $viewname into $window
    set result [DEVise insertWindow $viewname $window]
    # seems that there's no error code returned

    if {$link != $none} {
	# ask DEVise to link $viewname to $link
	set result [DEVise insertLink $link $viewname]
	# seems that there's no error code returned
    }

    ProcessViewSelected $viewname

    # DoToggleAxis X
    DoToggleAxis Y
}

############################################################

proc MacroDefClear {} {
    global tdatas schemas maps mappings views links windows

    set tdatas ""

    catch {unset schemas}
    catch {unset maps}
    catch {unset mappings}
    catch {unset views}
    catch {unset links}
    catch {unset windows}
}

############################################################

proc MacroDefHelp {} {
    # see if .help window already exists; if so, just return
    set err [catch {set exists [wm state .help]}]
    if {!$err} { wm deiconify .help; return }

    toplevel .help
    wm title .help "Help"
    wm geometry .help +100+100
    message .help.msg -justify center -width 10c \
	    -text "You can create a new visualization by selecting\
	           a data source, window, mapping, and view, and then\
		   pressing Create. To select any of these items, pull\
		   down the corresponding menu and select an existing\
		   item from the menu, or select New to create a new\
		   item.\n\n\
		   From the Link menu you can choose an existing link\
		   to link the new visualization to existing\
		   visualizations,\
		   or you can create a new link by choosing the New\
		   item from the Link menu, or you can leave the new\
		   visualization unlinked by choosing None.\n\n\
		   To create automatic views, select a data source and\
		   then press Auto. Select the attribute you want on the\
		   X axis and the set of attributes you want on the Y\
		   axis. Click OK, and you will see a new window with\
		   the views you selected. All views are linked on the\
		   X axis.\n\n\
		   Click on Close when you're done."
    button .help.ok -text OK -width 10 -command "destroy .help"
    pack .help.msg .help.ok -side top -padx 5m -pady 3m

    tkwait visibility .help
}

############################################################

proc MacroDefAuto {tdata} {
    global schemas modified x yvar selgrp schemaname schema
    global viewsel viewselname macroSelectColor macroMenuSelectColor
    global layoutsel linksel winnamesel titlesel
    global xaxissel yaxissel sourceList

    # see if .auto window already exists; if so, just return
    set err [catch {set exists [wm state .auto]}]
    if {!$err} { wm deiconify .auto; return }

    set sname [lindex $schemas($tdata) 0]
    set schema [ElimStringAttr [lindex $schemas($tdata) 1]]
    set sfname [lindex $sourceList($tdata) 3]
    set schemaname [file tail $sfname]

    # get the list of top level group names from DEVise
    set topgrps [DEVise getTopGroups $schemaname]

    if {[llength $topgrps] == 1 && [lindex $topgrps 0] == "__default"} {
	set selgrp "__default"
    } else {
	# Create window to show list of top level group names
	toplevel .topgrps
	wm title .topgrps "Choose Attribute Group"
	wm geometry .topgrps +100+100
	selection clear .topgrps
	listbox .topgrps.list -relief raised -borderwidth 2 \
		-yscrollcommand ".topgrps.scroll set" \
		-font 9x15 -selectmode single
	scrollbar .topgrps.scroll -command ".topgrps.list yview"
	button .topgrps.ok -text OK -command {
	    set selgrp [.topgrps.list get active]
	    set topgrp $selgrp
	    destroy .topgrps
	}
	pack .topgrps.ok -side bottom -fill x
	pack .topgrps.scroll -side right -fill y
	pack .topgrps.list -fill x 
	
	foreach i $topgrps {
	    .topgrps.list insert end $i
	}
	
	tkwait visibility .topgrps
	grab set .topgrps
	tkwait window .topgrps
    }

    toplevel .auto
    wm title .auto "Automatic Views"
    wm geometry .auto +100+100
    selection clear .auto

    label .auto.label -text "Select Auto Parameters"
    frame .auto.top
    frame .auto.mid
    frame .auto.bot
    frame .auto.ysel -relief groove -borderwidth 2
    frame .auto.but
    pack .auto.label -side top -pady 3m -fill x -expand 1
    pack .auto.top -side top -pady 3m -fill x -expand 1
    pack .auto.mid -side top -pady 3m -fill x -expand 1
    pack .auto.bot -side top -pady 3m -fill x -expand 1
    pack .auto.ysel -side top -pady 3m -fill x -expand 1
    pack .auto.but -side top -pady 3m -fill x -expand 1

    frame .auto.winnamesel -relief groove -borderwidth 2
    frame .auto.xsel -relief groove -borderwidth 2
    pack .auto.winnamesel .auto.xsel -in .auto.top -side left \
	    -ipady 3m -padx 3m -fill x -expand 1

    frame .auto.viewsel -relief groove -borderwidth 2
    frame .auto.layoutsel -relief groove -borderwidth 2
    pack .auto.viewsel .auto.layoutsel -in .auto.mid \
	    -side left -ipady 3m -padx 3m -fill x -expand 1

    frame .auto.titlesel -relief groove -borderwidth 2
    frame .auto.linksel -relief groove -borderwidth 2
    frame .auto.xaxissel -relief groove -borderwidth 2
    frame .auto.yaxissel -relief groove -borderwidth 2
    pack .auto.titlesel .auto.linksel .auto.xaxissel .auto.yaxissel \
	    -in .auto.bot -side left -ipady 3m -padx 3m -fill x -expand 1

    label .auto.winnamesel.label -text "Window Name:"
    entry .auto.winnamesel.entry -relief sunken -textvariable winnamesel \
	    -width 30
    pack .auto.winnamesel.label .auto.winnamesel.entry -side left -padx 3m
    set winnamesel "$tdata (Auto)"

    label .auto.xsel.label -text "Select X:"
    menubutton .auto.xsel.attr -relief raised \
	    -textvariable x -menu .auto.xsel.attr.g$selgrp -width 15
    pack .auto.xsel.label .auto.xsel.attr -side left -padx 3m

    label .auto.viewsel.label -text "View Type:"
    menubutton .auto.viewsel.view -relief raised \
	    -textvariable viewselname -menu .auto.viewsel.view.menu -width 15
    pack .auto.viewsel.label .auto.viewsel.view -side left -padx 3m

    menu .auto.viewsel.view.menu -tearoff 0
    .auto.viewsel.view.menu add radiobutton -label "Scatter Plot" \
	    -variable viewselname -value "Scatter Plot" -command {
	set viewsel 0
    }
    .auto.viewsel.view.menu add radiobutton -label Image \
	    -variable viewselname -value Image -command {
	set viewsel 1
    }
    .auto.viewsel.view.menu add radiobutton -label "Bar Chart" \
	    -variable viewselname -value "Bar Chart" -command {
	set viewsel 2
    }
    set viewselname "Bar Chart"
    set viewsel 2

    label .auto.layoutsel.label -text "Layout:"
    menubutton .auto.layoutsel.layout -relief raised \
	    -textvariable layoutsel -menu .auto.layoutsel.layout.menu \
	    -width 15
    pack .auto.layoutsel.label .auto.layoutsel.layout -side left -padx 3m

    menu .auto.layoutsel.layout.menu -tearoff 0
    .auto.layoutsel.layout.menu add radiobutton -label Tiled \
	    -variable layoutsel -value Tiled
    .auto.layoutsel.layout.menu add radiobutton -label Vertical \
	    -variable layoutsel -value Vertical
    .auto.layoutsel.layout.menu add radiobutton -label Horizontal \
	    -variable layoutsel -value Horizontal
    set layoutsel Vertical

    checkbutton .auto.titlesel.title -text Title -variable titlesel
    pack .auto.titlesel.title -side left -padx 3m
    set titlesel 0

    checkbutton .auto.linksel.link -text "Link X" -variable linksel
    pack .auto.linksel.link -side left -padx 3m
    set linksel 1

    checkbutton .auto.xaxissel.xaxis -text "X Axis" -variable xaxissel
    pack .auto.xaxissel.xaxis -side left -padx 3m
    set xaxissel 0

    checkbutton .auto.yaxissel.yaxis -text "Y Axis" -variable yaxissel
    pack .auto.yaxissel.yaxis -side left -padx 3m
    set yaxissel 1

    if {$selgrp == "__default"} {
	set slabel "Select Y"
	set swidth 15
    } else {
	set slabel "Select Y from $selgrp"
	set swidth [expr [llength [split $selgrp {}]] + 15]
    }
    label .auto.ysel.label -text $slabel -width $swidth
    pack .auto.ysel.label -side top -fill x -expand 1 -pady 2m

    frame .auto.ysel.sel
    pack .auto.ysel.sel -side top -padx 3m -pady 1m -expand 1

    # For selecting Y attrs - a button here will pop up a new window
    # containing a list of name from which a selection can be made

    setupButtons .auto.ysel.sel $selgrp $selgrp

    # Have a list containing the name of the selected group.
    # In every iteration of the loop, create a menu with the name ending
    # with the group name.

    set addname($selgrp) .auto.xsel.attr.g$selgrp
    set grplist $selgrp
    set topgrp $selgrp
    while {[llength $grplist] > 0} {
	set grpname [lindex $grplist 0]
	set grplist [lreplace $grplist 0 0]
	menu $addname($grpname) -tearoff 0
	set subgrps [DEVise getItems $schemaname $topgrp $grpname]
        foreach sub $subgrps {
		set subname [lindex $sub 0]
		if {[lindex $sub 1] != "intr"} {
			$addname($grpname) add radiobutton \
				-label $subname -variable x -value $subname 
		} else {
			$addname($grpname) add cascade \
				-label $subname \
				-menu $addname($grpname).g$subname
			set grplist [linsert $grplist 0 $subname]
			set addname($subname) $addname($grpname).g$subname
		}
	}
    }

    # Try to select default X to be a sorted attribute
    set x [lindex [lindex $schema 0] 0]
    foreach attr $schema {
	set name [lindex $attr 0]
	set type [lindex $attr 1]
	set sorted [lindex $attr 2]
	if {$sorted > 0 && $name != "recId"} {
	    set x $name
	    break
	}
    }

    tk_menuBar .auto.xsel .auto.xsel.attr

    button .auto.but.ok -text OK -width 15 -command {
	set ylist ""
	foreach yname [array names yvar] {
	    if {$yvar($yname) > 0} {
		lappend ylist $yname
	    }
	}
	if {$ylist == ""} {
	    dialog .autoError "Note" \
		    "Please select one or more\n\
		    Y attributes for automatic\n\
		    mapping." "" 0 OK
	    return
	}

	# puts "The value of x is $x"
	# puts "The ylist is $ylist"

	MacroDefAutoActual $tdata $viewsel $linksel $winnamesel $layoutsel \
		$titlesel $xaxissel $yaxissel $x $ylist
	destroy .auto
    }
    button .auto.but.cancel -text Cancel -width 15 -command {
	destroy .auto
    }
    pack .auto.but.ok .auto.but.cancel -side left -expand 1 -padx 3m

    tkwait visibility .auto
}

############################################################

proc MacroDefAutoActual {tdata viewsel linksel window layout titlesel
                         xaxissel yaxissel x ylist} {
    global schemas maps mappings views links windows modified none
    global viewDefault

    set err [catch {set exists $windows($window)}]
    if {$err > 0} {
	# ask DEVise to create window
	if {$layout == "Tiled"} {
	    set winparam "0.3 0.3 0.4 0.4"
	    set layoutparam "-1 -1"
	} elseif {$layout == "Vertical" } {
	    set winparam "0.3 0.15 0.4 0.7"
	    set layoutparam "-1 1"
	} else {
	    set winparam "0.15 0.3 0.7 0.4"
	    set layoutparam "1 -1"
	}
	set cmd "DEVise create window TileLayout \{$window\} $winparam"
	set result [eval $cmd]
	if {$result == ""} {
	    dialog .windowError "Window Error" \
		    "Error creating window $window" "" 0 OK
	    return
	}
	set windows($window) $winparam
	eval "DEVise setWindowLayout \{$window\} $layoutparam"
    }
    
    set schema [ElimStringAttr [lindex $schemas($tdata) 1]]

    set bgColor white
    set sortedx 0
    set xlo ""
    set xhi ""

    # Find out type of X and whether it is sorted or not
    foreach attr $schema {
	set name [lindex $attr 0]
	if {$name != $x} {continue}
	set xtype [lindex $attr 1]
	set sortedx [lindex $attr 2]
	set hasxhi [lindex $attr 3]
	if {$hasxhi} {
	    set xhi [lindex $attr 4]
	}
	set hasxlo [lindex $attr 5]
	if {$hasxlo} {
	    set xlo [lindex $attr 6]
	}
	break
    }

    # also consult lo/hi values defined in .rc file
    set viewParams ""
    catch { set viewParams $viewDefault($xtype) }
    foreach param $viewParams {
	set pname [lindex $param 0]
	set value [lindex $param 1]
	if {$xlo == "" && $pname == "xlow"} {
	    set xlo $value
	}
	if {$xhi == "" && $pname == "xhigh"} {
	    set xhi $value
	}
    }

    # if no defaults specified anywhere, resort to these defaults
    if {$xhi == ""} {
	set xhi 0
    }
    if {$xlo == ""} {
	set xlo 100
    }

    # puts "Mapping will have xlo $xlo and xhi $xhi"

    if {$sortedx > 0} {
	set sortedx SortedX
    } else {
	set sortedx Scatter
    }

    set linkname [format "%s Link" $x]
    if {$linksel} {
	set err [catch {set exists $links($linkname)}]
	if {$err > 0} {
	    # ask DEVise to create link
	    set result [DEVise create link Visual_Link $linkname 1]
	    if {$result == ""} {
		dialog .linkError "Link Error" \
			"Error creating link $linkname" "" 0 OK
		return
	    }
	    set flag 1
	    set links($linkname) $flag
	}
    }

    set sname [lindex $schemas($tdata) 0]
    set color 2
    set shape $viewsel
    set size 1
    set pattern 0
    set orient 0
    set shapeAttr0 ""
    set shapeAttr1 ""

    if {$shape == 1} {
	# set pixel width and height to one for image displays
	set shape 0
	set shapeAttr0 1
	set shapeAttr1 1
    }

    foreach attr $schema {
	set name [lindex $attr 0]
	if {[lsearch $ylist $name] < 0} { continue }

	set type [lindex $attr 1]
	set sorted [lindex $attr 2]
	set yhi ""
	set hasyhi [lindex $attr 3]
	if {$hasyhi} {
	    set yhi [lindex $attr 4]
	}
	set ylo ""
	set hasylo [lindex $attr 5]
	if {$hasylo} {
	    set ylo [lindex $attr 6]
	}

	# also consult lo/hi values defined in .rc file
	set viewParams ""
	catch { set viewParams $viewDefault($type) }
	foreach param $viewParams {
	    set pname [lindex $param 0]
	    set value [lindex $param 1]
	    if {$ylo == "" && $pname == "ylow"} {
		set ylo $value
	    }
	    if {$yhi == "" && $pname == "yhigh"} {
		set yhi $value
	    }
	}

	# for bar shape, make ylo zero
	if {$shape == 2} {
	    set ylo 0
	}

	# if no defaults specified anywhere, resort to these defaults
	if {$yhi == ""} {
	    set yhi 0
	}
	if {$ylo == ""} {
	    set ylo 100
	}

	# puts "Mapping will have ylo $ylo and yhi $yhi"

	set mapname [format "%s_vs_%s" $name $x]
	set err [catch {set exists $mappings($mapname)}]
	if {$err > 0} {
	    set defn [list $x $name $color $size $pattern $orient $shape]
	    set mappings($mapname) $defn
	    lappend maps($sname) $mapname
	}

	set viewname [format "%s View" $name]
	set err [catch {set exists $views($viewname)}]
	if {$err > 0} {
	    set defn [list $xlo $xhi $ylo $yhi $bgColor]
	    set views($viewname) $defn
	}

	# ask DEVise to create view instance
	set sorted $sortedx
	set viewinstance [UniqueName "$name vs. $x"]
	if {[lsearch [ViewSet] $viewinstance] >= 0} {
	    dialog .viewError "View Error" \
		    "View $viewinstance exists already." "" 0 OK
	    return
	}
	set result [DEVise create view $sorted $viewinstance \
		$xlo $xhi $ylo $yhi $bgColor]
	if {$result == ""} {
	    dialog .viewError "View Error" \
		    "Error creating view $viewinstance" "" 0 OK
	    return
	}
	
	# ask DEVise to turn on/off label
	if {$titlesel} {
	    DEVise setLabel $viewinstance 1 16 $viewinstance
	}

	# ask DEVise to turn on/off X axis
	DEVise setAxisDisplay $viewinstance X $xaxissel

	# ask DEVise to turn on/off Y axis
	DEVise setAxisDisplay $viewinstance Y $yaxissel

	if {[lsearch [DEVise get mapping] $mapname] < 0} {
	    # ask DEVise to create interpreted mapping
	    # parameter format: x y color size pattern orientation shape
	    set result [DEVise createInterp $tdata $mapname "" \$$x \$$name \
		    $color $size $pattern $orient $shape $shapeAttr0 \
		    $shapeAttr1]
	}

	set mapinstance [UniqueName "$tdata#$mapname"]
	# ask DEVise to create an instance of mapping
	set result [DEVise create mapping $mapname $tdata $mapinstance \
		"" \$$x \$$name $color $size $pattern $orient $shape \
		$shapeAttr0 $shapeAttr1]
	DEVise setPixelWidth $mapinstance 1

	# ask DEVise to insert $viewinstance into $mapinstance
	set result [DEVise insertMapping $viewinstance $mapinstance]
	# seems that there's no error code returned

	# ask DEVise to insert $viewinstance into $window
	set result [DEVise insertWindow $viewinstance $window]
	# seems that there's no error code returned

	if {$linksel} {
	    # ask DEVise to link $viewinstance to $linkname
	    set result [DEVise insertLink $linkname $viewinstance]
	    # seems that there's no error code returned
	}

	DEVise clearViewHistory $viewinstance
	DEVise insertViewHistory $viewinstance $xlo $ylo $xhi $yhi 0

	ProcessViewSelected $viewinstance

	incr color
    }

    MacroDefWindows .map.window $none
    MacroDefMaps .map.gdata $none
    MacroDefViews .map.view $none
    MacroDefLinks .map.link $none

    set modified 1
}

############################################################

proc MacroDefTdata {m default} {
    global tdatas tdata modified none
    global macroSelectedColor macroUnselectedColor macroActiveColor

    catch {destroy $m.mbar}
    catch {destroy $m.label}

    set tdata $none
    set defExists 0

    menubutton $m.mbar -relief raised -textvariable tdata \
	    -menu $m.mbar.menu -width 24 -background $macroUnselectedColor \
	    -activebackground $macroActiveColor -justify left
    CreateTextBitmap $m.label file.gif Source
    pack $m.label $m.mbar -side left -padx 2m
    menu $m.mbar.menu -tearoff 0
    foreach t $tdatas {
	set name [lindex $t 0]
	$m.mbar.menu add command -label $name \
		-command "set tdata \"$name\"; \
		          MacroDefMaps .map.gdata \"$none\""
	if {$tdata == $none} {
	    set tdata $name
	}
	if {$default == $name} {
	    set defExists 1
	}
    }

    if {$default != $none && $defExists > 0} {
	set tdata $default
    }

    if {$tdata != $none} {
	# fix: .map.bot.but.auto should be a parameter
	.map.bot.but.auto configure -state normal
	$m.mbar configure -background $macroSelectedColor \
		-activebackground $macroActiveColor
    } else {
	.map.bot.but.auto configure -state disabled
    }

    $m.mbar.menu add command -label "Open..." \
	    -command {
	set sname [DefSource]
	if {$sname != ""} {
	    # fix this: .map.tdata should be $m
	    MacroDefTdata .map.tdata $sname
	    MacroDefMaps .map.gdata $none
	    set modified 1
	}
    }
    tk_menuBar $m $m.mbar
}

############################################################

proc MacroDefWindows {m default} {
    global windows window modified none
    global macroSelectedColor macroUnselectedColor
    global libdir

    catch {destroy $m.mbar}
    catch {destroy $m.label}

    set window $none
    set defExists 0

    menubutton $m.mbar -relief raised -textvariable window \
	    -menu $m.mbar.menu -width 24 \
	    -background $macroUnselectedColor -justify left
    CreateTextBitmap $m.label window.gif Window
    pack $m.label $m.mbar -side left -padx 2m
    menu $m.mbar.menu -tearoff 0
    foreach win [lsort [array names windows]] {
	$m.mbar.menu add command -label $win \
		-command "set window \"$win\""
	if {$window == $none} {
	    set window $win
	}
	if {$default == $win} {
	    set defExists 1
	}
    }

    if {$default != $none && $defExists > 0} {
	set window $default
    }

    if {$window != $none} {
	$m.mbar configure -background $macroSelectedColor
    }

    $m.mbar.menu add command -label "New..." \
	    -command {
	set winname [DefWindow]
	if {$winname != ""} {
	    # fix this: .map.window should be $m
	    MacroDefWindows .map.window $winname
	    set modified 1
	}
    }
    tk_menuBar $m $m.mbar
}

############################################################

proc MacroDefMaps {m default} {
    global schemas maps mappings tdata gdata modified none DEViseColors
    global macroSelectedColor macroUnselectedColor

    catch {destroy $m.mbar}
    catch {destroy $m.label}

    set gdata $none
    set defExists 0

    foreach color $DEViseColors {
	set idx [lindex $color 0]
	set name [lindex $color 1]
	set devcolors($idx) $name
    }

    menubutton $m.mbar -relief raised -textvariable gdata \
	    -menu $m.mbar.menu -width 20 -background $macroUnselectedColor
    if {$tdata != $none} {
	$m.mbar configure -state normal
    } else {
	$m.mbar configure -state disabled
    }
    CreateTextBitmap $m.label chart.gif Mapping
    pack $m.label $m.mbar -side left -padx 2m
    menu $m.mbar.menu -tearoff 0
    if {$tdata != $none} {
	set schema [lindex $schemas($tdata) 0]
	foreach map [lsort $maps($schema)] {
	    # someday use $color to configure color of button
	    # set color $devcolors([lindex $mappings($map) 2])
	    $m.mbar.menu add command -label $map \
		    -command "set gdata \"$map\""
	    if {$gdata == $none} {
		set gdata $map
	    }
	    if {$default == $map} {
		set defExists 1
	    }
	}
    }

    if {$default != $none && $defExists > 0} {
	set gdata $default
    }

    if {$gdata != $none} {
	$m.mbar configure -background $macroSelectedColor
    }

    if {$tdata != $none} {
	$m.mbar.menu add command -label "New..." \
		-command {
	    set sname [lindex $schemas($tdata) 0]
	    set schema [lindex $schemas($tdata) 1]
	    set mapname [DefMapping $tdata $schema]
	    if {$mapname != ""} {
		lappend maps($sname) $mapname
		# fix this: .map.gdata should be $m
		MacroDefMaps .map.gdata $mapname
		set modified 1
	    }
	}
    }
    tk_menuBar $m $m.mbar
}

############################################################

proc MacroDefViews {m default} {
    global views view modified none
    global macroSelectedColor macroUnselectedColor

    catch {destroy $m.mbar}
    catch {destroy $m.label}

    set view $none
    set defExists 0

    menubutton $m.mbar -relief raised -textvariable view \
	    -menu $m.mbar.menu -width 20 -background $macroUnselectedColor
    CreateTextBitmap $m.label view.gif View
    pack $m.label $m.mbar -side left -padx 2m
    menu $m.mbar.menu -tearoff 0
    foreach v [lsort [array names views]] {
	$m.mbar.menu add command -label $v \
		    -command "set view \"$v\""
	if {$view == $none} {
	    set view $v
	}
	if {$default == $v} {
	    set defExists 1
	}
    }

    if {$default != $none && $defExists > 0} {
	set view $default
    }

    if {$view != $none} {
	$m.mbar configure -background $macroSelectedColor
    }

    $m.mbar.menu add command -label "New..." \
	    -command {
	set viewname [DefView]
	if {$viewname != ""} {
	    # fix this: .map.view should be $m
	    MacroDefViews .map.view $viewname
	    set modified 1
	}
    }
    tk_menuBar $m $m.mbar
}

############################################################

proc MacroDefLinks {m default} {
    global links link modified none
    global macroSelectedColor macroUnselectedColor macroLinkColor

    catch {destroy $m.mbar}
    catch {destroy $m.label}

    set link $none
    set defExists 0

    menubutton $m.mbar -relief raised -textvariable link \
	    -menu $m.mbar.menu -width 20 -background $macroLinkColor
    CreateTextBitmap $m.label link.gif Link
    pack $m.label $m.mbar -side left -padx 2m
    menu $m.mbar.menu -tearoff 0
    foreach l [lsort [array names links]] {
	$m.mbar.menu add command -label $l \
		    -command "set link \"$l\"; \
		    # .map.link should be $m
		    .map.link.mbar configure -background $macroSelectedColor"
	if {$link == $none} {
	    set link $l
	}
	if {$default == $l} {
	    set defExists 1
	}
    }

    if {$default != $none && $defExists > 0} {
	set link $default
    }

    if {$link != $none} {
	$m.mbar configure -background $macroSelectedColor
    }

    $m.mbar.menu add command -label $none \
	    -command "set link \"$none\"; \
	    # .map.link should be $m
	    .map.link.mbar configure -background $macroLinkColor"

    $m.mbar.menu add command -label "New..." \
	    -command {
	set linkname [DefLink]
	if {$linkname != ""} {
	    # fix this: .map.link should be $m
	    MacroDefLinks .map.link $linkname
	    set modified 1
	}
    }
    tk_menuBar $m $m.mbar
}

############################################################

proc DefSource {} {
    global sourceList tdatas schemas maps sname

    # see if .source window already exists; if so, just return
    set err [catch {set exists [wm state .source]}]
    if {!$err} { wm deiconify .source; return }

    # ask user to select a data stream
    set sname [selectStream]

    # return if no data stream selected, or user selected
    # a data stream already on the list of streams
    if {$sname == ""} { return }
    foreach tdata $tdatas {
	set name [lindex $tdata 0]
	if {$sname == $name} {
	    return
	}
    }

    set schema [lindex $sourceList($sname) 2]
    set schemafile [lindex $sourceList($sname) 3]

    # load schema file if necessary - it is not sufficient to check if
    # the physical schema by the same name has been loaded because the same
    # physical schema may be shared by several logical schemas - the best
    # way of checking is to see that we have no groups defined under the 
    # logical schema name

    set topgrps [DEVise getTopGroups [file tail $schemafile]]
    if {[llength $topgrps] == 0} {
	set result [DEVise importFileType $schemafile]
	if {$result == ""} {
	    return
	}
	if {$result != $schema} {
	    puts "File $schemafile appears to contain schema $result,\
		    not $schema"
	    set schema $result
	}
    }

    # initialize element in schema definition array if necessary
    set err [catch {set sdef $maps($schema)}]
    if {$err > 0} {
	set maps($schema) ""
    }

    # cache data to disk right now
    if {[isCached $sname -1 -1] == ""} {
	set but [dialog .cacheData "Caching Data" \
		"Cache \"$sname\" to disk now?" \
		"" 1 Yes No]
	if {$but == 1} {
	    dialog .notCached "Must Cache Data Stream" \
		    "Cannot visualize data without caching it to disk first." \
		    "" 0 OK
	    return ""
	}
    }

    set source [cacheData $sname -1 -1]
    if {$source == ""} {
	return
    }

    statusWindow .info "Status" \
	    "Creating an index on \"$sname\".\n\n\This may take a while."

    # ask DEVise to create tdata
    puts "Adding source \"$sname\","
    puts "  file $source, schema $schema"
    set result [DEVise create tdata $schema $source $sname]
    catch {destroy .info}
    if {$result == ""} {
	dialog .fileError "File Error" \
		"Error reading file $source" "" 0 OK
	return ""
    }

    set sdef [DEVise getSchema $sname]
    lappend tdatas [list $sname $source]
    set schemas($sname) [list $schema $sdef]

    return $sname
}

############################################################

proc statusWindow {w title msg} {
    toplevel $w
    wm title $w $title
    wm geometry $w +200+200
    message $w.msg -justify center -width 8c -text $msg
    pack $w.msg -side top -padx 8m -pady 4m
    update
}

############################################################

proc DefWindow {} {
    global windows x y w h winname

    # see if .def window already exists; if so, just return
    set err [catch {set exists [wm state .def]}]
    if {!$err} { wm deiconify .def; return }

    toplevel .def
    wm title .def "Define Window"
    wm geometry .def +100+100
    selection clear .def

    set winname "Default"
    set x "0.1"
    set y "0.3"
    set w "0.5"
    set h "0.5"

    label .def.label -text "Enter window parameters"
    frame .def.win
    frame .def.but
    pack .def.label -side top -pady 3m
    pack .def.win -side top -padx 3m -fill both -expand 1
    pack .def.but -side top -pady 3m -padx 3m -fill x -expand 1

    frame .def.win.left
    frame .def.win.right
    pack .def.win.left .def.win.right -side left -fill both \
	    -expand 1

    label .def.win.left.x -text X -width 8
    label .def.win.left.y -text Y -width 8
    label .def.win.left.w -text Width -width 8
    label .def.win.left.h -text Height -width 8
    label .def.win.left.name -text Name -width 8
    pack .def.win.left.x .def.win.left.y \
	    .def.win.left.w .def.win.left.h -side top -pady 0.7m
    pack .def.win.left.name -side top -pady 3m

    entry .def.win.right.x -relief sunken -width 15 -textvariable x
    entry .def.win.right.y -relief sunken -width 15 -textvariable y
    entry .def.win.right.w -relief sunken -width 15 -textvariable w
    entry .def.win.right.h -relief sunken -width 15 -textvariable h
    entry .def.win.right.name -relief sunken -width 15 -textvariable winname
    pack .def.win.right.x .def.win.right.y \
	    .def.win.right.w .def.win.right.h -side top
    pack .def.win.right.name -side top -pady 3m

    button .def.but.ok -text OK -width 10 \
	    -command {
	if {$winname == ""} {
	    dialog .needInfo "Missing Information" \
		    "Please enter all requested information." \
		    "" 0 {OK}
	} else {
	    set err [catch {set exists $windows($winname)}]
	    if {!$err} {
		dialog .winExists "Win Exists" \
			"Window $winname exists already." \
			"" 0 {OK}
	    } else {
		destroy .def
	    }
	}
    }
    button .def.but.cancel -text Cancel -width 10 \
	    -command {
	set winname ""
	destroy .def
    }
    pack .def.but.ok .def.but.cancel -padx 3m -side left -expand 1

    tkwait visibility .def
    grab set .def
    tkwait window .def

    if {$winname != ""} {
	# ask DEVise to create window
	set winType TileLayout
	set result [DEVise create window $winType $winname $x $y $w $h]
	if {$result == ""} {
	    dialog .windowError "Window Error" \
		    "Error creating window $winname" "" 0 OK
	    return ""
	}
	set defn [list $x $y $w $h]
	set windows($winname) $defn
    }

    return $winname
}

############################################################

proc DefMapping {tdata schema} {
    global DEViseColors DEViseShapes
    global mappings devcolors devshapes
    global mapname x y color size pattern orient shape

    # see if .def window already exists; if so, just return
    set err [catch {set exists [wm state .def]}]
    if {!$err} { wm deiconify .def; return }

    toplevel .def
    wm title .def "Define Mapping"
    wm geometry .def +100+100
    selection clear .def

    set mapname "Default"

    label .def.label -text "Enter mapping parameters"
    frame .def.map
    frame .def.but
    pack .def.label -side top -pady 3m
    pack .def.map -side top -padx 3m -fill both -expand 1
    pack .def.but -side top -pady 3m -padx 3m -fill x -expand 1

    frame .def.map.left
    frame .def.map.right
    pack .def.map.left .def.map.right -side left -fill both \
	    -expand 1

    label .def.map.left.x -text X -width 8
    label .def.map.left.y -text Y -width 8
    label .def.map.left.color -text Color -width 12
    label .def.map.left.size -text Size -width 12
    label .def.map.left.pattern -text Pattern -width 12
    label .def.map.left.orient -text Orientation -width 12
    label .def.map.left.shape -text Shape -width 12
    label .def.map.left.name -text Name -width 12
    pack .def.map.left.x .def.map.left.y \
	    .def.map.left.color .def.map.left.orient \
	    .def.map.left.size .def.map.left.pattern \
	    .def.map.left.shape -side top -pady 0.7m
    pack .def.map.left.name -side top -pady 3m

    menubutton .def.map.right.x -relief raised \
	    -textvariable x -menu .def.map.right.x.menu -width 15
    menubutton .def.map.right.y -relief raised \
	    -textvariable y -menu .def.map.right.y.menu -width 15
    menubutton .def.map.right.color -relief raised \
	    -textvariable color -menu .def.map.right.color.menu -width 15
    menubutton .def.map.right.size -relief raised \
	    -textvariable size -menu .def.map.right.size.menu -width 15
    menubutton .def.map.right.pattern -relief raised \
	    -textvariable pattern -menu .def.map.right.pattern.menu -width 15
    menubutton .def.map.right.orient -relief raised \
	    -textvariable orient -menu .def.map.right.orient.menu -width 15
    menubutton .def.map.right.shape -relief raised \
	    -textvariable shape -menu .def.map.right.shape.menu -width 15
    entry .def.map.right.name -relief sunken -width 15 -textvariable mapname
    pack .def.map.right.x .def.map.right.y \
	    .def.map.right.color .def.map.right.orient \
	    .def.map.right.size .def.map.right.pattern \
	    .def.map.right.shape -side top
    pack .def.map.right.name -side top -pady 3m

    menu .def.map.right.x.menu -tearoff 0
    menu .def.map.right.y.menu -tearoff 0
    set x ""
    set y ""
    foreach attr $schema {
	set name [lindex $attr 0]
	set type [lindex $attr 1]
	set sorted [lindex $attr 2]
	.def.map.right.x.menu add radiobutton -label $name \
		-variable x -value $name
	.def.map.right.y.menu add radiobutton -label $name \
		-variable y -value $name
	if {$sorted > 0 && $name != "recId" && $x == ""} {
	    set x $name
	}
    }
    tk_menuBar .def.map.right .def.map.right.x
    tk_menuBar .def.map.right .def.map.right.y
    if {$x == ""} {
	set x [lindex [lindex $schema 0] 0]
    }
    set y [lindex [lindex $schema 1] 0]

    menu .def.map.right.color.menu -tearoff 0
    foreach color $DEViseColors {
	set idx [lindex $color 0]
	set name [lindex $color 1]
	set devcolors($name) $idx
	.def.map.right.color.menu add radiobutton -label $name \
		-variable color -value $name
    }
    tk_menuBar .def.map.right .def.map.right.color
    set color red

    menu .def.map.right.size.menu -tearoff 0
    .def.map.right.size.menu add radiobutton -label 1 \
	    -variable size -value 1
    tk_menuBar .def.map.right .def.map.right.size
    set size 1

    menu .def.map.right.pattern.menu -tearoff 0
    .def.map.right.pattern.menu add radiobutton -label 0 \
	    -variable pattern -value 0
    tk_menuBar .def.map.right .def.map.right.pattern
    set pattern 0

    menu .def.map.right.orient.menu -tearoff 0
    .def.map.right.orient.menu add radiobutton -label 0 \
	    -variable orient -value 0
    tk_menuBar .def.map.right .def.map.right.orient
    set orient 0

    menu .def.map.right.shape.menu -tearoff 0
    foreach shape $DEViseShapes {
	set idx [lindex $shape 0]
	set name [lindex $shape 1]
	set devshapes($name) $idx
	.def.map.right.shape.menu add radiobutton -label $name \
		-variable shape -value $name
    }
    tk_menuBar .def.map.right .def.map.right.shape
    set shape Bar

    button .def.but.ok -text OK -width 10 \
	    -command {
	if {$mapname == ""} {
	    dialog .needInfo "Missing Information" \
		    "Please enter all requested information." \
		    "" 0 {OK}
	} else {
	    set err [catch {set exists $mappings($mapname)}]
	    if {!$err} {
		dialog .mapExists "Mapping Exists" \
			"Mapping $mapname exists already." \
			"" 0 {OK}
	    } else {
		destroy .def
	    }
	}
    }
    button .def.but.cancel -text Cancel -width 10 \
	    -command {
	set mapname ""
	destroy .def
    }
    pack .def.but.ok .def.but.cancel -side left -padx 3m -expand 1

    tkwait visibility .def
    grab set .def
    tkwait window .def

    if {$mapname != ""} {
	set cidx $devcolors($color)
	set pidx 0
	set oidx 0
	set sidx $devshapes($shape)
	set defn [list $x $y $cidx $size $pidx $oidx $sidx "" ""]
	set mappings($mapname) $defn
    }

    return $mapname
}

############################################################

proc DefView {} {
    global views
    global xlo xhi ylo yhi color size pattern orient shape viewname
    global DEViseColors DEViseShapes
    global devcolors devshapes

    # see if .def window already exists; if so, just return
    set err [catch {set exists [wm state .def]}]
    if {!$err} { wm deiconify .def; return }

    toplevel .def
    wm title .def "Define View"
    wm geometry .def +100+100
    selection clear .def

    set viewname "Default"
    set xlo "0.0"
    set xhi "100.0"
    set ylo "0.0"
    set yhi "100.0"

    set viewParams [DEVise getparam view SortedX]
    foreach param $viewParams {
	set pname [lindex $param 0]
	set value [lindex $param 1]
	if {$pname == "xlow"} {
	    set xlo $value
	}
	if {$pname == "xhigh"} {
	    set xhi $value
	}
	if {$pname == "ylow"} {
	    set ylo $value
	}
	if {$pname == "yhigh"} {
	    set yhi $value
	}
    }

    label .def.label -text "Enter view parameters"
    frame .def.view
    frame .def.but
    pack .def.label -side top -pady 3m
    pack .def.view -side top -padx 3m -fill both -expand 1
    pack .def.but -side top -pady 3m -padx 3m -fill x -expand 1

    frame .def.view.left
    frame .def.view.right
    pack .def.view.left .def.view.right -side left -fill both \
	    -expand 1

    label .def.view.left.xlo -text "X low" -width 12
    label .def.view.left.xhi -text "X high" -width 12
    label .def.view.left.ylo -text "Y low" -width 12
    label .def.view.left.yhi -text "Y high" -width 12
    label .def.view.left.color -text Color -width 12
    label .def.view.left.size -text Size -width 12
    label .def.view.left.pattern -text Pattern -width 12
    label .def.view.left.orient -text Orientation -width 12
    label .def.view.left.shape -text Shape -width 12
    label .def.view.left.name -text Name -width 12
    pack .def.view.left.xlo .def.view.left.xhi \
	    .def.view.left.ylo .def.view.left.yhi \
	    .def.view.left.color .def.view.left.orient \
	    .def.view.left.size .def.view.left.pattern \
	    .def.view.left.shape -side top -pady 0.7m
    pack .def.view.left.name -side top -pady 3m

    entry .def.view.right.xlo -relief sunken -width 20 -textvariable xlo
    entry .def.view.right.xhi -relief sunken -width 20 -textvariable xhi
    entry .def.view.right.ylo -relief sunken -width 20 -textvariable ylo
    entry .def.view.right.yhi -relief sunken -width 20 -textvariable yhi
    menubutton .def.view.right.color -relief raised \
	    -textvariable color -menu .def.view.right.color.menu -width 20
    menubutton .def.view.right.size -relief raised \
	    -textvariable size -menu .def.view.right.size.menu -width 20
    menubutton .def.view.right.pattern -relief raised \
	    -textvariable pattern -menu .def.view.right.pattern.menu -width 20
    menubutton .def.view.right.orient -relief raised \
	    -textvariable orient -menu .def.view.right.orient.menu -width 20
    menubutton .def.view.right.shape -relief raised \
	    -textvariable shape -menu .def.view.right.shape.menu -width 20
    entry .def.view.right.name -relief sunken -width 20 -textvariable viewname
    pack .def.view.right.xlo .def.view.right.xhi \
	    .def.view.right.ylo .def.view.right.yhi \
	    .def.view.right.color .def.view.right.orient \
	    .def.view.right.size .def.view.right.pattern \
	    .def.view.right.shape -side top
    pack .def.view.right.name -side top -pady 3m

    menu .def.view.right.color.menu -tearoff 0
    foreach color $DEViseColors {
	set idx [lindex $color 0]
	set name [lindex $color 1]
	set devcolors($name) $idx
	.def.view.right.color.menu add radiobutton -label $name \
		-variable color -value $name
    }
    tk_menuBar .def.view.right .def.view.right.color
    set color red

    menu .def.view.right.size.menu -tearoff 0
    .def.view.right.size.menu add radiobutton -label 1 \
	    -variable size -value 1
    tk_menuBar .def.view.right .def.view.right.size
    set size 1

    menu .def.view.right.pattern.menu -tearoff 0
    .def.view.right.pattern.menu add radiobutton -label 0 \
	    -variable pattern -value 0
    tk_menuBar .def.view.right .def.view.right.pattern
    set pattern 0

    menu .def.view.right.orient.menu -tearoff 0
    .def.view.right.orient.menu add radiobutton -label 0 \
	    -variable orient -value 0
    tk_menuBar .def.view.right .def.view.right.orient
    set orient 0

    menu .def.view.right.shape.menu -tearoff 0
    foreach shape $DEViseShapes {
	set idx [lindex $shape 0]
	set name [lindex $shape 1]
	set devshapes($name) $idx
	.def.view.right.shape.menu add radiobutton -label $name \
		-variable shape -value $name
    }
    tk_menuBar .def.view.right .def.view.right.shape
    set shape Bar

    button .def.but.ok -text OK -width 10 \
	    -command {
	if {$viewname == ""} {
	    dialog .needInfo "Missing Information" \
		    "Please enter all requested information." \
		    "" 0 {OK}
	} else {
	    set err [catch {set exists $views($viewname)}]
	    if {!$err} {
		dialog .viewExists "View Exists" \
			"View $viewname exists already." \
			"" 0 {OK}
	    } else {
		destroy .def
	    }
	}
    }
    button .def.but.cancel -text Cancel -width 10 \
	    -command {
	set viewname ""
	destroy .def
    }
    pack .def.but.ok .def.but.cancel -padx 3m -side left -expand 1

    tkwait visibility .def
    grab set .def
    tkwait window .def

    if {$viewname != ""} {
	set defn [list $xlo $xhi $ylo $yhi white]
	set views($viewname) $defn
    }

    return $viewname
}

############################################################

proc DefLink {} {
    global links
    global x y color size pattern orient shape linkname
    global macroSelectColor

    # see if .def window already exists; if so, just return
    set err [catch {set exists [wm state .def]}]
    if {!$err} { wm deiconify .def; return }

    toplevel .def
    wm title .def "Define Link"
    wm geometry .def +100+100
    selection clear .def

    set linkname "Default"
    set x 1
    set y 0
    set color 0
    set size 0
    set pattern 0
    set orient 0
    set shape 0

    label .def.label -text "Enter link parameters"
    frame .def.link
    frame .def.name
    frame .def.but
    pack .def.label -side top -pady 3m
    pack .def.link -side top -padx 3m -fill both -expand 1
    pack .def.name -side top -padx 3m -fill x -expand 1
    pack .def.but -side top -pady 3m -padx 3m -fill x -expand 1

    checkbutton .def.link.x -text X -variable x -anchor w \
	    -indicatoron 0 -selectcolor $macroSelectColor
    checkbutton .def.link.y -text Y -variable y -anchor w \
	    -indicatoron 0 -selectcolor $macroSelectColor
    checkbutton .def.link.color -text Color -variable color -anchor w \
	    -indicatoron 0 -selectcolor $macroSelectColor
    checkbutton .def.link.size -text Size -variable size -anchor w \
	    -indicatoron 0 -selectcolor $macroSelectColor
    checkbutton .def.link.pattern -text Pattern -variable pattern -anchor w \
	    -indicatoron 0 -selectcolor $macroSelectColor
    checkbutton .def.link.orient -text Orientation \
	    -variable orient -anchor w \
	    -indicatoron 0 -selectcolor $macroSelectColor
    checkbutton .def.link.shape -text Shape -variable shape -anchor w \
	    -indicatoron 0 -selectcolor $macroSelectColor
    pack .def.link.x .def.link.y .def.link.color .def.link.orient \
	    .def.link.size .def.link.pattern .def.link.shape \
	    -side top -fill x -expand 1

    label .def.name.label -text "Name"
    entry .def.name.name -relief sunken -textvariable linkname
    pack .def.name.label -side left -pady 3m -padx 3m
    pack .def.name.name -side right -pady 3m -fill x -expand 1

    button .def.but.ok -text OK -width 10 \
	    -command {
	if {$linkname == ""} {
	    dialog .needInfo "Missing Information" \
		    "Please enter all requested information." \
		    "" 0 {OK}
	} else {
	    set err [catch {set exists $links($linkname)}]
	    if {!$err} {
		dialog .linkExists "Link Exists" \
			"Link $linkname exists already." \
			"" 0 {OK}
	    } else {
		destroy .def
	    }
	}
    }
    button .def.but.cancel -text Cancel -width 10 \
	    -command {
	set linkname ""
	destroy .def
    }
    pack .def.but.ok .def.but.cancel -side left -padx 3m -expand 1

    tkwait visibility .def
    grab set .def
    tkwait window .def

    if {$linkname != ""} {
	# ask DEVise to create link
	set flag [expr $x | ($y << 1) | ($color << 2) | ($size << 3) | \
		       ($pattern << 4) | ($orient << 5) | ($shape << 6)]
	set result [DEVise create link Visual_Link $linkname $flag]
	if {$result == ""} {
	    dialog .linkError "Link Error" \
		    "Error creating link $linkname" "" 0 OK
	    return ""
	}
	set links($linkname) $flag
    }

    return $linkname
}

############################################################

proc CreateBitmapButton2 {w file title command} {
    global libdir

    button $w -command $command

    frame $w.stack -relief raised -bd 2

    pack $w.stack

    # create a button for the image
    label $w.stack.img -image [image create photo -file $libdir/$file] \
	    -bd 0 -relief flat -padx 1 -pady 1

    pack $w.stack.img

    # create a button for the title
    label $w.stack.title -text $title \
	-bd 0 -relief flat -font 6x10 \
	-padx 1 -pady 1
    
    pack $w.stack.title

    return $w
}

############################################################

proc CreateBitmapButton {w file title command {width 20m} {height 21m}} {
    global libdir

    frame $w -relief raised -bd 2 -width $width -height $height
    bind $w <Button-1> $command

    # create a button for the image
    button $w.img -image [image create photo -file $libdir/$file] \
	-bd 0 -relief flat -command $command

    # create a button for the title
    button $w.title -text $title -bd 0 -relief flat -command $command
    
    pack propagate $w 0
    pack $w.img $w.title -side top -padx 1 -pady 1

    return $w
}

############################################################

proc CreateTextBitmap {w file title {width 20m} {height 17m}} {
    global libdir

    frame $w -width $width -height $height

    # create a button for the image
    label $w.img -image [image create photo -file $libdir/$file] \
	-bd 0 -relief flat

    # create a button for the title
    label $w.title -text $title -bd 0 -relief flat
    
    pack propagate $w 0
    pack $w.img $w.title -side top -padx 1 -pady 1

    return $w
}

############################################################

proc CreateTitleBitmap {w file title {height 16m}} {
    global libdir

    frame $w -height $height
    frame $w.top
    pack $w.top -side top

    # create a button for the image
    label $w.img -image [image create photo -file $libdir/$file] \
	-bd 0 -relief flat -padx 1 -pady 1

    # create a button for the title
    label $w.title -text $title -bd 0 -relief flat -padx 1 -pady 1
    
    pack $w.img $w.title -in $w.top -side left -padx 8

    return $w
}

############################################################

proc CreateBitmapMenuButton { w file varname } {
    upvar varname var
    global libdir

    frame $w -relief raised -bd 2

    # create a button for the image
    button $w.img -image [image create photo -file $libdir/$file] \
	-bd 0 -relief flat -command $command

    pack $w.img

    # create a button for the title
    button $w.title -text $title \
	-bd 0 -relief flat -font 6x10 \
	-padx 1 -pady 1 \
	-command $command
    
    pack $w.title

    return $w
}

# Procedure for displaying Y coordinates in Auto mode

proc selYAuto {grpname topgrp} {
    global yvar macroSelectColor schemaname

    # Check if the window already exists
    set err [catch {set exists [wm state .selY$grpname]}]
    if {!$err} {wm deiconify .selY$grpname; return}

    # Create new window
    toplevel .selY$grpname
    wm title .selY$grpname "Group: $grpname"
    wm geometry .selY$grpname +100+100
	
    label .selY$grpname.label -text "Select Y parameters"
    frame .selY$grpname.sel -relief groove -borderwidth 2
    frame .selY$grpname.but 
    pack .selY$grpname.label -side top -pady 2m -fill x -expand 1
    pack .selY$grpname.sel -side top -pady 2m -fill x -expand 1
    pack .selY$grpname.but -side top -pady 2m -fill x -expand 1
    
    # Call function to set up buttons
    setupButtons .selY$grpname.sel $grpname $topgrp
    
    button .selY$grpname.but.ok -text OK -width 20 -command \
	    [format "destroy .selY%s" $grpname]
    
    pack .selY$grpname.but.ok -side top -expand 1 -padx 3m
}
			
proc setupButtons {win grpname topgrp} {
    global yvar macroSelectColor schemaname

    set row -1
    set col -1
    set maxcol 1
    set varcnt 0

    # We will do some preprocessing to figure out how to display the
    # the attributes - i.e. how many columns per row, size of menu
    # buttons and the size of the window itself.
    
    set grplist [DEVise getItems $schemaname $topgrp $grpname]

    # Find the max width of the attrs and the number of attrs
    set numattrs 0
    set maxwidth 0
    foreach itm $grplist {
	set subname [lindex $itm 0]
	set width [llength [split $subname {}]]
	if {$width > $maxwidth} {
	    set maxwidth $width
	}
	incr numattrs
    }

    if {$maxwidth > 15} {
	set maxcol 1
	set colwidth [expr $maxwidth + 2]
    } else {
	set maxcol 5
	set colwidth 15
    }
    
    foreach itm $grplist {
	set subname [lindex $itm 0]
	set type [lindex $itm 1]
	if {$col < 0} {
	    incr row
	    set col 0
	    frame $win.row$row
	    pack $win.row$row -side top -fill x \
		    -expand 1
	}
	if {$type != "intr"} {
	    checkbutton $win.row$row.col$col \
		    -text $subname -variable yvar($subname) \
		    -width $colwidth -anchor w -indicatoron 0 \
		    -selectcolor $macroSelectColor
	    set yvar($subname) 0
	} else {
	    button $win.row$row.col$col \
		    -text $subname -width $colwidth \
		    -bg darkslategray4  -fg wheat \
		    -command \
		    [format "selYAuto %s %s" $subname $topgrp] 
	}
	pack $win.row$row.col$col -side left \
		-fill x -expand 1
	incr col
	if {$col >= $maxcol} {
	    set col -1
	}
    }

    #Add empty frames at end of last row
    for {} {$row >= 0 && $col >= 0 && $col < $maxcol} {incr col} {
	label $win.row$row.col$col -text "" \
		-width $colwidth -relief flat -borderwidth 4
	pack $win.row$row.col$col -side left -fill x \
		-expand 1
    }
}

############################################################

# Initialize the macro definition utility
MacroDefInit
