#  ========================================================================
#  DEVise Data Visualization Software
#  (c) Copyright 1992-1995
#  By the DEVise Development Group
#  Madison, Wisconsin
#  All Rights Reserved.
#  ========================================================================
#
#  Under no circumstances is this software to be copied, distributed,
#  or altered in any way without prior permission from the DEVise
#  Development Group.

############################################################

#	$Id$

#
#	Revision 1.6  1995/09/28 17:44:03  jussi
#	Included size, pattern, and orientation in all mapping definitions
#	although these are not used by DEVise currently. Minor other
#	touch-ups.
#
#	Revision 1.5  1995/09/27 17:20:34  ravim
#	Added support for groups in schemas.
#
#	Revision 1.4  1995/09/26 23:09:02  jussi
#	Added color/shape/size/pattern/orientation settings to view
#	definition.
#
#	Revision 1.3  1995/09/22 17:33:47  jussi
#	Added copyright message.
#
#	Revision 1.2  1995/09/21 15:36:27  jussi
#	Added small icons.
#
#	Revision 1.1  1995/09/13 14:24:07  jussi
#	Extracted macro definition code from control.tk.

############################################################

proc MacroDefInit {} {
    global macroSelectedColor macroUnselectedColor macroLinkColor
    global macroSelectColor macroMenuSelectColor macroActiveColor

    set macroSelectedColor LightBlue
    set macroUnselectedColor LightPink
    set macroLinkColor LightBlue
    set macroSelectColor #e6ceb1
    set macroMenuSelectColor white
    set macroActiveColor #e6ceb1

    MacroDefClear
}

############################################################

proc MacroDefStart {} {
    global tdatas schemas maps mappings views links windows modified

    # see if .map window already exists; if so, just return
    set err [catch {set exists [wm state .map]}]
    if {!$err} { wm deiconify .map; return }

    # clear tdatas, schemas, windows, and links because they can be
    # reconstructed from DEVise data structures; maps, mappings,
    # and views cannot be safely reconstructed
    
    set tdatas ""
    catch {unset schemas}
    catch {unset links}
    catch {unset windows}

    # the following are required for the old Tcl to work properly;
    # these define arrays with zero elements

    set schemas(a) a
    unset schemas(a)
    set links(a) a
    unset links(a)
    set windows(a) a
    unset windows(a)

    foreach schema [DEVise get tdata] {
	set err [catch {set exists $maps($schema)}]
	if {$err > 0} { set maps($schema) "" }
	foreach tdata [DEVise get tdata $schema] {
	    set params [DEVise getCreateParam tdata $schema $tdata]
	    set filePath [lindex $params 0]
	    set fileAlias [lindex $params 1]
	    lappend tdatas [list $fileAlias $filePath]
	    set sdef [DEVise getSchema $tdata]
	    set schemas($tdata) [list $schema $sdef]
	}
    }

    foreach class [lsort [DEVise get "mapping"]] {
	foreach mapping [lsort [DEVise get "mapping" $class]] {
	    set params [DEVise getCreateParam "mapping" $class $mapping]
	    set tdata [lindex $params 0]
	    set schema [lindex $schemas($tdata) 0]
	    set mapname [lindex $params 1]
	    set firsthash [string first \# $mapname]
	    if {$firsthash >= 0} {
		incr firsthash
		set mapname [string range $mapname $firsthash end]
	    }
	    set x [string range [lindex $params 3] 1 end]
	    set y [string range [lindex $params 4] 1 end]
	    set color [lindex $params 5]
	    set size [lindex $params 6]
	    set pattern [lindex $params 7]
	    set orient [lindex $params 8]
	    set shape [lindex $params 9]
	    set defn [list $x $y $color $size $pattern $orient $shape]
	    
	    set mappings($mapname) $defn
	    if {[string first $mapname $maps($schema)] < 0} {
		lappend maps($schema) $mapname
	    }
	}
    }

    foreach class [lsort [DEVise get "window"]] {
	foreach window [lsort [DEVise get "window" $class]] {
	    set params [DEVise getCreateParam "window" $class $window]
	    set name [lindex $params 0]
	    set windows($name) [lrange $params 1 end]
	}
    }

    foreach class [lsort [DEVise get "link"]] {
	foreach link [lsort [DEVise get "link" $class]] {
	    set params [DEVise getCreateParam "link" $class $link]
	    set name [lindex $params 0]
	    set links($name) [lrange $params 1 end]
	}
    }

    foreach class [lsort [DEVise get "view"]] {
	foreach view [lsort [DEVise get "view" $class]] {
	    set params [DEVise getCreateParam "view" $class $view]
	    set name [lindex $params 0]
	    set firsthash [string first \# $name]
	    if {$firsthash < 0} { continue }
	    incr firsthash
	    set name [string range $name $firsthash end]
	    set secondhash [string first \# $name]
	    if {$secondhash >= 0} {
		incr secondhash -1
		set name [string range $name 0 $secondhash]
	    }
	    set views($name) [lrange $params 1 end]
	}
    }

    set modified 0
    MacroDef
}

############################################################

proc MacroDef {} {
    global tdatas schemas maps mappings views links windows
    global tdata window gdata view link none

    # see if .map window already exists; if so, just return
    set err [catch {set exists [wm state .map]}]
    if {!$err} { wm deiconify .map; return }

    set none "-- None --"

    toplevel .map
    wm title .map "Define Visualization"
    wm minsize .map 600 250
    wm maxsize .map 800 400
    wm geometry .map =600x320+50+50
    selection clear .map

    frame .map.top
    frame .map.but
    pack .map.top -side top -pady 3m -fill both -expand 1
    pack .map.but -side top -pady 5m -fill x

    button .map.but.close -text Close -width 10 -command {
	destroy .map
    }
    button .map.but.create -text Create -width 10 -command {
	MacroDefNewMapping
    }
    button .map.but.auto -text "Auto..." -width 10 -command {
	MacroDefAuto $tdata
    }

    CreateBitmapButton .map.but.help help.gif Help MacroDefHelp
#    button .map.but.help -text Help -width 40 -command MacroDefHelp
    pack .map.but.close .map.but.create .map.but.auto .map.but.help \
	    -side left -padx 7m

    frame .map.left -relief groove -borderwidth 2
    frame .map.right -relief groove -borderwidth 2
    pack .map.left .map.right -in .map.top -side left \
	    -fill both -expand 1

    frame .map.tdata
    frame .map.window
    frame .map.gdata
    frame .map.view
    frame .map.link
    pack .map.tdata .map.window -in .map.left -side top -pady 3m \
	    -fill both -expand 1
    pack .map.gdata .map.view .map.link -in .map.right -side top -pady 3m \
	    -fill both -expand 1

    MacroDefTdata .map.tdata "$none"
    MacroDefWindows .map.window "$none"
    MacroDefMaps .map.gdata "$none"
    MacroDefViews .map.view "$none"
    MacroDefLinks .map.link "$none"

    tkwait visibility .map
}

############################################################

proc MacroDefNewMapping {} {
    global tdatas schemas maps mappings views links windows
    global tdata window gdata view link none

    if {$tdata == $none || $window == $none \
	|| $gdata == $none || $view == $none} {
	dialog .createError "Note" \
		"Please select a data source, a window,\n\
		a mapping and a view and then press Create." \
		"" 0 OK
	return
    }

    set x [lindex $mappings($gdata) 0]
    set y [lindex $mappings($gdata) 1]
    set color [lindex $mappings($gdata) 2]
    set size [lindex $mappings($gdata) 3]
    set pattern [lindex $mappings($gdata) 4]
    set orient [lindex $mappings($gdata) 5]
    set shape [lindex $mappings($gdata) 6]

    # ask DEVise to create view instance
    set sorted SortedX
    set viewname $tdata#$view#$x#$y
    if {[lsearch [ViewSet] $viewname] >= 0} {
	dialog .viewError "View Error" \
		"View $viewname exists already." "" 0 OK
	return
    }
    set cmd [concat DEVise create view $sorted \{$viewname\} $views($view)]
    # puts "cmd = $cmd"
    set result [eval $cmd]
    if {$result == ""} {
	dialog .viewError "View Error" \
		"Error creating view $viewname" "" 0 OK
	return
    }

    if {[lsearch [DEVise get mapping] $gdata] < 0} {
	# ask DEVise to create interpreted mapping
	# parameter format: x y color size pattern orientation shape
	set result [DEVise createInterp $tdata $gdata "" \$$x \$$y \
		$color $size $pattern $orient $shape "" ""]
    }

    set mapinstance "$tdata#$gdata" 
    if {[lsearch [GdataSet] $mapinstance] < 0} {
	# ask DEVise to create an instance of mapping
	set result [DEVise create mapping $gdata $tdata $mapinstance \
		"" \$$x \$$y $color $size $pattern $orient $shape "" ""]
	DEVise setPixelWidth $mapinstance 1
    }

    # ask DEVise to insert $viewname into $mapinstance
    set result [DEVise insertMapping $viewname $mapinstance]
    # seems that there's no error code returned

    # ask DEVise to insert $viewname into $window
    set result [DEVise insertWindow $viewname $window]
    # seems that there's no error code returned

    if {$link != $none} {
	# ask DEVise to link $viewname to $link
	set result [DEVise insertLink $link $viewname]
	# seems that there's no error code returned
    }

    ProcessViewSelected $viewname

    # DoToggleAxis X
    DoToggleAxis Y
}

############################################################

proc MacroDefClear {} {
    global tdatas schemas maps mappings views links windows

    set tdatas ""

    catch {unset schemas}
    catch {unset maps}
    catch {unset mappings}
    catch {unset views}
    catch {unset links}
    catch {unset windows}
}

############################################################

proc MacroDefHelp {} {
    # see if .help window already exists; if so, just return
    set err [catch {set exists [wm state .help]}]
    if {!$err} { wm deiconify .help; return }

    toplevel .help
    wm title .help "Help"
    wm geometry .help +100+100
    message .help.msg -justify center -width 10c \
	    -text "You can create a new visualization by selecting\
	           a data source, window, mapping, and view, and then\
		   pressing Create. To select any of these items, pull\
		   down the corresponding menu and select an existing\
		   item from the menu, or select New to create a new\
		   item.\n\n\
		   From the Link menu you can choose an existing link\
		   to link the new visualization to existing\
		   visualizations,\
		   or you can create a new link by choosing the New\
		   item from the Link menu, or you can leave the new\
		   visualization unlinked by choosing None.\n\n\
		   To create automatic views, select a data source and\
		   then press Auto. Select the attribute you want on the\
		   X axis and the set of attributes you want on the Y\
		   axis. Click OK, and you will see a new window with\
		   the views you selected. All views are linked on the\
		   X axis.\n\n\
		   Click on Close when you're done."
    button .help.ok -text OK -width 10 -command "destroy .help"
    pack .help.msg .help.ok -side top -padx 5m -pady 3m

    tkwait visibility .help
}

############################################################

proc MacroDefAuto {tdata} {
    global schemas modified x xtype sortedx yvar selgrp schema
    global macroSelectColor macroMenuSelectColor

    # see if .auto window already exists; if so, just return
    set err [catch {set exists [wm state .auto]}]
    if {!$err} { wm deiconify .auto; return }

    toplevel .auto
    wm title .auto "Automatic Views"
    wm geometry .auto +100+100
    selection clear .auto

    label .auto.label -text "Select Auto Parameters"
    frame .auto.xsel -relief groove -borderwidth 2
    frame .auto.ysel -relief groove -borderwidth 2
    frame .auto.but
    pack .auto.label -side top -pady 3m -fill x -expand 1
    pack .auto.xsel -side top -pady 3m -ipady 5m -ipadx 5m
    pack .auto.ysel -side top -pady 3m -fill x -expand 1
    pack .auto.but -side top -pady 3m -fill x -expand 1

    label .auto.xsel.label -text "Select X" -width 15
    menubutton .auto.xsel.attr -relief raised \
	    -textvariable x -menu .auto.xsel.attr.$selgrp -width 15
    pack .auto.xsel.label -side left
    pack .auto.xsel.attr -side left

    label .auto.ysel.label -text "Select Y" -width 15
    pack .auto.ysel.label -side top -fill x -expand 1 -pady 3m

    #  For selecting Y attrs - a button here will pop up a new window
    # containing a list of name from which a selection can be made
    button .auto.ysel.sel -text "Attributes from Group : $selgrp" \
           -command {selYAuto $selgrp}
    pack .auto.ysel.sel -side top -fill x -expand 1 -pady 3m


    # Have a list containing the name of the selected group.
    # In every iteration of the loop, create a menu with the name ending
    # with the group name.
    set addname($selgrp) .auto.xsel.attr.$selgrp
    set grplist $selgrp
    while {[llength $grplist] > 0} {
	set grpname [lindex $grplist 0]
	set grplist [lreplace $grplist 0 0]
	menu $addname($grpname) -tearoff 0
	set subgrps [DEVise getItems $grpname]
        foreach sub $subgrps {
		set subname [lindex $sub 0]
		if {[lindex $sub 1] != "intr"} {
			$addname($grpname) add radiobutton \
				-label $subname -variable x -value $subname 
		} else {
			$addname($grpname) add cascade \
				-label $subname \
				-menu $addname($grpname).$subname
			set grplist [linsert $grplist 0 $subname]
			set addname($subname) $addname($grpname).$subname
		}
	}
    }


#    menu .auto.xsel.attr.menu -tearoff 0

    set sname [lindex $schemas($tdata) 0]
    set schema [ElimStringAttr [lindex $schemas($tdata) 1]]
    set x ""
    set xtype ""
    set sortedx 0

#    set row -1
#    set col -1
#    set maxcol 4
#    set varcnt 0

#    foreach attr $schema {
#	set name [lindex $attr 0]
#	set type [lindex $attr 1]
#	set sorted [lindex $attr 2]
#	.auto.xsel.attr.menu add radiobutton -label $name \
#		-variable x -value $name
#	if {$sorted > 0 && $name != "recId" && $x == ""} {
#	    set x $name
#	    set xtype $type
#	    set sortedx $sorted
#	}
#	if {$col < 0} {
#	    incr row
#	    set col 0
#	    frame .auto.ysel.row$row
#	    pack .auto.ysel.row$row -side top -fill x -expand 1
#	}
#	checkbutton .auto.ysel.row$row.col$col -text $name \
#		-variable yvar($name) -width 15 -anchor w \
#		-indicatoron 0 -selectcolor $macroSelectColor
#	set yvar($name) 0
#	pack .auto.ysel.row$row.col$col -side left -fill x -expand 1
#	incr col
#	if {$col >= $maxcol} {
#	    set col -1
#	}
#    }

    # add empty frame to end of last row so that existing buttons
    # on that row won't get expanded more than buttons on other
    # (full) rows
#    for {} {$row >= 0 && $col >= 0 && $col < $maxcol} {incr col} {
#	label .auto.ysel.row$row.col$col -text "" -width 15 \
#		-relief flat -borderwidth 4
#	pack .auto.ysel.row$row.col$col -side left -fill x -expand 1
#    }

    if {$x == ""} {
	set x [lindex [lindex $schema 0] 0]
	set xtype [lindex [lindex $schema 0] 1]
	set sortedx [lindex [lindex $schema 0] 2]
    }


    tk_menuBar .auto.xsel .auto.xsel.attr

    button .auto.but.ok -text OK -width 20 -command {
	set ylist ""
	foreach yname [array names yvar] {
	    if {$yvar($yname) > 0} {
		lappend ylist $yname
	    }
	}
	if {$ylist == ""} {
	    dialog .autoError "Note" \
		    "Please select one or more\n\
		    Y attributes for automatic\n\
		    mapping." "" 0 OK
	} else {
            # We have the correct value for x only - need to find 
            # out the values for xtype and sortedx before calling
            # this function
            foreach attr $schema {
                 set name [lindex $attr 0]
                 if {$name != $x} {continue}
                 set xtype [lindex $attr 1]
                 set sortedx [lindex $attr 2]
                 break
            }
            puts "The value of x is $x"
            puts "The value of xtype is $xtype"
            puts "The value of sortedx is $sortedx"
	    puts "The ylist is $ylist"
	    MacroDefAutoActual $tdata $x $xtype $sortedx $ylist
	    destroy .auto
	}
    }
    button .auto.but.cancel -text Cancel -width 20 -command {
	destroy .auto
    }
    pack .auto.but.ok .auto.but.cancel -side left -expand 1

    tkwait visibility .auto
}

############################################################

proc MacroDefAutoActual {tdata x xtype sortedx ylist} {
    global schemas maps mappings views links windows modified none
    global viewDefault

    set window [format "%s (Auto)" $tdata]
    set err [catch {set exists $windows($window)}]
    if {$err > 0} {
	# ask DEVise to create window
	set winType WinVertical
	set result [DEVise create window $winType $window 0.3 0.0 0.5 0.95]
	if {$result == ""} {
	    dialog .windowError "Window Error" \
		    "Error creating window $window" "" 0 OK
	    return
	}
	set windows($window) {0.3 0.0 0.5 0.95}
    }
    
    if {$sortedx > 0} {
	set sortedx SortedX
    } else {
	set sortedx Scatter
    }

    # should scan x in file and compute xlo and xhi

    set xlo 0.0
    set xhi 1000.0
    set bgColor white

    set viewParams ""
    catch { set viewParams $viewDefault($xtype) }
    foreach param $viewParams {
	set pname [lindex $param 0]
	set value [lindex $param 1]
	if {$pname == "xlow"} {
	    set xlo $value
	}
	if {$pname == "xhigh"} {
	    set xhi $value
	}
    }
    # puts "Auto mappings will have xlo $xlo and xhi $xhi"

    set linkname [format "%s Link" $x]
    set err [catch {set exists $links($linkname)}]
    if {$err > 0} {
	# ask DEVise to create link
	set result [DEVise create link Visual_Link $linkname 1]
	if {$result == ""} {
	    dialog .linkError "Link Error" \
		    "Error creating link $linkname" "" 0 OK
	    return
	}
	set flag 1
	set links($linkname) $flag
    }

    set sname [lindex $schemas($tdata) 0]
    set schema [ElimStringAttr [lindex $schemas($tdata) 1]]
    set color 2
    set shape 2
    set size 1
    set pattern 0
    set orient 0

    foreach attr $schema {
	set name [lindex $attr 0]
	set type [lindex $attr 1]
	set sorted [lindex $attr 2]
	if {[lsearch $ylist $name] < 0} { continue }

	puts "Creating mapping for $name"

	set mapname [format "%s_vs_%s" $name $x]
	set err [catch {set exists $mappings($mapname)}]
	if {$err > 0} {
	    set defn [list $x $name $color $size $pattern $orient $shape]
	    set mappings($mapname) $defn
	    lappend maps($sname) $mapname
	}

	# should scan y in file and compute ylo and yhi for each view

	set ylo 0.0
	set yhi 100.0

	set viewParams ""
	catch {	set viewParams $viewDefault($type) }
	foreach param $viewParams {
	    set pname [lindex $param 0]
	    set value [lindex $param 1]
	    if {$pname == "ylow"} {
		set ylo $value
	    }
	    if {$pname == "yhigh"} {
		set yhi $value
	    }
	}

	set viewname [format "%s View" $name]
	set err [catch {set exists $views($viewname)}]
	if {$err > 0} {
	    set defn [list $xlo $xhi $ylo $yhi $bgColor]
	    set views($viewname) $defn
	}

	# ask DEVise to create view instance
	set sorted $sortedx
	set viewinstance "$tdata#$viewname#$x#$name"
	if {[lsearch [ViewSet] $viewinstance] >= 0} {
	    dialog .viewError "View Error" \
		    "View $viewinstance exists already." "" 0 OK
	    return
	}
	set result [DEVise create view $sorted $viewinstance \
		$xlo $xhi $ylo $yhi $bgColor]
	if {$result == ""} {
	    dialog .viewError "View Error" \
		    "Error creating view $viewinstance" "" 0 OK
	    return
	}
	
	if {[lsearch [DEVise get mapping] $mapname] < 0} {
	    # ask DEVise to create interpreted mapping
	    # parameter format: x y color size pattern orientation shape
	    set result [DEVise createInterp $tdata $mapname "" \$$x \$$name \
		    $color $size $pattern $orient $shape "" ""]
	}

	set mapinstance "$tdata#$mapname"
	if {[lsearch [GdataSet] $mapinstance] < 0} {
	    # ask DEVise to create an instance of mapping
	    set result [DEVise create mapping $mapname $tdata $mapinstance \
		    "" \$$x \$$name $color $size $pattern $orient $shape "" ""]
	    DEVise setPixelWidth $mapinstance 1
	} else {
	    puts "$mapinstance exists already -- not creating"
	}

	# ask DEVise to insert $viewinstance into $mapinstance
	set result [DEVise insertMapping $viewinstance $mapinstance]
	# seems that there's no error code returned

	# ask DEVise to insert $viewinstance into $window
	set result [DEVise insertWindow $viewinstance $window]
	# seems that there's no error code returned

	# ask DEVise to link $viewinstance to $linkname
	set result [DEVise insertLink $linkname $viewinstance]
	# seems that there's no error code returned

	DEVise clearViewHistory $viewinstance
	DEVise insertViewHistory $viewinstance $xlo $ylo $xhi $yhi 0

	ProcessViewSelected $viewinstance
	# DoToggleAxis X
	DoToggleAxis Y

	incr color
    }

    MacroDefWindows .map.window $none
    MacroDefMaps .map.gdata $none
    MacroDefViews .map.view $none
    MacroDefLinks .map.link $none

    set modified 1
}

############################################################

proc MacroDefTdata {m default} {
    global tdatas tdata modified none
    global macroSelectedColor macroUnselectedColor macroActiveColor

    catch {destroy $m.mbar}
    catch {destroy $m.label}

    set tdata $none
    set defExists 0

    menubutton $m.mbar -relief raised -textvariable tdata \
	    -menu $m.mbar.menu -width 20 -background $macroUnselectedColor \
	    -activebackground $macroActiveColor
    CreateTextBitmap $m.label file.gif Source
    pack $m.label $m.mbar -side left -padx 2m
    menu $m.mbar.menu -tearoff 0
    foreach t $tdatas {
	set name [lindex $t 0]
	$m.mbar.menu add command -label $name \
		-command "set tdata \"$name\"; \
		          MacroDefMaps .map.gdata \"$none\""
	if {$tdata == $none} {
	    set tdata $name
	}
	if {$default == $name} {
	    set defExists 1
	}
    }

    if {$default != $none && $defExists > 0} {
	set tdata $default
    }

    if {$tdata != $none} {
	# fix: .map.but.auto should be a parameter
	.map.but.auto configure -state normal
	$m.mbar configure -background $macroSelectedColor \
		-activebackground $macroActiveColor
    } else {
	.map.but.auto configure -state disabled
    }

    $m.mbar.menu add command -label "Open..." \
	    -command {
	set sname [DefSource]
	if {$sname != ""} {
	    # fix this: .map.tdata should be $m
	    MacroDefTdata .map.tdata $sname
	    MacroDefMaps .map.gdata $none
	    set modified 1
	}
    }
    tk_menuBar $m $m.mbar
}

############################################################

proc MacroDefWindows {m default} {
    global windows window modified none
    global macroSelectedColor macroUnselectedColor
    global libdir

    catch {destroy $m.mbar}
    catch {destroy $m.label}

    set window $none
    set defExists 0

    menubutton $m.mbar -relief raised -textvariable window \
	    -menu $m.mbar.menu -width 20 \
	    -background $macroUnselectedColor
    CreateTextBitmap $m.label window.gif Window
    pack $m.label $m.mbar -side left -padx 2m
    menu $m.mbar.menu -tearoff 0
    foreach win [lsort [array names windows]] {
	$m.mbar.menu add command -label $win \
		-command "set window \"$win\""
	if {$window == $none} {
	    set window $win
	}
	if {$default == $win} {
	    set defExists 1
	}
    }

    if {$default != $none && $defExists > 0} {
	set window $default
    }

    if {$window != $none} {
	$m.mbar configure -background $macroSelectedColor
    }

    $m.mbar.menu add command -label "New..." \
	    -command {
	set winname [DefWindow]
	if {$winname != ""} {
	    # fix this: .map.window should be $m
	    MacroDefWindows .map.window $winname
	    set modified 1
	}
    }
    tk_menuBar $m $m.mbar
}

############################################################

proc MacroDefMaps {m default} {
    global schemas maps mappings tdata gdata modified none DEViseColors
    global macroSelectedColor macroUnselectedColor

    catch {destroy $m.mbar}
    catch {destroy $m.label}

    set gdata $none
    set defExists 0

    foreach color $DEViseColors {
	set idx [lindex $color 0]
	set name [lindex $color 1]
	set devcolors($idx) $name
    }

    menubutton $m.mbar -relief raised -textvariable gdata \
	    -menu $m.mbar.menu -width 20 -background $macroUnselectedColor
    if {$tdata != $none} {
	$m.mbar configure -state normal
    } else {
	$m.mbar configure -state disabled
    }
    CreateTextBitmap $m.label chart.gif Mapping
    pack $m.label $m.mbar -side left -padx 2m
    menu $m.mbar.menu -tearoff 0
    if {$tdata != $none} {
	set schema [lindex $schemas($tdata) 0]
	foreach map [lsort $maps($schema)] {
	    # someday use $color to configure color of button
	    # set color $devcolors([lindex $mappings($map) 2])
	    $m.mbar.menu add command -label $map \
		    -command "set gdata \"$map\""
	    if {$gdata == $none} {
		set gdata $map
	    }
	    if {$default == $map} {
		set defExists 1
	    }
	}
    }

    if {$default != $none && $defExists > 0} {
	set gdata $default
    }

    if {$gdata != $none} {
	$m.mbar configure -background $macroSelectedColor
    }

    if {$tdata != $none} {
	$m.mbar.menu add command -label "New..." \
		-command {
	    set sname [lindex $schemas($tdata) 0]
	    set schema [lindex $schemas($tdata) 1]
	    set mapname [DefMapping $tdata $schema]
	    if {$mapname != ""} {
		lappend maps($sname) $mapname
		# fix this: .map.gdata should be $m
		MacroDefMaps .map.gdata $mapname
		set modified 1
	    }
	}
    }
    tk_menuBar $m $m.mbar
}

############################################################

proc MacroDefViews {m default} {
    global views view modified none
    global macroSelectedColor macroUnselectedColor

    catch {destroy $m.mbar}
    catch {destroy $m.label}

    set view $none
    set defExists 0

    menubutton $m.mbar -relief raised -textvariable view \
	    -menu $m.mbar.menu -width 20 -background $macroUnselectedColor
    CreateTextBitmap $m.label view.gif View
    pack $m.label $m.mbar -side left -padx 2m
    menu $m.mbar.menu -tearoff 0
    foreach v [lsort [array names views]] {
	$m.mbar.menu add command -label $v \
		    -command "set view \"$v\""
	if {$view == $none} {
	    set view $v
	}
	if {$default == $v} {
	    set defExists 1
	}
    }

    if {$default != $none && $defExists > 0} {
	set view $default
    }

    if {$view != $none} {
	$m.mbar configure -background $macroSelectedColor
    }

    $m.mbar.menu add command -label "New..." \
	    -command {
	set viewname [DefView]
	if {$viewname != ""} {
	    # fix this: .map.view should be $m
	    MacroDefViews .map.view $viewname
	    set modified 1
	}
    }
    tk_menuBar $m $m.mbar
}

############################################################

proc MacroDefLinks {m default} {
    global links link modified none
    global macroSelectedColor macroUnselectedColor macroLinkColor

    catch {destroy $m.mbar}
    catch {destroy $m.label}

    set link $none
    set defExists 0

    menubutton $m.mbar -relief raised -textvariable link \
	    -menu $m.mbar.menu -width 20 -background $macroLinkColor
    CreateTextBitmap $m.label link.gif Link
    pack $m.label $m.mbar -side left -padx 2m
    menu $m.mbar.menu -tearoff 0
    foreach l [lsort [array names links]] {
	$m.mbar.menu add command -label $l \
		    -command "set link \"$l\"; \
		    # .map.link should be $m
		    .map.link.mbar configure -background $macroSelectedColor"
	if {$link == $none} {
	    set link $l
	}
	if {$default == $l} {
	    set defExists 1
	}
    }

    if {$default != $none && $defExists > 0} {
	set link $default
    }

    if {$link != $none} {
	$m.mbar configure -background $macroSelectedColor
    }

    $m.mbar.menu add command -label $none \
	    -command "set link \"$none\"; \
	    # .map.link should be $m
	    .map.link.mbar configure -background $macroLinkColor"

    $m.mbar.menu add command -label "New..." \
	    -command {
	set linkname [DefLink]
	if {$linkname != ""} {
	    # fix this: .map.link should be $m
	    MacroDefLinks .map.link $linkname
	    set modified 1
	}
    }
    tk_menuBar $m $m.mbar
}

############################################################

proc DefSource {} {
    global tdatas schemas maps fsBox sname datadir dialogListVar topgrps \
	selgrp

    # see if .source window already exists; if so, just return
    set err [catch {set exists [wm state .source]}]
    if {!$err} { wm deiconify .source; return }

    set fsBox(path) $datadir
    set fsBox(pattern) *
    set source [FSBox]

    if {$source == ""} { return }
    if {![file isfile $source]} { return }

    foreach tdata $tdatas {
	set name [lindex $tdata 0]
	set file [lindex $tdata 1]
	if {$source == $file} {
	    set fname [file tail $source]
	    dialog .sourceExists "Source Exists" \
		    "Source file $fname is already open\n\
		    under source name $name." \
		    "" 0 {OK}
	    return
	}
    }

    set schemaTypes [DEVise get tdata]
    set schema ""
    if {![llength $schemaTypes]} {
	set schema [ImportFileType]
    } else {
	set fname [file tail $source]
	set but [dialogList .schemaType "Schema" \
		"Select schema type for file $fname." \
		"" 2 {OK New Cancel} $schemaTypes]
	if {!$but} {
	    set schema $dialogListVar(selected)
	} elseif {$but == 1} {
	    set schema [ImportFileType]
	}
    }
    if {$schema == ""} { return }

    set err [catch {set sdef $maps($schema)}]
    if {$err > 0} {
	set maps($schema) ""
    }

    toplevel .source
    wm title .source "Define Source"
    wm geometry .source +100+100
    selection clear .source

    CreateTitleBitmap .source.label file.gif "Enter Data Source Name"
    frame .source.mid -relief groove -borderwidth 2
    frame .source.but
    pack .source.label .source.mid .source.but -side top -pady 3m \
	    -padx 3m -fill both -expand 1

    frame .source.left
    frame .source.right
    pack .source.left -in .source.mid -side left
    pack .source.right -in .source.mid -side left -padx 3m -fill x -expand 1

    label .source.left.sname -text "Source name" -width 15
    label .source.left.source -text "Source file" -width 15
    label .source.left.schema -text "Schema" -width 15
    pack .source.left.sname -side top -fill x -pady 3m
    pack .source.left.source .source.left.schema -side top -fill x

    set sname [file tail $source]
    entry .source.right.sname -relief sunken -textvariable sname
    label .source.right.source -text [file tail $source] -anchor w
    label .source.right.schema -text $schema -anchor w
    pack .source.right.sname -side top -fill x -pady 3m
    pack .source.right.source .source.right.schema -side top -fill x

    button .source.but.ok -text OK -width 10 \
	    -command {
	if {$sname == ""} {
	    dialog .needSource "No Source Name" \
		    "Please enter name of source data." \
		    "" 0 {OK}
	} else {
	    set err [catch {set exists $schemas($sname)}]
	    if {!$err} {
		dialog .sourceExists "Source Name Exists" \
			"Source name $sname exists already." \
			"" 0 {OK}
	    } else {
		destroy .source
	    }
	}
    }
    button .source.but.clear -text Clear -width 10 \
	    -command { set sname "" }
    button .source.but.cancel -text Cancel -width 10 \
	    -command {
	set sname ""
	destroy .source
    }
    pack .source.but.ok .source.but.clear .source.but.cancel -side left \
	    -padx 3m -expand 1

    tkwait visibility .source
    grab set .source
    tkwait window .source

    if {$sname != ""} {
	set fname [file tail $source]
	statusWindow .info "Status" \
		"Creating an index on $fname.\n\n\
		This may take a while."
	# ask DEVise to create tdata
	set result [DEVise create tdata $schema $source $sname]
	catch {destroy .info}
	if {$result == ""} {
	    dialog .fileError "File Error" \
		    "Error reading file $fname" "" 0 OK
	    return ""
	}

	# get the list of top level group names from DEVise
	set topgrps [DEVise getTopGroups]

        if {[llength $topgrps] == 0} {
            set selgrp "__default"
            DEVise defaultGroup $sname
        } else {
	    # Create window to show list of top level group names
	    toplevel .topgrps
	    wm title .topgrps "Choose Group"
	    wm geometry .topgrps +100+100
	    selection clear .topgrps
	    listbox .topgrps.list -relief raised -borderwidth 2 \
		    -yscrollcommand ".topgrps.scroll set"
	    scrollbar .topgrps.scroll -command ".topgrps.list yview"
	    button .topgrps.ok -text "OK" -command {
		set selgrp [.topgrps.list get active]
		destroy .topgrps
	    }
	    pack .topgrps.ok -side bottom
	    pack .topgrps.list -side left
	    pack .topgrps.scroll -side right -fill y
	    
	    foreach i $topgrps {
		.topgrps.list insert end $i
	    }

	    tkwait visibility .topgrps
	    grab set .topgrps
	    tkwait window .topgrps
        }
		
	set sdef [DEVise getSchema $sname]
	lappend tdatas [list $sname $source]
	set schemas($sname) [list $schema $sdef]
    }

    return $sname
}

############################################################

proc statusWindow {w title msg} {
    toplevel $w
    wm title $w $title
    wm geometry $w +200+200
    message $w.msg -justify center -width 8c -text $msg
    pack $w.msg -side top -padx 8m -pady 4m
    update
}

############################################################

proc DefWindow {} {
    global windows x y w h winname

    # see if .def window already exists; if so, just return
    set err [catch {set exists [wm state .def]}]
    if {!$err} { wm deiconify .def; return }

    toplevel .def
    wm title .def "Define Window"
    wm geometry .def +100+100
    selection clear .def

    set winname "Default"
    set x "0.1"
    set y "0.3"
    set w "0.5"
    set h "0.5"

    label .def.label -text "Enter window parameters"
    frame .def.win
    frame .def.but
    pack .def.label -side top -pady 3m
    pack .def.win -side top -padx 3m -fill both -expand 1
    pack .def.but -side top -pady 3m -padx 3m -fill x -expand 1

    frame .def.win.left
    frame .def.win.right
    pack .def.win.left .def.win.right -side left -fill both \
	    -expand 1

    label .def.win.left.x -text X -width 8
    label .def.win.left.y -text Y -width 8
    label .def.win.left.w -text Width -width 8
    label .def.win.left.h -text Height -width 8
    label .def.win.left.name -text Name -width 8
    pack .def.win.left.x .def.win.left.y \
	    .def.win.left.w .def.win.left.h -side top -pady 0.7m
    pack .def.win.left.name -side top -pady 3m

    entry .def.win.right.x -relief sunken -width 15 -textvariable x
    entry .def.win.right.y -relief sunken -width 15 -textvariable y
    entry .def.win.right.w -relief sunken -width 15 -textvariable w
    entry .def.win.right.h -relief sunken -width 15 -textvariable h
    entry .def.win.right.name -relief sunken -width 15 -textvariable winname
    pack .def.win.right.x .def.win.right.y \
	    .def.win.right.w .def.win.right.h -side top
    pack .def.win.right.name -side top -pady 3m

    button .def.but.ok -text OK -width 10 \
	    -command {
	if {$winname == ""} {
	    dialog .needInfo "Missing Information" \
		    "Please enter all requested information." \
		    "" 0 {OK}
	} else {
	    set err [catch {set exists $windows($winname)}]
	    if {!$err} {
		dialog .winExists "Win Exists" \
			"Window $winname exists already." \
			"" 0 {OK}
	    } else {
		destroy .def
	    }
	}
    }
    button .def.but.cancel -text Cancel -width 10 \
	    -command {
	set winname ""
	destroy .def
    }
    pack .def.but.ok .def.but.cancel -padx 3m -side left -expand 1

    tkwait visibility .def
    grab set .def
    tkwait window .def

    if {$winname != ""} {
	# ask DEVise to create window
	set winType WinVertical
	set result [DEVise create window $winType $winname $x $y $w $h]
	if {$result == ""} {
	    dialog .windowError "Window Error" \
		    "Error creating window $winname" "" 0 OK
	    return ""
	}
	set defn [list $x $y $w $h]
	set windows($winname) $defn
    }

    return $winname
}

############################################################

proc DefMapping {tdata schema} {
    global DEViseColors DEViseShapes
    global mappings devcolors devshapes
    global mapname x y color size pattern orient shape

    # see if .def window already exists; if so, just return
    set err [catch {set exists [wm state .def]}]
    if {!$err} { wm deiconify .def; return }

    toplevel .def
    wm title .def "Define Mapping"
    wm geometry .def +100+100
    selection clear .def

    set mapname "Default"

    label .def.label -text "Enter mapping parameters"
    frame .def.map
    frame .def.but
    pack .def.label -side top -pady 3m
    pack .def.map -side top -padx 3m -fill both -expand 1
    pack .def.but -side top -pady 3m -padx 3m -fill x -expand 1

    frame .def.map.left
    frame .def.map.right
    pack .def.map.left .def.map.right -side left -fill both \
	    -expand 1

    label .def.map.left.x -text X -width 8
    label .def.map.left.y -text Y -width 8
    label .def.map.left.color -text Color -width 12
    label .def.map.left.size -text Size -width 12
    label .def.map.left.pattern -text Pattern -width 12
    label .def.map.left.orient -text Orientation -width 12
    label .def.map.left.shape -text Shape -width 12
    label .def.map.left.name -text Name -width 12
    pack .def.map.left.x .def.map.left.y \
	    .def.map.left.color .def.map.left.orient \
	    .def.map.left.size .def.map.left.pattern \
	    .def.map.left.shape -side top -pady 0.7m
    pack .def.map.left.name -side top -pady 3m

    menubutton .def.map.right.x -relief raised \
	    -textvariable x -menu .def.map.right.x.menu -width 15
    menubutton .def.map.right.y -relief raised \
	    -textvariable y -menu .def.map.right.y.menu -width 15
    menubutton .def.map.right.color -relief raised \
	    -textvariable color -menu .def.map.right.color.menu -width 15
    menubutton .def.map.right.size -relief raised \
	    -textvariable size -menu .def.map.right.size.menu -width 15
    menubutton .def.map.right.pattern -relief raised \
	    -textvariable pattern -menu .def.map.right.pattern.menu -width 15
    menubutton .def.map.right.orient -relief raised \
	    -textvariable orient -menu .def.map.right.orient.menu -width 15
    menubutton .def.map.right.shape -relief raised \
	    -textvariable shape -menu .def.map.right.shape.menu -width 15
    entry .def.map.right.name -relief sunken -width 15 -textvariable mapname
    pack .def.map.right.x .def.map.right.y \
	    .def.map.right.color .def.map.right.orient \
	    .def.map.right.size .def.map.right.pattern \
	    .def.map.right.shape -side top
    pack .def.map.right.name -side top -pady 3m

    menu .def.map.right.x.menu -tearoff 0
    menu .def.map.right.y.menu -tearoff 0
    set x ""
    set y ""
    foreach attr $schema {
	set name [lindex $attr 0]
	set type [lindex $attr 1]
	set sorted [lindex $attr 2]
	.def.map.right.x.menu add radiobutton -label $name \
		-variable x -value $name
	.def.map.right.y.menu add radiobutton -label $name \
		-variable y -value $name
	if {$sorted > 0 && $name != "recId" && $x == ""} {
	    set x $name
	}
    }
    tk_menuBar .def.map.right .def.map.right.x
    tk_menuBar .def.map.right .def.map.right.y
    if {$x == ""} {
	set x [lindex [lindex $schema 0] 0]
    }
    set y [lindex [lindex $schema 1] 0]

    menu .def.map.right.color.menu -tearoff 0
    foreach color $DEViseColors {
	set idx [lindex $color 0]
	set name [lindex $color 1]
	set devcolors($name) $idx
	.def.map.right.color.menu add radiobutton -label $name \
		-variable color -value $name
    }
    tk_menuBar .def.map.right .def.map.right.color
    set color red

    menu .def.map.right.size.menu -tearoff 0
    .def.map.right.size.menu add radiobutton -label 1 \
	    -variable size -value 1
    tk_menuBar .def.map.right .def.map.right.size
    set size 1

    menu .def.map.right.pattern.menu -tearoff 0
    .def.map.right.pattern.menu add radiobutton -label 0 \
	    -variable pattern -value 0
    tk_menuBar .def.map.right .def.map.right.pattern
    set pattern 0

    menu .def.map.right.orient.menu -tearoff 0
    .def.map.right.orient.menu add radiobutton -label 0 \
	    -variable orient -value 0
    tk_menuBar .def.map.right .def.map.right.orient
    set orient 0

    menu .def.map.right.shape.menu -tearoff 0
    foreach shape $DEViseShapes {
	set idx [lindex $shape 0]
	set name [lindex $shape 1]
	set devshapes($name) $idx
	.def.map.right.shape.menu add radiobutton -label $name \
		-variable shape -value $name
    }
    tk_menuBar .def.map.right .def.map.right.shape
    set shape Bar

    button .def.but.ok -text OK -width 10 \
	    -command {
	if {$mapname == ""} {
	    dialog .needInfo "Missing Information" \
		    "Please enter all requested information." \
		    "" 0 {OK}
	} else {
	    set err [catch {set exists $mappings($mapname)}]
	    if {!$err} {
		dialog .mapExists "Mapping Exists" \
			"Mapping $mapname exists already." \
			"" 0 {OK}
	    } else {
		destroy .def
	    }
	}
    }
    button .def.but.cancel -text Cancel -width 10 \
	    -command {
	set mapname ""
	destroy .def
    }
    pack .def.but.ok .def.but.cancel -side left -padx 3m -expand 1

    tkwait visibility .def
    grab set .def
    tkwait window .def

    if {$mapname != ""} {
	set cidx $devcolors($color)
	set pidx 0
	set oidx 0
	set sidx $devshapes($shape)
	set defn [list $x $y $cidx $size $pidx $oidx $sidx]
	set mappings($mapname) $defn
    }

    return $mapname
}

############################################################

proc DefView {} {
    global views
    global xlo xhi ylo yhi color size pattern orient shape viewname
    global DEViseColors DEViseShapes
    global devcolors devshapes

    # see if .def window already exists; if so, just return
    set err [catch {set exists [wm state .def]}]
    if {!$err} { wm deiconify .def; return }

    toplevel .def
    wm title .def "Define View"
    wm geometry .def +100+100
    selection clear .def

    set viewname "Default"
    set xlo "0.0"
    set xhi "100.0"
    set ylo "0.0"
    set yhi "100.0"

    set viewParams [DEVise getparam view SortedX]
    foreach param $viewParams {
	set pname [lindex $param 0]
	set value [lindex $param 1]
	if {$pname == "xlow"} {
	    set xlo $value
	}
	if {$pname == "xhigh"} {
	    set xhi $value
	}
	if {$pname == "ylow"} {
	    set ylo $value
	}
	if {$pname == "yhigh"} {
	    set yhi $value
	}
    }

    label .def.label -text "Enter view parameters"
    frame .def.view
    frame .def.but
    pack .def.label -side top -pady 3m
    pack .def.view -side top -padx 3m -fill both -expand 1
    pack .def.but -side top -pady 3m -padx 3m -fill x -expand 1

    frame .def.view.left
    frame .def.view.right
    pack .def.view.left .def.view.right -side left -fill both \
	    -expand 1

    label .def.view.left.xlo -text "X low" -width 12
    label .def.view.left.xhi -text "X high" -width 12
    label .def.view.left.ylo -text "Y low" -width 12
    label .def.view.left.yhi -text "Y high" -width 12
    label .def.view.left.color -text Color -width 12
    label .def.view.left.size -text Size -width 12
    label .def.view.left.pattern -text Pattern -width 12
    label .def.view.left.orient -text Orientation -width 12
    label .def.view.left.shape -text Shape -width 12
    label .def.view.left.name -text Name -width 12
    pack .def.view.left.xlo .def.view.left.xhi \
	    .def.view.left.ylo .def.view.left.yhi \
	    .def.view.left.color .def.view.left.orient \
	    .def.view.left.size .def.view.left.pattern \
	    .def.view.left.shape -side top -pady 0.7m
    pack .def.view.left.name -side top -pady 3m

    entry .def.view.right.xlo -relief sunken -width 20 -textvariable xlo
    entry .def.view.right.xhi -relief sunken -width 20 -textvariable xhi
    entry .def.view.right.ylo -relief sunken -width 20 -textvariable ylo
    entry .def.view.right.yhi -relief sunken -width 20 -textvariable yhi
    menubutton .def.view.right.color -relief raised \
	    -textvariable color -menu .def.view.right.color.menu -width 20
    menubutton .def.view.right.size -relief raised \
	    -textvariable size -menu .def.view.right.size.menu -width 20
    menubutton .def.view.right.pattern -relief raised \
	    -textvariable pattern -menu .def.view.right.pattern.menu -width 20
    menubutton .def.view.right.orient -relief raised \
	    -textvariable orient -menu .def.view.right.orient.menu -width 20
    menubutton .def.view.right.shape -relief raised \
	    -textvariable shape -menu .def.view.right.shape.menu -width 20
    entry .def.view.right.name -relief sunken -width 20 -textvariable viewname
    pack .def.view.right.xlo .def.view.right.xhi \
	    .def.view.right.ylo .def.view.right.yhi \
	    .def.view.right.color .def.view.right.orient \
	    .def.view.right.size .def.view.right.pattern \
	    .def.view.right.shape -side top
    pack .def.view.right.name -side top -pady 3m

    menu .def.view.right.color.menu -tearoff 0
    foreach color $DEViseColors {
	set idx [lindex $color 0]
	set name [lindex $color 1]
	set devcolors($name) $idx
	.def.view.right.color.menu add radiobutton -label $name \
		-variable color -value $name
    }
    tk_menuBar .def.view.right .def.view.right.color
    set color red

    menu .def.view.right.size.menu -tearoff 0
    .def.view.right.size.menu add radiobutton -label 1 \
	    -variable size -value 1
    tk_menuBar .def.view.right .def.view.right.size
    set size 1

    menu .def.view.right.pattern.menu -tearoff 0
    .def.view.right.pattern.menu add radiobutton -label 0 \
	    -variable pattern -value 0
    tk_menuBar .def.view.right .def.view.right.pattern
    set pattern 0

    menu .def.view.right.orient.menu -tearoff 0
    .def.view.right.orient.menu add radiobutton -label 0 \
	    -variable orient -value 0
    tk_menuBar .def.view.right .def.view.right.orient
    set orient 0

    menu .def.view.right.shape.menu -tearoff 0
    foreach shape $DEViseShapes {
	set idx [lindex $shape 0]
	set name [lindex $shape 1]
	set devshapes($name) $idx
	.def.view.right.shape.menu add radiobutton -label $name \
		-variable shape -value $name
    }
    tk_menuBar .def.view.right .def.view.right.shape
    set shape Bar

    button .def.but.ok -text OK -width 10 \
	    -command {
	if {$viewname == ""} {
	    dialog .needInfo "Missing Information" \
		    "Please enter all requested information." \
		    "" 0 {OK}
	} else {
	    set err [catch {set exists $views($viewname)}]
	    if {!$err} {
		dialog .viewExists "View Exists" \
			"View $viewname exists already." \
			"" 0 {OK}
	    } else {
		destroy .def
	    }
	}
    }
    button .def.but.cancel -text Cancel -width 10 \
	    -command {
	set viewname ""
	destroy .def
    }
    pack .def.but.ok .def.but.cancel -padx 3m -side left -expand 1

    tkwait visibility .def
    grab set .def
    tkwait window .def

    if {$viewname != ""} {
	set defn [list $xlo $xhi $ylo $yhi white]
	set views($viewname) $defn
    }

    return $viewname
}

############################################################

proc DefLink {} {
    global links
    global x y color size pattern orient shape linkname
    global macroSelectColor

    # see if .def window already exists; if so, just return
    set err [catch {set exists [wm state .def]}]
    if {!$err} { wm deiconify .def; return }

    toplevel .def
    wm title .def "Define Link"
    wm geometry .def +100+100
    selection clear .def

    set linkname "Default"
    set x 1
    set y 0
    set color 0
    set size 0
    set pattern 0
    set orient 0
    set shape 0

    label .def.label -text "Enter link parameters"
    frame .def.link
    frame .def.name
    frame .def.but
    pack .def.label -side top -pady 3m
    pack .def.link -side top -padx 3m -fill both -expand 1
    pack .def.name -side top -padx 3m -fill x -expand 1
    pack .def.but -side top -pady 3m -padx 3m -fill x -expand 1

    checkbutton .def.link.x -text X -variable x -anchor w \
	    -indicatoron 0 -selectcolor $macroSelectColor
    checkbutton .def.link.y -text Y -variable y -anchor w \
	    -indicatoron 0 -selectcolor $macroSelectColor
    checkbutton .def.link.color -text Color -variable color -anchor w \
	    -indicatoron 0 -selectcolor $macroSelectColor
    checkbutton .def.link.size -text Size -variable size -anchor w \
	    -indicatoron 0 -selectcolor $macroSelectColor
    checkbutton .def.link.pattern -text Pattern -variable pattern -anchor w \
	    -indicatoron 0 -selectcolor $macroSelectColor
    checkbutton .def.link.orient -text Orientation \
	    -variable orient -anchor w \
	    -indicatoron 0 -selectcolor $macroSelectColor
    checkbutton .def.link.shape -text Shape -variable shape -anchor w \
	    -indicatoron 0 -selectcolor $macroSelectColor
    pack .def.link.x .def.link.y .def.link.color .def.link.orient \
	    .def.link.size .def.link.pattern .def.link.shape \
	    -side top -fill x -expand 1

    label .def.name.label -text "Name"
    entry .def.name.name -relief sunken -textvariable linkname
    pack .def.name.label -side left -pady 3m -padx 3m
    pack .def.name.name -side right -pady 3m -fill x -expand 1

    button .def.but.ok -text OK -width 10 \
	    -command {
	if {$linkname == ""} {
	    dialog .needInfo "Missing Information" \
		    "Please enter all requested information." \
		    "" 0 {OK}
	} else {
	    set err [catch {set exists $links($linkname)}]
	    if {!$err} {
		dialog .linkExists "Link Exists" \
			"Link $linkname exists already." \
			"" 0 {OK}
	    } else {
		destroy .def
	    }
	}
    }
    button .def.but.cancel -text Cancel -width 10 \
	    -command {
	set linkname ""
	destroy .def
    }
    pack .def.but.ok .def.but.cancel -side left -padx 3m -expand 1

    tkwait visibility .def
    grab set .def
    tkwait window .def

    if {$linkname != ""} {
	# ask DEVise to create link
	set flag [expr $x | ($y << 1) | ($color << 2) | ($size << 3) | \
		       ($pattern << 4) | ($orient << 5) | ($shape << 6)]
	set result [DEVise create link Visual_Link $linkname $flag]
	if {$result == ""} {
	    dialog .linkError "Link Error" \
		    "Error creating link $linkname" "" 0 OK
	    return ""
	}
	set links($linkname) $flag
    }

    return $linkname
}

############################################################

proc CreateBitmapButton2 {w file title command} {
    global libdir

    button $w -command $command

    frame $w.stack -relief raised -bd 2

    pack $w.stack

    # create a button for the image
    label $w.stack.img -image [image create photo -file $libdir/$file] \
	    -bd 0 -relief flat -padx 1 -pady 1

    pack $w.stack.img

    # create a button for the title
    label $w.stack.title -text $title \
	-bd 0 -relief flat -font 6x10 \
	-padx 1 -pady 1
    
    pack $w.stack.title

    return $w
}

############################################################

proc CreateBitmapButton {w file title command {width 20m} {height 21m}} {
    global libdir

    frame $w -relief raised -bd 2 -width $width -height $height
    bind $w <Button-1> $command

    # create a button for the image
    button $w.img -image [image create photo -file $libdir/$file] \
	-bd 0 -relief flat -command $command

    # create a button for the title
    button $w.title -text $title -bd 0 -relief flat -command $command
    
    pack propagate $w 0
    pack $w.img $w.title -side top -padx 1 -pady 1

    return $w
}

############################################################

proc CreateTextBitmap {w file title {width 20m} {height 17m}} {
    global libdir

    frame $w -width $width -height $height

    # create a button for the image
    label $w.img -image [image create photo -file $libdir/$file] \
	-bd 0 -relief flat

    # create a button for the title
    label $w.title -text $title -bd 0 -relief flat
    
    pack propagate $w 0
    pack $w.img $w.title -side top -padx 1 -pady 1

    return $w
}

############################################################

proc CreateTitleBitmap {w file title {height 16m}} {
    global libdir

    frame $w -height $height
    frame $w.top
    pack $w.top -side top

    # create a button for the image
    label $w.img -image [image create photo -file $libdir/$file] \
	-bd 0 -relief flat -padx 1 -pady 1

    # create a button for the title
    label $w.title -text $title -bd 0 -relief flat -padx 1 -pady 1
    
    pack $w.img $w.title -in $w.top -side left -padx 8

    return $w
}

############################################################

proc CreateBitmapMenuButton { w file varname } {
    upvar varname var
    global libdir

    frame $w -relief raised -bd 2

    # create a button for the image
    button $w.img -image [image create photo -file $libdir/$file] \
	-bd 0 -relief flat -command $command

    pack $w.img

    # create a button for the title
    button $w.title -text $title \
	-bd 0 -relief flat -font 6x10 \
	-padx 1 -pady 1 \
	-command $command
    
    pack $w.title

    return $w
}


# Procedure for displaying Y coordinates in Auto mode
proc selYAuto {grpname} {
	global yvar macroSelectColor

	#Check if the window already exists
        set err [catch {set exists [wm state .selY$grpname]}]
	if {!$err} {wm deiconify .selY$grpname; return}

	# Create new window
	toplevel .selY$grpname
	wm title .selY$grpname "Group : $grpname"
	wm geometry .selY$grpname +100+100
	
	label .selY$grpname.label -text "Select Y parameters"
	frame .selY$grpname.sel -relief groove -borderwidth 2
	frame .selY$grpname.but 
	pack .selY$grpname.label -side top -pady 3m -fill x -expand 1
	pack .selY$grpname.sel -side top -pady 3m -fill x -expand 1
	pack .selY$grpname.but -side top -pady 3m -fill x -expand 1

	set row -1
	set col -1
	set maxcol 4
	set varcnt 0

	set grplist [DEVise getItems $grpname]

	foreach itm $grplist {
		set subname [lindex $itm 0]
		set type [lindex $itm 1]
		if {$col < 0} {
			incr row
			set col 0
			frame .selY$grpname.sel.row$row
			pack .selY$grpname.sel.row$row -side top -fill x \
				-expand 1
		}
		if {$type != "intr"} {
			checkbutton .selY$grpname.sel.row$row.col$col \
				-text $subname -variable yvar($subname) \
				-width 15 -anchor w -indicatoron 0 \
				-selectcolor $macroSelectColor
			set yvar($subname) 0
		} else {
			button .selY$grpname.sel.row$row.col$col \
				-text $subname -width 15 \
				-command \
				    [format "selYAuto %s" $subname] 
		}
		pack .selY$grpname.sel.row$row.col$col -side left \
			-fill x -expand 1
		incr col
		if {$col >= $maxcol} {
			set col -1
		}
	}

	#Add empty frames at end of last row
	for {} {$row >= 0 && $col >= 0 && $col < $maxcol} {incr col} {
		label .selY$grpname.sel.row$row.col$col -text "" \
			-width 15 -relief flat -borderwidth 4
		pack .selY$grpname.sel.row$row.col$col -side left -fill x \
			-expand 1
	}

	button .selY$grpname.but.ok -text OK -width 20 -command \
		[format "destroy .selY%s" $grpname]

	pack .selY$grpname.but.ok -side left -expand 1
}
			


############################################################

# INITIALIZE  macro definition utility
MacroDefInit
