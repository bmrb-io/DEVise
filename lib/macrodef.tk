#  ========================================================================
#  DEVise Data Visualization Software
#  (c) Copyright 1992-1996
#  By the DEVise Development Group
#  Madison, Wisconsin
#  All Rights Reserved.
#  ========================================================================
#
#  Under no circumstances is this software to be copied, distributed,
#  or altered in any way without prior permission from the DEVise
#  Development Group.

############################################################

#	$Id$

#	$Log$
#	Revision 1.55  1996/07/15 17:00:26  jussi
#	String attributes can now be "visualized" i.e. used as labels.
#
#	Revision 1.54  1996/07/13 17:30:45  jussi
#	Removed obsolete code (a lot was carried along for potential
#	future usage not none of the code was actually used). If a
#	schema has an attribute named Color, then the color field
#	in the mapping will use that attribute.
#
#	Revision 1.53  1996/07/13 00:36:40  jussi
#	Added nicer error messages for missing schema files.
#
#	Revision 1.52  1996/07/13 00:21:13  jussi
#	Broke OpenNewDataSource into two parts so the DoColorStat can
#	reuse the latter part of it.
#
#	Revision 1.51  1996/07/12 21:54:44  jussi
#	Fixed minor typo.
#
#	Revision 1.50  1996/07/08 17:08:02  jussi
#	Small fix in OpenDataSource.
#
#	Revision 1.49  1996/07/01 19:37:33  jussi
#	Made changes to reflect new TData constructor interface. Web
#	data caching is now handled in the server, not in the client.
#
#	Revision 1.48  1996/06/20 17:14:09  guangshu
#	Added support for derived TData sets (statistics for now).
#
#	Revision 1.47  1996/06/16 01:32:53  jussi
#	Added handling of case where xlo == xhi or ylo == yhi.
#
#	Revision 1.46  1996/06/13 23:00:22  jussi
#	Fixed minor bug with New Mapping check button.
#
#	Revision 1.45  1996/06/04 14:22:06  wenger
#	Ascii data can now be read from session files (or other files
#	where the data is only part of the file); added some assertions
#	to check for pointer alignment in functions that rely on this;
#	Makefile changes to make compiling with debugging easier.
#
#	Revision 1.44  1996/05/11 03:00:01  jussi
#	Minor improvements. Changes made towards caching multiple
#	data sources in one step.
#
#	Revision 1.43  1996/05/09 18:15:16  kmurli
#	No changes, just inserted some debugging print statements and
#	removed them
#
#	Revision 1.42  1996/05/05 03:05:11  jussi
#	Automatic adjustment of Y axis scale is done for bar charts only.
#
#	Revision 1.41  1996/04/23 20:39:10  jussi
#	Corrected default value of view label.
#
#	Revision 1.40  1996/04/23 14:40:25  jussi
#	Added mising variable name to global name list, fixed color
#	assignment with new mappings.
#
#	Revision 1.39  1996/04/11 18:23:02  jussi
#	Major changes in the organization of the user interface.
#
#	Revision 1.38  1996/03/26 21:16:13  jussi
#	Added scaling of axis values to nearest "reasonable" value.
#
#	Revision 1.37  1996/02/05 19:55:12  jussi
#	Background color is chosen from a palette of colors instead of
#	a list of color names.
#
#	Revision 1.36  1996/02/01 18:31:13  jussi
#	Improved handling of errors in extracting from data from
#	external source.
#
#	Revision 1.35  1996/01/30 00:06:13  jussi
#	Minor improvements in visual appearance.
#
#	Revision 1.34  1996/01/27 00:45:10  jussi
#	User can now select background color of a new window.
#
#	Revision 1.33  1996/01/23 20:48:48  jussi
#	Added MacroImport which, temporarily, uses almost identical
#	duplicates of MacroDefAuto and MacroDefAutoActual. When the
#	old interface is obsoleted, the older versions of these two
#	procedures will be removed.
#
#	Revision 1.32  1996/01/17 19:27:34  jussi
#	Minor fix.
#
#	Revision 1.31  1996/01/16 01:30:16  jussi
#	Some reorganization of code. Removed duplicate code etc.
#
#	Revision 1.30  1996/01/13 23:09:49  jussi
#	Added support for Z attribute and shape attribute 2.
#
#	Revision 1.29  1996/01/13 20:56:26  jussi
#	Reorganized code that opens a data source. The same routine
#	(OpenDataSource) is now used in the session file.
#
#	Revision 1.28  1996/01/11 21:01:44  jussi
#	Data stream is cached before schema is read; this is because
#	for SEQ the schema is produced as part of the caching step.
#
#	Revision 1.27  1996/01/10 18:48:46  jussi
#	Attribute hi/lo values now take their values from either the
#	schema or the .rc file (schema has precedence). For bar charts,
#	ylo is 0 by default.
#
#	Revision 1.26  1996/01/10 00:38:42  jussi
#	Added support for hi/lo values defined in schema.
#
#	Revision 1.25  1995/12/29 17:33:04  jussi
#	Changed format of view instance names created automatically.
#	Removed Double-Button-1 binding of group selection list.
#	Cleaned up code that initializes associative arrays.
#
#	Revision 1.24  1995/12/14 15:49:16  jussi
#	Added support for TileLayout with automatic or manual view layout
#	control.
#
#	Revision 1.23  1995/12/13 02:06:06  ravim
#	Changed criterion for not reloading the schema.
#
#	Revision 1.22  1995/12/04 18:28:15  jussi
#	Changed size of automatically created windows to depend on view
#	layout selected. For horizontal layout, the window is wide, for
#	vertical layout, it's tall.
#
#	Revision 1.21  1995/12/04 18:02:33  jussi
#	User can now choose to have a title, X axis, Y axis, X link enabled
#	or disabled in automatically generated views. Window name can be
#	specified too. Horizontal view layouts are available now.
#
#	Revision 1.20  1995/11/29 15:47:26  jussi
#	Removed constant size definition from some toplevel windows
#	because they will produce unexpected results on some window
#	managers.
#
#	Revision 1.19  1995/11/22 17:53:46  jussi
#	Added view type selection in automatic view generation. User can
#	now choose between a bar chart, an image, and a scatter plot.
#
#	Revision 1.18  1995/11/20 22:22:54  jussi
#	Changed sequence of caching data from tape to disk.
#	Restored missing history log.
#
#	Revision 1.17  1995/11/19 06:04:29  ravim
#	New way of displaying attributes and groups.
#
#	Revision 1.16  1995/11/18 01:49:46  ravim
#	Groups associated with schema. Also groups chosen at "Auto" stage.
#
#	Revision 1.15  1995/11/14 22:50:39  jussi
#	Interfaced new stream selection dialog into DefSource. Minor other
#	changes.
#
#	Revision 1.14  1995/11/07 20:24:48  jussi
#	Commented out some output statements.
#
#	Revision 1.13  1995/11/06 16:33:33  jussi
#	Increased minimum vertical size of .map window.
#
#	Revision 1.12  1995/10/29 01:01:12  ravim
#	Bug fix.
#
#	Revision 1.11  1995/10/27 21:05:03  ravim
#	Handles group names starting with capital letters.
#
#	Revision 1.10  1995/10/11 17:07:21  ravim
#	Minor changes.
#
#	Revision 1.9  1995/09/30 08:00:52  ravim
#	No changes - Ignore.
#
#	Revision 1.8  1995/09/30 07:59:18  ravim
#	Minor changes to group handling
#
#	Revision 1.7  1995/09/30 07:56:11  ravim
#	Initial implementation of schema browser - can create new schema files
#
#	Revision 1.6  1995/09/28 17:44:03  jussi
#	Included size, pattern, and orientation in all mapping definitions
#	although these are not used by DEVise currently. Minor other
#	touch-ups.
#
#	Revision 1.5  1995/09/27 17:20:34  ravim
#	Added support for groups in schemas.
#
#	Revision 1.4  1995/09/26 23:09:02  jussi
#	Added color/shape/size/pattern/orientation settings to view
#	definition.
#
#	Revision 1.3  1995/09/22 17:33:47  jussi
#	Added copyright message.
#
#	Revision 1.2  1995/09/21 15:36:27  jussi
#	Added small icons.
#
#	Revision 1.1  1995/09/13 14:24:07  jussi
#	Extracted macro definition code from control.tk.

############################################################

proc SelectTopGroup {schemaname} {
    global selgrp

    # get the list of top level group names from DEVise
    set topgrps [DEVise getTopGroups $schemaname]

    if {[llength $topgrps] == 1 && [lindex $topgrps 0] == "__default"} {
	return "__default"
    }

    # Create window to show list of top level group names
    toplevel .topgrps
    wm title .topgrps "Choose Attribute Group"
    wm geometry .topgrps +100+100
    selection clear .topgrps
    listbox .topgrps.list -relief raised -borderwidth 2 \
	    -yscrollcommand ".topgrps.scroll set" \
	    -font 9x15 -selectmode single
    scrollbar .topgrps.scroll -command ".topgrps.list yview"
    button .topgrps.ok -text OK -command {
	set selgrp [.topgrps.list get active]
	destroy .topgrps
    }
    pack .topgrps.ok -side bottom -fill x
    pack .topgrps.scroll -side right -fill y
    pack .topgrps.list -fill x 
    
    foreach i $topgrps {
	.topgrps.list insert end $i
    }
    
    tkwait visibility .topgrps
    grab set .topgrps
    tkwait window .topgrps

    return $selgrp
}

############################################################

proc OpenDataSource {sname} {
    global sourceList derivedSourceList

    # first see if sname is a derived source
    # and if the cache disk file exists
    set err [catch {set exists $derivedSourceList($sname)}]
    if {!$err} {
	set fname [isCached $sname -1 -1]
	if {$fname == ""} {
	    dialog .noDerivedData "No Derived Data" \
		    "Derived data \"$sname\" does not exist." \
		    "" 0 Ok
	    return ""
	}
        set stype [lindex $derivedSourceList($sname) 0]
	DEVise dataSegment $sname $fname 0 0
	return [list $sname $fname $stype]
    }

    # see if data source (still) defined (may be out-of-date in
    # a session file)

    set err [catch {set exists $sourceList($sname)}]
    if {$err} {
	set but [dialog .sourceNotExists "Undefined Data Stream" \
		"Data stream \"$sname\" does not exist." \
		"" 0 OK "Select Another"]
	if {$but == 0} { return "" }
	while {1} {
	    set sname [selectStream]
	    if {$sname == ""} { return "" }
	    # must choose a single data stream
	    if {[llength $sname] > 1} {
		dialog .singleStream "Select Single Stream" \
			"You have selected more than one data stream.\
			Please select a single data stream." "" 0 Continue
		continue
	    }
	    break
	}
	set sname [lindex $sname 0]
    }

    # cache data to disk right now
    if {[isCached $sname -1 -1] == ""} {
	set but [dialog .cacheData "Caching Data" \
		"Cache \"$sname\" to disk now?" \
		"" 1 Yes No]
	if {$but == 1} {
	    dialog .notCached "Must Cache Data Stream" \
		    "Cannot visualize data without caching it to disk first." \
		    "" 0 OK
	    return ""
	}
    }

    set fname [cacheData $sname -1 -1]
    if {$fname == ""} {
	return ""
    }

    # Tell the C++ code whether this data is only a portion of a file.
    set fileSeg [lindex $sourceList($sname) 8]
    DEVise dataSegment $sname $fname [lindex $fileSeg 0] [lindex $fileSeg 1]

    set stype [lindex $sourceList($sname) 0]
    if {$stype != "WWW" && $stype != "UNIXFILE"} {
        set stype "UNIXFILE"
    }

    return [list $sname $fname $stype]
}

############################################################

proc CacheMultipleDataSources {snames} {
    global sourceList

    set numnotcached 0
    foreach sname $snames {
	# see if data stream is on disk already
	if {[isCached $sname -1 -1] == ""} {
	    incr numnotcached
	}
    }

    if {$numnotcached > 0} {
	set but [dialog .cacheData "Caching Data" \
		"Will need to cache $numnotcached streams to disk now." \
		"" 0 Okay Cancel]
	if {$but == 1} {
	    dialog .notCached "Cancel Visualization" \
		    "Cannot visualize data without caching it to disk first." \
		    "" 0 OK
	    return ""
	}
    }

    set sources [cacheMultipleData $snames -1 -1]
    return $sources
}

############################################################

proc OpenNewDataSource {derivedOnly} {
    # select data streams to display
    if {$derivedOnly} {
	set snames [selectDerivedStream]
    } else {
	set snames [selectStream]
    }

    if {$snames == ""} { return "" }

    # must choose a single data stream
    if {[llength $snames] > 1} {
	dialog .singleStream "Select Single Stream" \
                "You have selected more than one data stream.\
                Only the first stream will be visualized." "" 0 Continue
    }

    return [ OpenAndDefineDataSources $derivedOnly $snames ]
}

############################################################

proc OpenAndDefineDataSources {derivedOnly snames} {
    global sourceList derivedSourceList

    foreach sname $snames {
        # see if data stream already open
        if {[lsearch [TdataSet] $sname] >= 0} {
            continue
        }

        # make sure data is cached on disk
        set sourcedef [OpenDataSource $sname]
        if {$sourcedef == ""} {
            return ""
        }

        set sname [lindex $sourcedef 0]
        set param [lindex $sourcedef 1]
        set stype [lindex $sourcedef 2]
        
        if {$derivedOnly} {
            set schema [lindex $derivedSourceList($sname) 2]
            set schemafile [lindex $derivedSourceList($sname) 3]
        } else {
            set schema [lindex $sourceList($sname) 2]
            set schemafile [lindex $sourceList($sname) 3]
        }

        # load schema file if necessary - it is not sufficient to check if
        # the physical schema by the same name has been loaded because the same
        # physical schema may be shared by several logical schemas - the best
        # way of checking is to see that we have no groups defined under the 
        # logical schema name
    
        set topgrps [DEVise getTopGroups [file tail $schemafile]]
        if {[llength $topgrps] == 0} {
            if {![file readable $schemafile]} {
                dialog .schemaError "Schema File Not Found" \
                        "Cannot open schema file $schemafile" "" 0 OK
                return ""
            }
            set result [DEVise importFileType $schemafile]
            if {$result == ""} {
                return ""
            }
            if {$result != $schema} {
                puts "File $schemafile appears to contain schema $result,\
                        not $schema"
                set schema $result
            }
        }
    
        statusWindow .info "Status" \
                "Creating an index on \"$sname\".\n\n\This may take a while."
        update

        # ask DEVise to create tdata
        set result [DEVise create tdata $schema $sname $stype $param]
        catch {destroy .info}

        if {$result == ""} {
            dialog .tdataError "Data Stream Error" \
                    "Cannot open data stream $sname" "" 0 OK
            return ""
        }
    }

    return [lindex $snames 0]
}

############################################################

proc setupAttrCheckButtons {win var schemaname grpname topgrp} {
    global $var

    set row -1
    set col -1
    set maxcol 1
    set varcnt 0

    # We will do some preprocessing to figure out how to display the
    # the attributes - i.e. how many columns per row, size of menu
    # buttons and the size of the window itself.
    
    set grplist [DEVise getItems $schemaname $topgrp $grpname]

    # Find the max width of the attrs and the number of attrs
    set numattrs 0
    set maxwidth 0
    foreach itm $grplist {
	set subname [lindex $itm 0]
	set width [llength [split $subname {}]]
	if {$width > $maxwidth} {
	    set maxwidth $width
	}
	incr numattrs
    }

    if {$maxwidth < 13} {
	set maxwidth 13
    }
    incr maxwidth 2
    set maxcol [expr 75 / $maxwidth]
    if {$maxcol < 1} {
	set maxcol 1
    }
    set colwidth $maxwidth
    
    foreach itm $grplist {
	set subname [lindex $itm 0]
	set type [lindex $itm 1]
	set checkvar [format "%s(%s)" $var $subname]

	if {$col < 0} {
	    incr row
	    set col 0
	    frame $win.row$row
	    pack $win.row$row -side top -fill x -expand 1
	}

	# If regular attribute, add a check button; otherwise,
	# add a button which launches a submenu window

	if {$type != "intr"} {
	    checkbutton $win.row$row.col$col \
		    -text $subname -variable $checkvar \
		    -width $colwidth -indicatoron 0 \
		    -selectcolor #e6ceb1
	    set $checkvar 0
	} else {
	    menubutton $win.row$row.col$col \
		    -relief raised \
		    -text $subname -width $colwidth \
		    -bg darkslategray4 -fg wheat \
		    -menu "$win.row$row.col$col.menu"
	    setupAttrCheckMenu $win.row$row.col$col.menu $var $schemaname \
		    $subname $topgrp
	}
	pack $win.row$row.col$col -side left -fill x -expand 1
	incr col
	if {$col >= $maxcol} {
	    set col -1
	}
    }

    # Add empty frames at end of last row
    for {} {$row >= 0 && $col >= 0 && $col < $maxcol} {incr col} {
	label $win.row$row.col$col -text "" \
		-width $colwidth -relief flat -borderwidth 4
	pack $win.row$row.col$col -side left -fill x -expand 1
    }
}

############################################################

proc setupAttrCheckMenu {menu var schemaname grpname topgrp} {
    global $var

    menu $menu -tearoff 0

    set grplist [DEVise getItems $schemaname $topgrp $grpname]

    foreach itm $grplist {
	set subname [lindex $itm 0]
	set type [lindex $itm 1]
	set checkvar [format "%s(%s)" $var $subname]

	# If regular attribute, add a check button; otherwise,
	# add a cascaded menu for group

	if {$type != "intr"} {
	    $menu add checkbutton -label $subname -variable $checkvar
	    set $checkvar 0
	} else {
	    $menu add cascade -label $subname -menu $menu.g$subname
	    setupAttrCheckMenu $menu.g$subname $var $schemaname \
		    $subname $topgrp
	}
    }
}

############################################################

proc setupAttrRadioMenu {menu var prefix schemaname grpname topgrp} {
    global $var

    menu $menu -tearoff 0

    set grplist [DEVise getItems $schemaname $topgrp $grpname]

    foreach itm $grplist {
	set subname [lindex $itm 0]
	set type [lindex $itm 1]

	# If regular attribute, add a check button; otherwise,
	# add a cascaded menu for group

	if {$type != "intr"} {
	    $menu add radiobutton -label $subname -variable $var \
		    -value $prefix$subname
	} else {
	    $menu add cascade -label $subname -menu $menu.g$subname
	    setupAttrRadioMenu $menu.g$subname $var $prefix $schemaname \
		    $subname $topgrp
	}
    }
}

############################################################

proc MacroImport {mode derivedOnly} {
    global dialogListVar sourceList derivedSourceList

    set tdata ""

    if {!$derivedOnly && $mode > 0} {
	set tdataSet [TdataSet]
	if {[llength $tdataSet] > 0} {
	    set answer [ dialogList .selectTData "Visualize Data Stream"  \
		    "Select a data stream" \
		    "" 2 { New Cancel Ok } $tdataSet ]
	    if {$answer == 1 || $dialogListVar(selected) == ""} {
		return
	    }
	    if {$answer == 2} { 
		set tdata $dialogListVar(selected)
	    } else {
		set tdata ""
	    }
	}
    }

    if {$tdata == ""} {
	set tdata [OpenNewDataSource $derivedOnly]
    }

    if {$tdata == ""} { return }

    if {$derivedOnly} {
	set schemafile [lindex $derivedSourceList($tdata) 3]
    } else {
	set schemafile [lindex $sourceList($tdata) 3]
    }

    MacroDefAuto $tdata $schemafile
}

############################################################

proc MacroDefAuto {tdata schemafile} {
    global x yvar viewselname bgcolor linksel windowsel titlesel
    global xaxissel yaxissel cancel newgdata viewsel
    global sourceList global curView

    if {[WindowVisible .auto]} {
	return
    }
	
    set schema [DEVise getSchema $tdata]
    set schemaname [file tail $schemafile]
    set topgrp [SelectTopGroup $schemaname]

    toplevel .auto
    wm title .auto "Define Visualization"
    wm geometry .auto +50+50
    selection clear .auto
	
    label .auto.label -text "Define Visualization Parameters"

    frame .auto.top
    frame .auto.mid
    frame .auto.bot
    frame .auto.ysel -relief groove -borderwidth 2
    frame .auto.but

    pack .auto.label -side top -pady 3m -fill x -expand 1
    pack .auto.top -side top -pady 3m -fill x -expand 1
    pack .auto.mid -side top -pady 3m -fill x -expand 1
    pack .auto.bot -side top -pady 3m -fill x -expand 1
    pack .auto.ysel -side top -pady 3m -fill x -expand 1
    pack .auto.but -side top -pady 3m -fill x -expand 1

    frame .auto.windowsel -relief groove -borderwidth 2
    frame .auto.xsel -relief groove -borderwidth 2
    pack .auto.windowsel .auto.xsel -in .auto.top -side left \
	    -ipady 3m -padx 1m -fill x -expand 1

    frame .auto.viewsel -relief groove -borderwidth 2
    frame .auto.colorsel -relief groove -borderwidth 2
    frame .auto.gdatasel -relief groove -borderwidth 2
    pack .auto.viewsel .auto.colorsel .auto.gdatasel \
	    -in .auto.mid -side left -ipady 3m -padx 1m -fill x -expand 1

    frame .auto.titlesel -relief groove -borderwidth 2
    frame .auto.linksel -relief groove -borderwidth 2
    frame .auto.xaxissel -relief groove -borderwidth 2
    frame .auto.yaxissel -relief groove -borderwidth 2
    pack  .auto.titlesel .auto.linksel .auto.xaxissel .auto.yaxissel \
	    -in .auto.bot -side left -ipady 3m -padx 1m -fill x -expand 1
	

    label .auto.windowsel.label -text "Window:"
    menubutton .auto.windowsel.window -relief raised \
	    -textvariable windowsel -menu .auto.windowsel.window.menu \
	    -width 30
    pack .auto.windowsel.label .auto.windowsel.window -side left -padx 1m
    set windowsel ""
    if {$curView != ""} {
	set windowsel [DEVise getViewWin $curView]
    }
    if {$windowsel == ""} {
	set windowsel "None selected yet"
    }
   
    menu .auto.windowsel.window.menu -tearoff 0
    foreach w [WinSet] {
	.auto.windowsel.window.menu add command -label $w \
		-command "set windowsel {$w}"
    }

    .auto.windowsel.window.menu add separator
    .auto.windowsel.window.menu add command -label "New..." -command {
	set newwin [DoCreateWindow "Select window type"]
	if {$newwin != ""} {
	    set windowsel $newwin
	    .auto.windowsel.window.menu add command -label $windowsel \
		    -command "set windowsel {$windowsel}"
	}
    }

    label .auto.xsel.label -text "Select X:"
    menubutton .auto.xsel.attr -relief raised \
	    -textvariable x -menu .auto.xsel.attr.g$topgrp -width 20
    pack .auto.xsel.label .auto.xsel.attr -side left -padx 1m
    setupAttrRadioMenu .auto.xsel.attr.g$topgrp x "" $schemaname \
	    $topgrp $topgrp

    label .auto.viewsel.label -text "View Type:"
    menubutton .auto.viewsel.view -relief raised \
	    -textvariable viewselname -menu .auto.viewsel.view.menu -width 15
    pack .auto.viewsel.label .auto.viewsel.view -side left -padx 1m

    menu .auto.viewsel.view.menu -tearoff 0
    .auto.viewsel.view.menu add radiobutton -label "Scatter Plot" \
	    -variable viewselname -value "Scatter Plot" -command {
	set viewsel 0
    }
    .auto.viewsel.view.menu add radiobutton -label Image \
	    -variable viewselname -value Image -command {
	set viewsel 1
    }
    .auto.viewsel.view.menu add radiobutton -label "Bar Chart" \
	    -variable viewselname -value "Bar Chart" -command {
	set viewsel 2
    }
    set viewselname "Bar Chart"
    set viewsel 2

    checkbutton .auto.gdatasel.link -text "New Mappings" -variable newgdata
    pack .auto.gdatasel.link -side left -padx 3m
    set newgdata 1

    label .auto.colorsel.label -text "Background:"
    button .auto.colorsel.color -width 15 -textvariable bgcolor \
	-command "getColor bgcolor" -highlightthickness 0
    pack .auto.colorsel.label .auto.colorsel.color -side left -padx 1m
    set bgcolor "AntiqueWhite"

    checkbutton .auto.titlesel.title -text Title -variable titlesel
    pack .auto.titlesel.title -side left -padx 3m
    set titlesel 0

    checkbutton .auto.linksel.link -text "Link X" -variable linksel
    pack .auto.linksel.link -side left -padx 3m
    set linksel 1

    checkbutton .auto.xaxissel.xaxis -text "X Axis" -variable xaxissel
    pack .auto.xaxissel.xaxis -side left -padx 3m
    set xaxissel 0

    checkbutton .auto.yaxissel.yaxis -text "Y Axis" -variable yaxissel
    pack .auto.yaxissel.yaxis -side left -padx 3m
    set yaxissel 1
	
    if {$topgrp == "__default"} {
	set slabel "Select Y"
	set swidth 15
    } else {
	set slabel "Select Y from $topgrp"
	set swidth [expr [llength [split $topgrp {}]] + 15]
    }
    label .auto.ysel.label -text $slabel -width $swidth
    pack .auto.ysel.label -side top -fill x -expand 1 -pady 2m

    frame .auto.ysel.sel
    pack .auto.ysel.sel -side top -padx 3m -pady 1m -expand 1
    setupAttrCheckButtons .auto.ysel.sel yvar $schemaname $topgrp $topgrp

    # Try to select default X to be a sorted attribute
    set x [lindex [lindex $schema 0] 0]
    foreach attr $schema {
	set name [lindex $attr 0]
	set type [lindex $attr 1]
	set sorted [lindex $attr 2]
	if {$sorted > 0 && $name != "recId"} {
	    set x $name
	    break
	}
    }

    tk_menuBar .auto.xsel .auto.xsel.attr
    set cancel 0
	
    button .auto.but.ok -text OK -width 15 -command {
	if {![DEVise exists $windowsel]} {
	    dialog .winError "No Window Specified" \
		    "Please select a window for visualization." \
	    "" 0 OK
	   return
	}
	foreach yname [array names yvar] {
	    if {$yvar($yname) > 0} {
		set cancel 0
		return
	    }
	}
	dialog .autoError "Note" \
		"Please select one or more\n\
		Y attributes for automatic\n\
		mapping." "" 0 OK
	return
    }
    button .auto.but.cancel -text Cancel -width 15 -command {
	set cancel 1
    }
    pack .auto.but.ok .auto.but.cancel -side left -expand 1 -padx 3m
	

    tkwait variable cancel
    destroy .auto

    if {$cancel} {
	return
    }

    set ylist ""
    foreach yname [array names yvar] {
	if {$yvar($yname) > 0} {
	    lappend ylist $yname
	}
    }
    
    # puts "The value of x is $x"
    # puts "The ylist is $ylist"
    
    MacroDefAutoActual $tdata $viewsel $linksel $windowsel $bgcolor \
	    $titlesel $xaxissel $yaxissel $x $ylist $newgdata
}

############################################################

proc MacroDefAutoActual {tdata viewsel linksel window bgcolor
                         titlesel xaxissel yaxissel x ylist
                         newgdata} {
    global viewDefault

    set schema [DEVise getSchema $tdata]

    set colorAttr ""
    set sortedx 0
    set xlo ""
    set xhi ""

    # Find out type of X and whether it is sorted or not.
    # Also find out if there is a 'color' attribute.
    foreach attr $schema {
	set name [lindex $attr 0]
	set type [lindex $attr 1]
        if {[string tolower $name] == "color" && $type == "int"} {
            set colorAttr $name
        }
	if {$name != $x} {continue}
	set xtype [lindex $attr 1]
	set sortedx [lindex $attr 2]
	set hasxhi [lindex $attr 3]
	if {$hasxhi} {
	    set xhi [lindex $attr 4]
	}
	set hasxlo [lindex $attr 5]
	if {$hasxlo} {
	    set xlo [lindex $attr 6]
	}
	break
    }

    # Also consult lo/hi values defined in .rc file
    set viewParams ""
    catch { set viewParams $viewDefault($xtype) }
    foreach param $viewParams {
	set pname [lindex $param 0]
	set value [lindex $param 1]
	if {$xlo == "" && $pname == "xlow"} {
	    set xlo $value
	}
	if {$xhi == "" && $pname == "xhigh"} {
	    set xhi $value
	}
    }

    # if no defaults specified anywhere, resort to these defaults
    if {$xhi == ""} {
	set xhi 0
    }
    if {$xlo == ""} {
	set xlo 100
    }

    if {$xlo == $xhi} {
	incr xlo -1
	incr xhi +1
    }

    # puts "Mapping will have xlo $xlo and xhi $xhi"

    if {$sortedx > 0} {
	set sortedx SortedX
    } else {
	set sortedx Scatter
    }

    if {$linksel} {
	set linkname [format "%s Link" $x]
	if {![DEVise exists $linkname]} {
	    # ask DEVise to create link
	    set result [DEVise create link Visual_Link $linkname 1]
	    if {$result == ""} {
		dialog .linkError "Link Error" \
			"Error creating link $linkname" "" 0 OK
		return
	    }
	}
    }

    set color 2
    set shape $viewsel
    set size 1
    set pattern 0
    set orient 0
    set shapeAttr0 ""
    set shapeAttr1 ""

    if {$shape == 1} {
	# set pixel width and height to one for image displays
	set shape 0
	set shapeAttr0 1
	set shapeAttr1 1
    }

    foreach attr $schema {
	set name [lindex $attr 0]
	if {[lsearch $ylist $name] < 0} { continue }

	set type [lindex $attr 1]
	set sorted [lindex $attr 2]
	set yhi ""
	set hasyhi [lindex $attr 3]
	if {$hasyhi} {
	    set yhi [lindex $attr 4]
	    if {$viewsel == 2} {
		set yhi [ScaleUpper $yhi]
	    }
	}
	set ylo ""
	set hasylo [lindex $attr 5]
	if {$hasylo} {
	    set ylo [lindex $attr 6]
	    if {$viewsel == 2} {
		set ylo [ScaleLower $ylo]
	    }
	}

	# also consult lo/hi values defined in .rc file
	set viewParams ""
	catch { set viewParams $viewDefault($type) }
	foreach param $viewParams {
	    set pname [lindex $param 0]
	    set value [lindex $param 1]
	    if {$ylo == "" && $pname == "ylow"} {
		set ylo $value
	    }
	    if {$yhi == "" && $pname == "yhigh"} {
		set yhi $value
	    }
	}

	# if no defaults specified anywhere, resort to these defaults
	if {$yhi == ""} {
	    set yhi 0
	}
	if {$ylo == ""} {
	    set ylo 100
	}

	# for bar shape, make ylo zero
	if {$shape == 2} {
	    set ylo 0
	}

	if {$ylo == $yhi} {
	    incr ylo -1
	    incr yhi +1
	}

	# puts "Mapping will have ylo $ylo and yhi $yhi"

	# ask DEVise to create view instance
	set sorted $sortedx
	set viewbasename "View"
	set viewinstance [UniqueName $viewbasename]
	if {[lsearch [ViewSet] $viewinstance] >= 0} {
	    dialog .viewError "View Error" \
		    "View $viewinstance exists already." "" 0 OK
	    return
	}
	set result [DEVise create view $sorted $viewinstance \
		$xlo $xhi $ylo $yhi $bgcolor]
	if {$result == ""} {
	    dialog .viewError "View Error" \
		    "Error creating view $viewinstance" "" 0 OK
	    return
	}
	
	# ask DEVise to turn on/off label
	set titletext "$name vs. $x"
	if {[llength $ylist] == 1} {
	    set titletext $tdata
	}
	if {$titlesel} {
	    DEVise setLabel $viewinstance 1 16 $titletext
	} else {
	    DEVise setLabel $viewinstance 0 12 $titletext
	}

	# ask DEVise to turn on/off X axis
	DEVise setAxisDisplay $viewinstance X $xaxissel

	# ask DEVise to turn on/off Y axis
	DEVise setAxisDisplay $viewinstance Y $yaxissel

	# if new mappings are requested, associate color with mapping,
	# otherwise associate color with view
	if {0 && !$newgdata} {
	    DEVise setViewOverrideColor $viewinstance $color 1
	}

        # for map color, either use constant color, or variable
        # if defined in the schema
        set mapColor $color
        if {$colorAttr != ""} {
            set mapColor \$$colorAttr
        }

	set mapname [format "%s_vs_%s" $name $x]

	if {[lsearch [DEVise get mapping] $mapname] < 0} {
	    # ask DEVise to create interpreted mapping class
	    set result [DEVise createMappingClass $mapname]
	}

	set mapinstance "$tdata#$mapname"
	if {$newgdata} {
	    # new mappings are requested
	    set mapinstance [UniqueName $mapinstance]
	}
	if {[lsearch [GdataSet] $mapinstance] < 0} {
	    # ask DEVise to create an instance of mapping
	    set result [DEVise create mapping $mapname $tdata $mapinstance \
		    "" \$$x \$$name $mapColor $size $pattern $orient $shape \
		    $shapeAttr0 $shapeAttr1]
	    DEVise setPixelWidth $mapinstance 1
	}

	# ask DEVise to insert $mapinstance into $viewinstance
	set result [DEVise insertMapping $viewinstance $mapinstance]
	# seems that there's no error code returned

	# ask DEVise to insert $viewinstance into $window
	set result [DEVise insertWindow $viewinstance $window]
	# seems that there's no error code returned

	if {$linksel} {
	    # ask DEVise to link $viewinstance to $linkname
	    set result [DEVise insertLink $linkname $viewinstance]
	    # seems that there's no error code returned
	}

	DEVise clearViewHistory $viewinstance
	DEVise insertViewHistory $viewinstance $xlo $ylo $xhi $yhi 0

	ProcessViewSelected $viewinstance

	incr color
    }
}
