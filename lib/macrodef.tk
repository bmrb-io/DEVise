#  ========================================================================
#  DEVise Data Visualization Software
#  (c) Copyright 1992-1996
#  By the DEVise Development Group
#  Madison, Wisconsin
#  All Rights Reserved.
#  ========================================================================
#
#  Under no circumstances is this software to be copied, distributed,
#  or altered in any way without prior permission from the DEVise
#  Development Group.

############################################################

#	$Id$

#	$Log$
#	Revision 1.52  1996/07/13 00:21:13  jussi
#	Broke OpenNewDataSource into two parts so the DoColorStat can
#	reuse the latter part of it.
#
#	Revision 1.51  1996/07/12 21:54:44  jussi
#	Fixed minor typo.
#
#	Revision 1.50  1996/07/08 17:08:02  jussi
#	Small fix in OpenDataSource.
#
#	Revision 1.49  1996/07/01 19:37:33  jussi
#	Made changes to reflect new TData constructor interface. Web
#	data caching is now handled in the server, not in the client.
#
#	Revision 1.48  1996/06/20 17:14:09  guangshu
#	Added support for derived TData sets (statistics for now).
#
#	Revision 1.47  1996/06/16 01:32:53  jussi
#	Added handling of case where xlo == xhi or ylo == yhi.
#
#	Revision 1.46  1996/06/13 23:00:22  jussi
#	Fixed minor bug with New Mapping check button.
#
#	Revision 1.45  1996/06/04 14:22:06  wenger
#	Ascii data can now be read from session files (or other files
#	where the data is only part of the file); added some assertions
#	to check for pointer alignment in functions that rely on this;
#	Makefile changes to make compiling with debugging easier.
#
#	Revision 1.44  1996/05/11 03:00:01  jussi
#	Minor improvements. Changes made towards caching multiple
#	data sources in one step.
#
#	Revision 1.43  1996/05/09 18:15:16  kmurli
#	No changes, just inserted some debugging print statements and
#	removed them
#
#	Revision 1.42  1996/05/05 03:05:11  jussi
#	Automatic adjustment of Y axis scale is done for bar charts only.
#
#	Revision 1.41  1996/04/23 20:39:10  jussi
#	Corrected default value of view label.
#
#	Revision 1.40  1996/04/23 14:40:25  jussi
#	Added mising variable name to global name list, fixed color
#	assignment with new mappings.
#
#	Revision 1.39  1996/04/11 18:23:02  jussi
#	Major changes in the organization of the user interface.
#
#	Revision 1.38  1996/03/26 21:16:13  jussi
#	Added scaling of axis values to nearest "reasonable" value.
#
#	Revision 1.37  1996/02/05 19:55:12  jussi
#	Background color is chosen from a palette of colors instead of
#	a list of color names.
#
#	Revision 1.36  1996/02/01 18:31:13  jussi
#	Improved handling of errors in extracting from data from
#	external source.
#
#	Revision 1.35  1996/01/30 00:06:13  jussi
#	Minor improvements in visual appearance.
#
#	Revision 1.34  1996/01/27 00:45:10  jussi
#	User can now select background color of a new window.
#
#	Revision 1.33  1996/01/23 20:48:48  jussi
#	Added MacroImport which, temporarily, uses almost identical
#	duplicates of MacroDefAuto and MacroDefAutoActual. When the
#	old interface is obsoleted, the older versions of these two
#	procedures will be removed.
#
#	Revision 1.32  1996/01/17 19:27:34  jussi
#	Minor fix.
#
#	Revision 1.31  1996/01/16 01:30:16  jussi
#	Some reorganization of code. Removed duplicate code etc.
#
#	Revision 1.30  1996/01/13 23:09:49  jussi
#	Added support for Z attribute and shape attribute 2.
#
#	Revision 1.29  1996/01/13 20:56:26  jussi
#	Reorganized code that opens a data source. The same routine
#	(OpenDataSource) is now used in the session file.
#
#	Revision 1.28  1996/01/11 21:01:44  jussi
#	Data stream is cached before schema is read; this is because
#	for SEQ the schema is produced as part of the caching step.
#
#	Revision 1.27  1996/01/10 18:48:46  jussi
#	Attribute hi/lo values now take their values from either the
#	schema or the .rc file (schema has precedence). For bar charts,
#	ylo is 0 by default.
#
#	Revision 1.26  1996/01/10 00:38:42  jussi
#	Added support for hi/lo values defined in schema.
#
#	Revision 1.25  1995/12/29 17:33:04  jussi
#	Changed format of view instance names created automatically.
#	Removed Double-Button-1 binding of group selection list.
#	Cleaned up code that initializes associative arrays.
#
#	Revision 1.24  1995/12/14 15:49:16  jussi
#	Added support for TileLayout with automatic or manual view layout
#	control.
#
#	Revision 1.23  1995/12/13 02:06:06  ravim
#	Changed criterion for not reloading the schema.
#
#	Revision 1.22  1995/12/04 18:28:15  jussi
#	Changed size of automatically created windows to depend on view
#	layout selected. For horizontal layout, the window is wide, for
#	vertical layout, it's tall.
#
#	Revision 1.21  1995/12/04 18:02:33  jussi
#	User can now choose to have a title, X axis, Y axis, X link enabled
#	or disabled in automatically generated views. Window name can be
#	specified too. Horizontal view layouts are available now.
#
#	Revision 1.20  1995/11/29 15:47:26  jussi
#	Removed constant size definition from some toplevel windows
#	because they will produce unexpected results on some window
#	managers.
#
#	Revision 1.19  1995/11/22 17:53:46  jussi
#	Added view type selection in automatic view generation. User can
#	now choose between a bar chart, an image, and a scatter plot.
#
#	Revision 1.18  1995/11/20 22:22:54  jussi
#	Changed sequence of caching data from tape to disk.
#	Restored missing history log.
#
#	Revision 1.17  1995/11/19 06:04:29  ravim
#	New way of displaying attributes and groups.
#
#	Revision 1.16  1995/11/18 01:49:46  ravim
#	Groups associated with schema. Also groups chosen at "Auto" stage.
#
#	Revision 1.15  1995/11/14 22:50:39  jussi
#	Interfaced new stream selection dialog into DefSource. Minor other
#	changes.
#
#	Revision 1.14  1995/11/07 20:24:48  jussi
#	Commented out some output statements.
#
#	Revision 1.13  1995/11/06 16:33:33  jussi
#	Increased minimum vertical size of .map window.
#
#	Revision 1.12  1995/10/29 01:01:12  ravim
#	Bug fix.
#
#	Revision 1.11  1995/10/27 21:05:03  ravim
#	Handles group names starting with capital letters.
#
#	Revision 1.10  1995/10/11 17:07:21  ravim
#	Minor changes.
#
#	Revision 1.9  1995/09/30 08:00:52  ravim
#	No changes - Ignore.
#
#	Revision 1.8  1995/09/30 07:59:18  ravim
#	Minor changes to group handling
#
#	Revision 1.7  1995/09/30 07:56:11  ravim
#	Initial implementation of schema browser - can create new schema files
#
#	Revision 1.6  1995/09/28 17:44:03  jussi
#	Included size, pattern, and orientation in all mapping definitions
#	although these are not used by DEVise currently. Minor other
#	touch-ups.
#
#	Revision 1.5  1995/09/27 17:20:34  ravim
#	Added support for groups in schemas.
#
#	Revision 1.4  1995/09/26 23:09:02  jussi
#	Added color/shape/size/pattern/orientation settings to view
#	definition.
#
#	Revision 1.3  1995/09/22 17:33:47  jussi
#	Added copyright message.
#
#	Revision 1.2  1995/09/21 15:36:27  jussi
#	Added small icons.
#
#	Revision 1.1  1995/09/13 14:24:07  jussi
#	Extracted macro definition code from control.tk.

############################################################

proc MacroDefInit {} {
    global macroSelectedColor macroUnselectedColor macroLinkColor
    global macroSelectColor macroMenuSelectColor macroActiveColor

    set macroSelectedColor LightBlue
    set macroUnselectedColor LightPink
    set macroLinkColor LightBlue
    set macroSelectColor #e6ceb1
    set macroMenuSelectColor white
    set macroActiveColor #e6ceb1

    MacroDefClear
}

############################################################

proc MacroDefLoad {} {
    global tdatas schemas maps mappings views links windows modified

    set tdatas ""
    catch {unset schemas}
    catch {unset maps}
    catch {unset mappings}
    catch {unset links}
    catch {unset windows}
    catch {unset views}

    foreach schema [DEVise get tdata] {
	set err [catch {set exists $maps($schema)}]
	if {$err > 0} { set maps($schema) "" }
	foreach tdata [DEVise get tdata $schema] {
	    set params [DEVise getCreateParam tdata $schema $tdata]
	    set filePath [lindex $params 0]
	    set fileAlias [lindex $params 1]
	    lappend tdatas [list $fileAlias $filePath]
	    set sdef [DEVise getSchema $tdata]
	    set schemas($tdata) [list $schema $sdef]
	}
    }

    foreach class [lsort [DEVise get "mapping"]] {
	foreach mapping [lsort [DEVise get "mapping" $class]] {
	    set params [DEVise getCreateParam "mapping" $class $mapping]
	    set tdata [lindex $params 0]
	    set schema [lindex $schemas($tdata) 0]
	    set mapname [lindex $params 1]
	    set firsthash [string first \# $mapname]
	    if {$firsthash >= 0} {
		incr firsthash
		set mapname [string range $mapname $firsthash end]
	    }
	    set x [string range [lindex $params 3] 1 end]
	    set y [string range [lindex $params 4] 1 end]
	    set color [lindex $params 5]
	    set size [lindex $params 6]
	    set pattern [lindex $params 7]
	    set orient [lindex $params 8]
	    set shape [lindex $params 9]
	    set shapeAttr0 [lindex $params 10]
	    set shapeAttr1 [lindex $params 11]
	    set defn [list $x $y $color $size $pattern $orient $shape \
		    $shapeAttr0 $shapeAttr1]
	    set mappings($mapname) $defn
	    if {[string first $mapname $maps($schema)] < 0} {
		lappend maps($schema) $mapname
	    }
	}
    }

    foreach class [lsort [DEVise get "window"]] {
	foreach window [lsort [DEVise get "window" $class]] {
	    set params [DEVise getCreateParam "window" $class $window]
	    set name [lindex $params 0]
	    set windows($name) [lrange $params 1 end]
	}
    }

    foreach class [lsort [DEVise get "link"]] {
	foreach link [lsort [DEVise get "link" $class]] {
	    set params [DEVise getCreateParam "link" $class $link]
	    set name [lindex $params 0]
	    set links($name) [lrange $params 1 end]
	}
    }

    foreach class [lsort [DEVise get "view"]] {
	foreach view [lsort [DEVise get "view" $class]] {
	    set params [DEVise getCreateParam "view" $class $view]
	    set name [lindex $params 0]
	    set views($name) [lrange $params 1 end]
	}
    }

    set modified 0
}

############################################################

proc MacroDef {} {
    global tdatas schemas maps mappings views links windows
    global tdata window gdata view link none

    set none "-- None --"

    if {[WindowVisible .map]} {
	return
    }

    toplevel .map
    wm title .map "Define Visualization"
    wm geometry .map +50+50
    selection clear .map

    frame .map.top
    frame .map.bot
    pack .map.top -side top -pady 3m -fill both -expand 1
    pack .map.bot -side top -pady 5m -fill x

    frame .map.bot.but
    pack .map.bot.but -side top

    button .map.bot.but.close -text Close -width 10 -command {
	destroy .map
    }
    button .map.bot.but.create -text Create -width 10 -command {
	MacroDefNewMapping
    }
    button .map.bot.but.auto -text "Auto..." -width 10 -command {
	MacroDefAuto $tdata
    }

    CreateBitmapButton .map.bot.but.help help.gif Help MacroDefHelp
    button .map.bot.but.help -text Help -width 40 -command MacroDefHelp
    pack .map.bot.but.close .map.bot.but.create .map.bot.but.auto \
	    .map.bot.but.help -side left -padx 5m

    frame .map.left -relief groove -borderwidth 2
    frame .map.right -relief groove -borderwidth 2
    pack .map.left .map.right -in .map.top -side left \
	    -fill both -expand 1

    frame .map.tdata
    frame .map.window
    frame .map.gdata
    frame .map.view
    frame .map.link
    pack .map.tdata .map.window -in .map.left -side top -pady 3m \
	    -fill both -expand 1
    pack .map.gdata .map.view .map.link -in .map.right -side top -pady 3m \
	    -fill both -expand 1

    MacroDefLoad

    MacroDefTdata .map.tdata "$none"
    MacroDefWindows .map.window "$none"
    MacroDefMaps .map.gdata "$none"
    MacroDefViews .map.view "$none"
    MacroDefLinks .map.link "$none"

    tkwait visibility .map
}

############################################################

proc MacroDefNewMapping {} {
    global tdatas schemas maps mappings views links windows
    global tdata window gdata view link none

    if {$tdata == $none || $window == $none \
	|| $gdata == $none || $view == $none} {
	dialog .createError "Note" \
		"Please select a data source, a window,\n\
		a mapping and a view and then press Create." \
		"" 0 OK
	return
    }

    set x [lindex $mappings($gdata) 0]
    set y [lindex $mappings($gdata) 1]
    set color [lindex $mappings($gdata) 2]
    set size [lindex $mappings($gdata) 3]
    set pattern [lindex $mappings($gdata) 4]
    set orient [lindex $mappings($gdata) 5]
    set shape [lindex $mappings($gdata) 6]
    set shapeAttr0 ""
    set shapeAttr1 ""

    # ask DEVise to create view instance
    set sorted SortedX
    set viewname [UniqueName "$y vs. $x"]
    if {[lsearch [ViewSet] $viewname] >= 0} {
	dialog .viewError "View Error" \
		"View $viewname exists already." "" 0 OK
	return
    }
    set cmd [concat DEVise create view $sorted \{$viewname\} $views($view)]
    set result [eval $cmd]
    if {$result == ""} {
	dialog .viewError "View Error" \
		"Error creating view $viewname" "" 0 OK
	return
    }

    if {[lsearch [DEVise get mapping] $gdata] < 0} {
	# ask DEVise to create interpreted mapping
	# parameter format: x y color size pattern orientation shape
	set result [DEVise createInterp $tdata $gdata "" \$$x \$$y "" \
		$color $size $pattern $orient $shape $shapeAttr0 \
		$shapeAttr1 ""]
    }

    set mapinstance "$tdata#$gdata" 
    if {[lsearch [GdataSet] $mapinstance] < 0} {
	# ask DEVise to create an instance of mapping
	set result [DEVise create mapping $gdata $tdata $mapinstance \
		"" \$$x \$$y $color $size $pattern $orient $shape \
		$shapeAttr0 $shapeAttr1]
	DEVise setPixelWidth $mapinstance 1
    }

    # ask DEVise to insert $viewname into $mapinstance
    set result [DEVise insertMapping $viewname $mapinstance]
    # seems that there's no error code returned

    # ask DEVise to insert $viewname into $window
    set result [DEVise insertWindow $viewname $window]
    # seems that there's no error code returned

    if {$link != $none} {
	# ask DEVise to link $viewname to $link
	set result [DEVise insertLink $link $viewname]
	# seems that there's no error code returned
    }

    ProcessViewSelected $viewname

    # DoToggleAxis X
    DoToggleAxis Y
}

############################################################

proc MacroDefClear {} {
    global tdatas schemas maps mappings views links windows

    set tdatas ""

    catch {unset schemas}
    catch {unset maps}
    catch {unset mappings}
    catch {unset views}
    catch {unset links}
    catch {unset windows}
}

############################################################

proc MacroDefHelp {} {
    if {[WindowVisible .help]} {
	return
    }

    toplevel .help
    wm title .help "Help"
    wm geometry .help +100+100
    message .help.msg -justify center -width 10c \
	    -text "You can create a new visualization by selecting\
	           a data source, window, mapping, and view, and then\
		   pressing Create. To select any of these items, pull\
		   down the corresponding menu and select an existing\
		   item from the menu, or select New to create a new\
		   item.\n\n\
		   From the Link menu you can choose an existing link\
		   to link the new visualization to existing\
		   visualizations,\
		   or you can create a new link by choosing the New\
		   item from the Link menu, or you can leave the new\
		   visualization unlinked by choosing None.\n\n\
		   To create automatic views, select a data source and\
		   then press Auto. Select the attribute you want on the\
		   X axis and the set of attributes you want on the Y\
		   axis. Click OK, and you will see a new window with\
		   the views you selected. All views are linked on the\
		   X axis.\n\n\
		   Click on Close when you're done."
    button .help.ok -text OK -width 10 -command "destroy .help"
    pack .help.msg .help.ok -side top -padx 5m -pady 3m

    tkwait visibility .help
}

############################################################

proc SelectTopGroup {schemaname} {
    global selgrp

    # get the list of top level group names from DEVise
    set topgrps [DEVise getTopGroups $schemaname]

    if {[llength $topgrps] == 1 && [lindex $topgrps 0] == "__default"} {
	return "__default"
    }

    # Create window to show list of top level group names
    toplevel .topgrps
    wm title .topgrps "Choose Attribute Group"
    wm geometry .topgrps +100+100
    selection clear .topgrps
    listbox .topgrps.list -relief raised -borderwidth 2 \
	    -yscrollcommand ".topgrps.scroll set" \
	    -font 9x15 -selectmode single
    scrollbar .topgrps.scroll -command ".topgrps.list yview"
    button .topgrps.ok -text OK -command {
	set selgrp [.topgrps.list get active]
	destroy .topgrps
    }
    pack .topgrps.ok -side bottom -fill x
    pack .topgrps.scroll -side right -fill y
    pack .topgrps.list -fill x 
    
    foreach i $topgrps {
	.topgrps.list insert end $i
    }
    
    tkwait visibility .topgrps
    grab set .topgrps
    tkwait window .topgrps

    return $selgrp
}

############################################################

proc MacroDefAuto {tdata} {
    global schemas modified x yvar schemaname schema
    global viewsel viewselname macroSelectColor macroMenuSelectColor
    global layoutsel linksel winnamesel titlesel
    global xaxissel yaxissel sourceList

    if {[WindowVisible .auto]} {
	return
    }

    set sname [lindex $schemas($tdata) 0]
    set schema [ElimStringAttr [lindex $schemas($tdata) 1]]
    set sfname [lindex $sourceList($tdata) 3]
    set schemaname [file tail $sfname]

    set topgrp [SelectTopGroup $schemaname]

    toplevel .auto
    wm title .auto "Automatic Views"
    wm geometry .auto +100+100
    selection clear .auto

    label .auto.label -text "Select Auto Parameters"
    frame .auto.top
    frame .auto.mid
    frame .auto.bot
    frame .auto.ysel -relief groove -borderwidth 2
    frame .auto.but
    pack .auto.label -side top -pady 3m -fill x -expand 1
    pack .auto.top -side top -pady 3m -fill x -expand 1
    pack .auto.mid -side top -pady 3m -fill x -expand 1
    pack .auto.bot -side top -pady 3m -fill x -expand 1
    pack .auto.ysel -side top -pady 3m -fill x -expand 1
    pack .auto.but -side top -pady 3m -fill x -expand 1

    frame .auto.winnamesel -relief groove -borderwidth 2
    frame .auto.xsel -relief groove -borderwidth 2
    pack .auto.winnamesel .auto.xsel -in .auto.top -side left \
	    -ipady 3m -padx 3m -fill x -expand 1

    frame .auto.viewsel -relief groove -borderwidth 2
    frame .auto.layoutsel -relief groove -borderwidth 2
    pack .auto.viewsel .auto.layoutsel -in .auto.mid \
	    -side left -ipady 3m -padx 3m -fill x -expand 1

    frame .auto.titlesel -relief groove -borderwidth 2
    frame .auto.linksel -relief groove -borderwidth 2
    frame .auto.xaxissel -relief groove -borderwidth 2
    frame .auto.yaxissel -relief groove -borderwidth 2
    pack .auto.titlesel .auto.linksel .auto.xaxissel .auto.yaxissel \
	    -in .auto.bot -side left -ipady 3m -padx 3m -fill x -expand 1

    label .auto.winnamesel.label -text "Window Name:"
    entry .auto.winnamesel.entry -relief sunken -textvariable winnamesel \
	    -width 30
    pack .auto.winnamesel.label .auto.winnamesel.entry -side left -padx 3m
    set winnamesel "$tdata (Auto)"

    label .auto.xsel.label -text "Select X:"
    menubutton .auto.xsel.attr -relief raised \
	    -textvariable x -menu .auto.xsel.attr.g$topgrp -width 15
    pack .auto.xsel.label .auto.xsel.attr -side left -padx 3m
    setupAttrRadioMenu .auto.xsel.attr.g$topgrp x "" $schemaname \
	    $topgrp $topgrp

    label .auto.viewsel.label -text "View Type:"
    menubutton .auto.viewsel.view -relief raised \
	    -textvariable viewselname -menu .auto.viewsel.view.menu -width 15
    pack .auto.viewsel.label .auto.viewsel.view -side left -padx 3m

    menu .auto.viewsel.view.menu -tearoff 0
    .auto.viewsel.view.menu add radiobutton -label "Scatter Plot" \
	    -variable viewselname -value "Scatter Plot" -command {
	set viewsel 0
    }
    .auto.viewsel.view.menu add radiobutton -label Image \
	    -variable viewselname -value Image -command {
	set viewsel 1
    }
    .auto.viewsel.view.menu add radiobutton -label "Bar Chart" \
	    -variable viewselname -value "Bar Chart" -command {
	set viewsel 2
    }
    set viewselname "Bar Chart"
    set viewsel 2

    label .auto.layoutsel.label -text "Layout:"
    menubutton .auto.layoutsel.layout -relief raised \
	    -textvariable layoutsel -menu .auto.layoutsel.layout.menu \
	    -width 15
    pack .auto.layoutsel.label .auto.layoutsel.layout -side left -padx 3m

    menu .auto.layoutsel.layout.menu -tearoff 0
    .auto.layoutsel.layout.menu add radiobutton -label Tiled \
	    -variable layoutsel -value Tiled
    .auto.layoutsel.layout.menu add radiobutton -label Vertical \
	    -variable layoutsel -value Vertical
    .auto.layoutsel.layout.menu add radiobutton -label Horizontal \
	    -variable layoutsel -value Horizontal
    set layoutsel Vertical

    checkbutton .auto.titlesel.title -text Title -variable titlesel
    pack .auto.titlesel.title -side left -padx 3m
    set titlesel 0

    checkbutton .auto.linksel.link -text "Link X" -variable linksel
    pack .auto.linksel.link -side left -padx 3m
    set linksel 1

    checkbutton .auto.xaxissel.xaxis -text "X Axis" -variable xaxissel
    pack .auto.xaxissel.xaxis -side left -padx 3m
    set xaxissel 0

    checkbutton .auto.yaxissel.yaxis -text "Y Axis" -variable yaxissel
    pack .auto.yaxissel.yaxis -side left -padx 3m
    set yaxissel 1

    if {$topgrp == "__default"} {
	set slabel "Select Y"
	set swidth 15
    } else {
	set slabel "Select Y from $topgrp"
	set swidth [expr [llength [split $topgrp {}]] + 15]
    }
    label .auto.ysel.label -text $slabel -width $swidth
    pack .auto.ysel.label -side top -fill x -expand 1 -pady 2m

    frame .auto.ysel.sel
    pack .auto.ysel.sel -side top -padx 3m -pady 1m -expand 1
    setupAttrCheckButtons .auto.ysel.sel yvar $schemaname $topgrp $topgrp

    # Try to select default X to be a sorted attribute
    set x [lindex [lindex $schema 0] 0]
    foreach attr $schema {
	set name [lindex $attr 0]
	set type [lindex $attr 1]
	set sorted [lindex $attr 2]
	if {$sorted > 0 && $name != "recId"} {
	    set x $name
	    break
	}
    }

    tk_menuBar .auto.xsel .auto.xsel.attr

    button .auto.but.ok -text OK -width 15 -command {
	set ylist ""
	foreach yname [array names yvar] {
	    if {$yvar($yname) > 0} {
		lappend ylist $yname
	    }
	}
	if {$ylist == ""} {
	    dialog .autoError "Note" \
		    "Please select one or more\n\
		    Y attributes for automatic\n\
		    mapping." "" 0 OK
	    return
	}

	# puts "The value of x is $x"
	# puts "The ylist is $ylist"

	MacroDefAutoActual $tdata $viewsel $linksel $winnamesel $layoutsel \
		$titlesel $xaxissel $yaxissel $x $ylist
	destroy .auto
    }
    button .auto.but.cancel -text Cancel -width 15 -command {
	destroy .auto
    }
    pack .auto.but.ok .auto.but.cancel -side left -expand 1 -padx 3m

    tkwait visibility .auto
}

############################################################

proc MacroDefAutoActual {tdata viewsel linksel window layout titlesel
                         xaxissel yaxissel x ylist} {
    global schemas maps mappings views links windows modified none
    global viewDefault

    set window [UniqueName $window]

    set err [catch {set exists $windows($window)}]
    if {$err > 0} {
	# ask DEVise to create window
	if {$layout == "Tiled"} {
	    set winparam "0.3 0.3 0.4 0.4"
	    set layoutparam "-1 -1"
	} elseif {$layout == "Vertical" } {
	    set winparam "0.3 0.15 0.4 0.7"
	    set layoutparam "-1 1"
	} else {
	    set winparam "0.15 0.3 0.7 0.4"
	    set layoutparam "1 -1"
	}
	set cmd "DEVise create window TileLayout \{$window\} $winparam"
	set result [eval $cmd]
	if {$result == ""} {
	    dialog .windowError "Window Error" \
		    "Error creating window $window" "" 0 OK
	    return
	}
	set windows($window) $winparam
	eval "DEVise setWindowLayout \{$window\} $layoutparam"
    }
    
    set schema [ElimStringAttr [lindex $schemas($tdata) 1]]
	
    set bgColor white
    set sortedx 0
    set xlo ""
    set xhi ""

    # Find out type of X and whether it is sorted or not
    foreach attr $schema {
	set name [lindex $attr 0]
	if {$name != $x} {continue}
	set xtype [lindex $attr 1]
	set sortedx [lindex $attr 2]
	set hasxhi [lindex $attr 3]
	if {$hasxhi} {
	    set xhi [lindex $attr 4]
	}
	set hasxlo [lindex $attr 5]
	if {$hasxlo} {
	    set xlo [lindex $attr 6]
	}
	break
    }

    # also consult lo/hi values defined in .rc file
    set viewParams ""
    catch { set viewParams $viewDefault($xtype) }
    foreach param $viewParams {
	set pname [lindex $param 0]
	set value [lindex $param 1]
	if {$xlo == "" && $pname == "xlow"} {
	    set xlo $value
	}
	if {$xhi == "" && $pname == "xhigh"} {
	    set xhi $value
	}
    }

    # if no defaults specified anywhere, resort to these defaults
    if {$xhi == ""} {
	set xhi 0
    }
    if {$xlo == ""} {
	set xlo 100
    }

    # puts "Mapping will have xlo $xlo and xhi $xhi"

    if {$sortedx > 0} {
	set sortedx SortedX
    } else {
	set sortedx Scatter
    }

    set linkname [format "%s Link" $x]
    if {$linksel} {
	set err [catch {set exists $links($linkname)}]
	if {$err > 0} {
	    # ask DEVise to create link
	    set result [DEVise create link Visual_Link $linkname 1]
	    if {$result == ""} {
		dialog .linkError "Link Error" \
			"Error creating link $linkname" "" 0 OK
		return
	    }
	    set flag 1
	    set links($linkname) $flag
	}
    }

    set sname [lindex $schemas($tdata) 0]
    set color 2
    set shape $viewsel
    set size 1
    set pattern 0
    set orient 0
    set shapeAttr0 ""
    set shapeAttr1 ""

    if {$shape == 1} {
	# set pixel width and height to one for image displays
	set shape 0
	set shapeAttr0 1
	set shapeAttr1 1
    }

    foreach attr $schema {
	set name [lindex $attr 0]
	if {[lsearch $ylist $name] < 0} { continue }

	set type [lindex $attr 1]
	set sorted [lindex $attr 2]
	set yhi ""
	set hasyhi [lindex $attr 3]
	if {$hasyhi} {
	    set yhi [lindex $attr 4]
	    if {$viewsel == 2} {
		set yhi [ScaleUpper $yhi]
	    }
	}
	set ylo ""
	set hasylo [lindex $attr 5]
	if {$hasylo} {
	    set ylo [lindex $attr 6]
	    if {$viewsel == 2} {
		set ylo [ScaleLower $ylo]
	    }
	}

	# also consult lo/hi values defined in .rc file
	set viewParams ""
	catch { set viewParams $viewDefault($type) }
	foreach param $viewParams {
	    set pname [lindex $param 0]
	    set value [lindex $param 1]
	    if {$ylo == "" && $pname == "ylow"} {
		set ylo $value
	    }
	    if {$yhi == "" && $pname == "yhigh"} {
		set yhi $value
	    }
	}

	# if no defaults specified anywhere, resort to these defaults
	if {$yhi == ""} {
	    set yhi 0
	}
	if {$ylo == ""} {
	    set ylo 100
	}

	# for bar shape, make ylo zero
	if {$shape == 2} {
	    set ylo 0
	}

	# puts "Mapping will have ylo $ylo and yhi $yhi"

	set mapname [format "%s_vs_%s" $name $x]
	set err [catch {set exists $mappings($mapname)}]
	if {$err > 0} {
	    set defn [list $x $name $color $size $pattern $orient $shape]
	    set mappings($mapname) $defn
	    lappend maps($sname) $mapname
	}

	set viewname [format "%s View" $name]
	set err [catch {set exists $views($viewname)}]
	if {$err > 0} {
	    set defn [list $xlo $xhi $ylo $yhi $bgColor]
	    set views($viewname) $defn
	}

	# ask DEVise to create view instance
	set sorted $sortedx
	set viewbasename "$name vs. $x"
	set viewinstance [UniqueName $viewbasename]
	if {[lsearch [ViewSet] $viewinstance] >= 0} {
	    dialog .viewError "View Error" \
		    "View $viewinstance exists already." "" 0 OK
	    return
	}

	set result [DEVise create view $sorted $viewinstance \
		$xlo $xhi $ylo $yhi $bgColor]
	if {$result == ""} {
	    dialog .viewError "View Error" \
		    "Error creating view $viewinstance" "" 0 OK
	    return
	}
	
	# ask DEVise to turn on/off label
	if {$titlesel} {
	    DEVise setLabel $viewinstance 1 16 $viewbasename
	}

	# ask DEVise to turn on/off X axis
	DEVise setAxisDisplay $viewinstance X $xaxissel

	# ask DEVise to turn on/off Y axis
	DEVise setAxisDisplay $viewinstance Y $yaxissel

	if {[lsearch [DEVise get mapping] $mapname] < 0} {
	    # ask DEVise to create interpreted mapping
	    # parameter format: x y color size pattern orientation shape
	    set result [DEVise createInterp $tdata $mapname "" \$$x \$$name \
		    "" $color $size $pattern $orient $shape $shapeAttr0 \
		    $shapeAttr1 ""]
	}

	set mapinstance [UniqueName "$tdata#$mapname"]
	# ask DEVise to create an instance of mapping
	set result [DEVise create mapping $mapname $tdata $mapinstance \
		"" \$$x \$$name $color $size $pattern $orient $shape \
		$shapeAttr0 $shapeAttr1]
	DEVise setPixelWidth $mapinstance 1

	# ask DEVise to insert $viewinstance into $mapinstance
	set result [DEVise insertMapping $viewinstance $mapinstance]
	# seems that there's no error code returned

	# ask DEVise to insert $viewinstance into $window
	set result [DEVise insertWindow $viewinstance $window]
	# seems that there's no error code returned

	if {$linksel} {
	    # ask DEVise to link $viewinstance to $linkname
	    set result [DEVise insertLink $linkname $viewinstance]
	    # seems that there's no error code returned
	}

	DEVise clearViewHistory $viewinstance
	DEVise insertViewHistory $viewinstance $xlo $ylo $xhi $yhi 0

	ProcessViewSelected $viewinstance

	incr color
    }

    MacroDefWindows .map.window $none
    MacroDefMaps .map.gdata $none
    MacroDefViews .map.view $none
    MacroDefLinks .map.link $none

    set modified 1
}

############################################################

proc MacroDefTdata {m default} {
    global tdatas tdata modified none
    global macroSelectedColor macroUnselectedColor macroActiveColor

    catch {destroy $m.mbar}
    catch {destroy $m.label}

    set tdata $none
    set defExists 0

    menubutton $m.mbar -relief raised -textvariable tdata \
	    -menu $m.mbar.menu -width 24 -background $macroUnselectedColor \
	    -activebackground $macroActiveColor -justify left
    CreateTextBitmap $m.label file.gif Source
    pack $m.label $m.mbar -side left -padx 2m
    menu $m.mbar.menu -tearoff 0
    foreach t $tdatas {
	set name [lindex $t 0]
	$m.mbar.menu add command -label $name \
		-command "set tdata \"$name\"; \
		          MacroDefMaps .map.gdata \"$none\""
	if {$tdata == $none} {
	    set tdata $name
	}
	if {$default == $name} {
	    set defExists 1
	}
    }

    if {$default != $none && $defExists > 0} {
	set tdata $default
    }

    if {$tdata != $none} {
	# fix: .map.bot.but.auto should be a parameter
	.map.bot.but.auto configure -state normal
	$m.mbar configure -background $macroSelectedColor \
		-activebackground $macroActiveColor
    } else {
	.map.bot.but.auto configure -state disabled
    }

    $m.mbar.menu add command -label "Open..." \
	    -command {
	set sname [DefSource]
	if {$sname != ""} {
	    # fix this: .map.tdata should be $m
	    MacroDefTdata .map.tdata $sname
	    MacroDefMaps .map.gdata $none
	    set modified 1
	}
    }
    tk_menuBar $m $m.mbar
}

############################################################

proc MacroDefWindows {m default} {
    global windows window modified none
    global macroSelectedColor macroUnselectedColor
    global libdir

    catch {destroy $m.mbar}
    catch {destroy $m.label}

    set window $none
    set defExists 0

    menubutton $m.mbar -relief raised -textvariable window \
	    -menu $m.mbar.menu -width 24 \
	    -background $macroUnselectedColor -justify left
    CreateTextBitmap $m.label window.gif Window
    pack $m.label $m.mbar -side left -padx 2m
    menu $m.mbar.menu -tearoff 0
    foreach win [lsort [array names windows]] {
	$m.mbar.menu add command -label $win \
		-command "set window \"$win\""
	if {$window == $none} {
	    set window $win
	}
	if {$default == $win} {
	    set defExists 1
	}
    }

    if {$default != $none && $defExists > 0} {
	set window $default
    }

    if {$window != $none} {
	$m.mbar configure -background $macroSelectedColor
    }

    $m.mbar.menu add command -label "New..." \
	    -command {
	set winname [DefWindow]
	if {$winname != ""} {
	    # fix this: .map.window should be $m
	    MacroDefWindows .map.window $winname
	    set modified 1
	}
    }
    tk_menuBar $m $m.mbar
}

############################################################

proc MacroDefMaps {m default} {
    global schemas maps mappings tdata gdata modified none DEViseColors
    global macroSelectedColor macroUnselectedColor

    catch {destroy $m.mbar}
    catch {destroy $m.label}

    set gdata $none
    set defExists 0

    foreach color $DEViseColors {
	set idx [lindex $color 0]
	set name [lindex $color 1]
	set devcolors($idx) $name
    }

    menubutton $m.mbar -relief raised -textvariable gdata \
	    -menu $m.mbar.menu -width 20 -background $macroUnselectedColor
    if {$tdata != $none} {
	$m.mbar configure -state normal
    } else {
	$m.mbar configure -state disabled
    }
    CreateTextBitmap $m.label chart.gif Mapping
    pack $m.label $m.mbar -side left -padx 2m
    menu $m.mbar.menu -tearoff 0
    if {$tdata != $none} {
	set schema [lindex $schemas($tdata) 0]
	foreach map [lsort $maps($schema)] {
	    # someday use $color to configure color of button
	    # set color $devcolors([lindex $mappings($map) 2])
	    $m.mbar.menu add command -label $map \
		    -command "set gdata \"$map\""
	    if {$gdata == $none} {
		set gdata $map
	    }
	    if {$default == $map} {
		set defExists 1
	    }
	}
    }

    if {$default != $none && $defExists > 0} {
	set gdata $default
    }

    if {$gdata != $none} {
	$m.mbar configure -background $macroSelectedColor
    }

    if {$tdata != $none} {
	$m.mbar.menu add command -label "New..." \
		-command {
	    set sname [lindex $schemas($tdata) 0]
	    set schema [lindex $schemas($tdata) 1]
	    set mapname [DefMapping $tdata $schema]
	    if {$mapname != ""} {
		lappend maps($sname) $mapname
		# fix this: .map.gdata should be $m
		MacroDefMaps .map.gdata $mapname
		set modified 1
	    }
	}
    }
    tk_menuBar $m $m.mbar
}

############################################################

proc MacroDefViews {m default} {
    global views view modified none
    global macroSelectedColor macroUnselectedColor

    catch {destroy $m.mbar}
    catch {destroy $m.label}

    set view $none
    set defExists 0

    menubutton $m.mbar -relief raised -textvariable view \
	    -menu $m.mbar.menu -width 20 -background $macroUnselectedColor
    CreateTextBitmap $m.label view.gif View
    pack $m.label $m.mbar -side left -padx 2m
    menu $m.mbar.menu -tearoff 0
    foreach v [lsort [array names views]] {
	$m.mbar.menu add command -label $v \
		    -command "set view \"$v\""
	if {$view == $none} {
	    set view $v
	}
	if {$default == $v} {
	    set defExists 1
	}
    }

    if {$default != $none && $defExists > 0} {
	set view $default
    }

    if {$view != $none} {
	$m.mbar configure -background $macroSelectedColor
    }

    $m.mbar.menu add command -label "New..." \
	    -command {
	set viewname [DefView]
	if {$viewname != ""} {
	    # fix this: .map.view should be $m
	    MacroDefViews .map.view $viewname
	    set modified 1
	}
    }
    tk_menuBar $m $m.mbar
}

############################################################

proc MacroDefLinks {m default} {
    global links link modified none
    global macroSelectedColor macroUnselectedColor macroLinkColor

    catch {destroy $m.mbar}
    catch {destroy $m.label}

    set link $none
    set defExists 0

    menubutton $m.mbar -relief raised -textvariable link \
	    -menu $m.mbar.menu -width 20 -background $macroLinkColor
    CreateTextBitmap $m.label link.gif Link
    pack $m.label $m.mbar -side left -padx 2m
    menu $m.mbar.menu -tearoff 0
    foreach l [lsort [array names links]] {
	$m.mbar.menu add command -label $l \
		    -command "set link \"$l\"; \
		    # .map.link should be $m
		    .map.link.mbar configure -background $macroSelectedColor"
	if {$link == $none} {
	    set link $l
	}
	if {$default == $l} {
	    set defExists 1
	}
    }

    if {$default != $none && $defExists > 0} {
	set link $default
    }

    if {$link != $none} {
	$m.mbar configure -background $macroSelectedColor
    }

    $m.mbar.menu add command -label $none \
	    -command "set link \"$none\"; \
	    # .map.link should be $m
	    .map.link.mbar configure -background $macroLinkColor"

    $m.mbar.menu add command -label "New..." \
	    -command {
	set linkname [DefLink]
	if {$linkname != ""} {
	    # fix this: .map.link should be $m
	    MacroDefLinks .map.link $linkname
	    set modified 1
	}
    }
    tk_menuBar $m $m.mbar
}

############################################################

proc OpenDataSource {sname} {
    global sourceList derivedSourceList

    # first see if sname is a derived source
    # and if the cache disk file exists
    set err [catch {set exists $derivedSourceList($sname)}]
    if {!$err} {
	set fname [isCached $sname -1 -1]
	if {$fname == ""} {
	    dialog .noDerivedData "No Derived Data" \
		    "Derived data \"$sname\" does not exist." \
		    "" 0 Ok
	    return ""
	}
        set stype [lindex $derivedSourceList($sname) 0]
	DEVise dataSegment $sname $fname 0 0
	return [list $sname $fname $stype]
    }

    # see if data source (still) defined (may be out-of-date in
    # a session file)

    set err [catch {set exists $sourceList($sname)}]
    if {$err} {
	set but [dialog .sourceNotExists "Undefined Data Stream" \
		"Data stream \"$sname\" does not exist." \
		"" 0 OK "Select Another"]
	if {$but == 0} { return "" }
	while {1} {
	    set sname [selectStream]
	    if {$sname == ""} { return "" }
	    # must choose a single data stream
	    if {[llength $sname] > 1} {
		dialog .singleStream "Select Single Stream" \
			"You have selected more than one data stream.\
			Please select a single data stream." "" 0 Continue
		continue
	    }
	    break
	}
	set sname [lindex $sname 0]
    }

    # cache data to disk right now
    if {[isCached $sname -1 -1] == ""} {
	set but [dialog .cacheData "Caching Data" \
		"Cache \"$sname\" to disk now?" \
		"" 1 Yes No]
	if {$but == 1} {
	    dialog .notCached "Must Cache Data Stream" \
		    "Cannot visualize data without caching it to disk first." \
		    "" 0 OK
	    return ""
	}
    }

    set fname [cacheData $sname -1 -1]
    if {$fname == ""} {
	return ""
    }

    # Tell the C++ code whether this data is only a portion of a file.
    set fileSeg [lindex $sourceList($sname) 8]
    DEVise dataSegment $sname $fname [lindex $fileSeg 0] [lindex $fileSeg 1]
    set stype [lindex $sourceList($sname) 0]
    return [list $sname $fname $stype]
}

############################################################

proc CacheMultipleDataSources {snames} {
    global sourceList

    set numnotcached 0
    foreach sname $snames {
	# see if data stream is on disk already
	if {[isCached $sname -1 -1] == ""} {
	    incr numnotcached
	}
    }

    if {$numnotcached > 0} {
	set but [dialog .cacheData "Caching Data" \
		"Will need to cache $numnotcached streams to disk now." \
		"" 0 Okay Cancel]
	if {$but == 1} {
	    dialog .notCached "Cancel Visualization" \
		    "Cannot visualize data without caching it to disk first." \
		    "" 0 OK
	    return ""
	}
    }

    set sources [cacheMultipleData $snames -1 -1]
    return $sources
}

############################################################

proc OpenNewDataSource {derivedOnly} {
    # select data streams to display
    if {$derivedOnly} {
	set snames [selectDerivedStream]
    } else {
	set snames [selectStream]
    }

    if {$snames == ""} { return "" }

    # must choose a single data stream
    if {[llength $snames] > 1} {
	dialog .singleStream "Select Single Stream" \
                "You have selected more than one data stream.\
                Only the first stream will be visualized." "" 0 Continue
    }

    return [ OpenAndDefineDataSources $derivedOnly $snames ]
}

############################################################

proc OpenAndDefineDataSources {derivedOnly snames} {
    global sourceList derivedSourceList

    foreach sname $snames {
        # see if data stream already open
        if {[lsearch [TdataSet] $sname] >= 0} {
            continue
        }

        # make sure data is cached on disk
        set sourcedef [OpenDataSource $sname]
        if {$sourcedef == ""} {
            return ""
        }

        set sname [lindex $sourcedef 0]
        set param [lindex $sourcedef 1]
        set stype [lindex $sourcedef 2]
        
        if {$derivedOnly} {
            set schema [lindex $derivedSourceList($sname) 2]
            set schemafile [lindex $derivedSourceList($sname) 3]
        } else {
            set schema [lindex $sourceList($sname) 2]
            set schemafile [lindex $sourceList($sname) 3]
        }

        # load schema file if necessary - it is not sufficient to check if
        # the physical schema by the same name has been loaded because the same
        # physical schema may be shared by several logical schemas - the best
        # way of checking is to see that we have no groups defined under the 
        # logical schema name
    
        set topgrps [DEVise getTopGroups [file tail $schemafile]]
        if {[llength $topgrps] == 0} {
            if {![file readable $schemafile]} {
                dialog .schemaError "Schema File Not Found" \
                        "Cannot open schema file $schemafile" "" 0 OK
                return ""
            }
            set result [DEVise importFileType $schemafile]
            if {$result == ""} {
                return ""
            }
            if {$result != $schema} {
                puts "File $schemafile appears to contain schema $result,\
                        not $schema"
                set schema $result
            }
        }
    
        statusWindow .info "Status" \
                "Creating an index on \"$sname\".\n\n\This may take a while."
        update

        # ask DEVise to create tdata
        set result [DEVise create tdata $schema $sname $stype $param]
        catch {destroy .info}

        if {$result == ""} {
            dialog .tdataError "Data Stream Error" \
                    "Cannot open data stream $sname" "" 0 OK
            return ""
        }
    }

    return [lindex $snames 0]
}

############################################################

proc DefSource {} {
    global sourceList tdatas schemas maps sname

    if {[WindowVisible .source]} {
	return
    }

    # ask user to select a data stream
    set sname [OpenNewDataSource 0]
    if {$sname == ""} { return }

    set schema [lindex $sourceList($sname) 2]
    set schemafile [lindex $sourceList($sname) 3]
    set source [lindex $sourceList($sname) 4]

    # initialize element in schema definition array if necessary
    set err [catch {set sdef $maps($schema)}]
    if {$err > 0} {
	set maps($schema) ""
    }

    set sdef [DEVise getSchema $sname]
    lappend tdatas [list $sname $source]
    set schemas($sname) [list $schema $sdef]

    return $sname
}

############################################################

proc statusWindow {w title msg} {
    toplevel $w
    wm title $w $title
    wm geometry $w +200+200
    message $w.msg -justify center -width 8c -text $msg
    pack $w.msg -side top -padx 8m -pady 4m
    update
}

############################################################

proc DefWindow {} {
    global windows x y w h winname

    if {[WindowVisible .def]} {
	return
    }

    toplevel .def
    wm title .def "Define Window"
    wm geometry .def +100+100
    selection clear .def

    set winname "Default"
    set x "0.1"
    set y "0.3"
    set w "0.5"
    set h "0.5"

    label .def.label -text "Enter window parameters"
    frame .def.win
    frame .def.but
    pack .def.label -side top -pady 3m
    pack .def.win -side top -padx 3m -fill both -expand 1
    pack .def.but -side top -pady 3m -padx 3m -fill x -expand 1

    frame .def.win.left
    frame .def.win.right
    pack .def.win.left .def.win.right -side left -fill both \
	    -expand 1

    label .def.win.left.x -text X -width 8
    label .def.win.left.y -text Y -width 8
    label .def.win.left.w -text Width -width 8
    label .def.win.left.h -text Height -width 8
    label .def.win.left.name -text Name -width 8
    pack .def.win.left.x .def.win.left.y \
	    .def.win.left.w .def.win.left.h -side top -pady 0.7m
    pack .def.win.left.name -side top -pady 3m

    entry .def.win.right.x -relief sunken -width 15 -textvariable x
    entry .def.win.right.y -relief sunken -width 15 -textvariable y
    entry .def.win.right.w -relief sunken -width 15 -textvariable w
    entry .def.win.right.h -relief sunken -width 15 -textvariable h
    entry .def.win.right.name -relief sunken -width 15 -textvariable winname
    pack .def.win.right.x .def.win.right.y \
	    .def.win.right.w .def.win.right.h -side top
    pack .def.win.right.name -side top -pady 3m

    button .def.but.ok -text OK -width 10 \
	    -command {
	if {$winname == ""} {
	    dialog .needInfo "Missing Information" \
		    "Please enter all requested information." \
		    "" 0 {OK}
	} else {
	    set err [catch {set exists $windows($winname)}]
	    if {!$err} {
		dialog .winExists "Win Exists" \
			"Window $winname exists already." \
			"" 0 {OK}
	    } else {
		destroy .def
	    }
	}
    }
    button .def.but.cancel -text Cancel -width 10 \
	    -command {
	set winname ""
	destroy .def
    }
    pack .def.but.ok .def.but.cancel -padx 3m -side left -expand 1

    tkwait visibility .def
    grab set .def
    tkwait window .def

    if {$winname != ""} {
	# ask DEVise to create window
	set winType TileLayout
	set result [DEVise create window $winType $winname $x $y $w $h]
	if {$result == ""} {
	    dialog .windowError "Window Error" \
		    "Error creating window $winname" "" 0 OK
	    return ""
	}
	set defn [list $x $y $w $h]
	set windows($winname) $defn
    }

    return $winname
}

############################################################

proc DefMapping {tdata schema} {
    global DEViseColors DEViseShapes
    global mappings devcolors devshapes
    global mapname x y color size pattern orient shape

    if {[WindowVisible .def]} {
	return
    }

    toplevel .def
    wm title .def "Define Mapping"
    wm geometry .def +100+100
    selection clear .def

    set mapname "Default"

    label .def.label -text "Enter mapping parameters"
    frame .def.map
    frame .def.but
    pack .def.label -side top -pady 3m
    pack .def.map -side top -padx 3m -fill both -expand 1
    pack .def.but -side top -pady 3m -padx 3m -fill x -expand 1

    frame .def.map.left
    frame .def.map.right
    pack .def.map.left .def.map.right -side left -fill both \
	    -expand 1

    label .def.map.left.x -text X -width 8
    label .def.map.left.y -text Y -width 8
    label .def.map.left.color -text Color -width 12
    label .def.map.left.size -text Size -width 12
    label .def.map.left.pattern -text Pattern -width 12
    label .def.map.left.orient -text Orientation -width 12
    label .def.map.left.shape -text Shape -width 12
    label .def.map.left.name -text Name -width 12
    pack .def.map.left.x .def.map.left.y \
	    .def.map.left.color .def.map.left.orient \
	    .def.map.left.size .def.map.left.pattern \
	    .def.map.left.shape -side top -pady 0.7m
    pack .def.map.left.name -side top -pady 3m

    menubutton .def.map.right.x -relief raised \
	    -textvariable x -menu .def.map.right.x.menu -width 15
    menubutton .def.map.right.y -relief raised \
	    -textvariable y -menu .def.map.right.y.menu -width 15
    menubutton .def.map.right.color -relief raised \
	    -textvariable color -menu .def.map.right.color.menu -width 15
    menubutton .def.map.right.size -relief raised \
	    -textvariable size -menu .def.map.right.size.menu -width 15
    menubutton .def.map.right.pattern -relief raised \
	    -textvariable pattern -menu .def.map.right.pattern.menu -width 15
    menubutton .def.map.right.orient -relief raised \
	    -textvariable orient -menu .def.map.right.orient.menu -width 15
    menubutton .def.map.right.shape -relief raised \
	    -textvariable shape -menu .def.map.right.shape.menu -width 15
    entry .def.map.right.name -relief sunken -width 15 -textvariable mapname
    pack .def.map.right.x .def.map.right.y \
	    .def.map.right.color .def.map.right.orient \
	    .def.map.right.size .def.map.right.pattern \
	    .def.map.right.shape -side top
    pack .def.map.right.name -side top -pady 3m

    menu .def.map.right.x.menu -tearoff 0
    menu .def.map.right.y.menu -tearoff 0
    set x ""
    set y ""
    foreach attr $schema {
	set name [lindex $attr 0]
	set type [lindex $attr 1]
	set sorted [lindex $attr 2]
	.def.map.right.x.menu add radiobutton -label $name \
		-variable x -value $name
	.def.map.right.y.menu add radiobutton -label $name \
		-variable y -value $name
	if {$sorted > 0 && $name != "recId" && $x == ""} {
	    set x $name
	}
    }
    tk_menuBar .def.map.right .def.map.right.x
    tk_menuBar .def.map.right .def.map.right.y
    if {$x == ""} {
	set x [lindex [lindex $schema 0] 0]
    }
    set y [lindex [lindex $schema 1] 0]

    menu .def.map.right.color.menu -tearoff 0
    foreach color $DEViseColors {
	set idx [lindex $color 0]
	set name [lindex $color 1]
	set devcolors($name) $idx
	.def.map.right.color.menu add radiobutton -label $name \
		-variable color -value $name
    }
    tk_menuBar .def.map.right .def.map.right.color
    set color red

    menu .def.map.right.size.menu -tearoff 0
    .def.map.right.size.menu add radiobutton -label 1 \
	    -variable size -value 1
    tk_menuBar .def.map.right .def.map.right.size
    set size 1

    menu .def.map.right.pattern.menu -tearoff 0
    .def.map.right.pattern.menu add radiobutton -label 0 \
	    -variable pattern -value 0
    tk_menuBar .def.map.right .def.map.right.pattern
    set pattern 0

    menu .def.map.right.orient.menu -tearoff 0
    .def.map.right.orient.menu add radiobutton -label 0 \
	    -variable orient -value 0
    tk_menuBar .def.map.right .def.map.right.orient
    set orient 0

    menu .def.map.right.shape.menu -tearoff 0
    foreach shape $DEViseShapes {
	set idx [lindex $shape 0]
	set name [lindex $shape 1]
	set devshapes($name) $idx
	.def.map.right.shape.menu add radiobutton -label $name \
		-variable shape -value $name
    }
    tk_menuBar .def.map.right .def.map.right.shape
    set shape Bar

    button .def.but.ok -text OK -width 10 \
	    -command {
	if {$mapname == ""} {
	    dialog .needInfo "Missing Information" \
		    "Please enter all requested information." \
		    "" 0 {OK}
	} else {
	    set err [catch {set exists $mappings($mapname)}]
	    if {!$err} {
		dialog .mapExists "Mapping Exists" \
			"Mapping $mapname exists already." \
			"" 0 {OK}
	    } else {
		destroy .def
	    }
	}
    }
    button .def.but.cancel -text Cancel -width 10 \
	    -command {
	set mapname ""
	destroy .def
    }
    pack .def.but.ok .def.but.cancel -side left -padx 3m -expand 1

    tkwait visibility .def
    grab set .def
    tkwait window .def

    if {$mapname != ""} {
	set cidx $devcolors($color)
	set pidx 0
	set oidx 0
	set sidx $devshapes($shape)
	set defn [list $x $y $cidx $size $pidx $oidx $sidx "" ""]
	set mappings($mapname) $defn
    }

    return $mapname
}

############################################################

proc DefView {} {
    global views
    global xlo xhi ylo yhi color size pattern orient shape viewname
    global DEViseColors DEViseShapes
    global devcolors devshapes

    if {[WindowVisible .def]} {
	return
    }

    toplevel .def
    wm title .def "Define View"
    wm geometry .def +100+100
    selection clear .def

    set viewname "Default"
    set xlo "0.0"
    set xhi "100.0"
    set ylo "0.0"
    set yhi "100.0"

    set viewParams [DEVise getparam view SortedX]
    foreach param $viewParams {
	set pname [lindex $param 0]
	set value [lindex $param 1]
	if {$pname == "xlow"} {
	    set xlo $value
	}
	if {$pname == "xhigh"} {
	    set xhi $value
	}
	if {$pname == "ylow"} {
	    set ylo $value
	}
	if {$pname == "yhigh"} {
	    set yhi $value
	}
    }

    label .def.label -text "Enter view parameters"
    frame .def.view
    frame .def.but
    pack .def.label -side top -pady 3m
    pack .def.view -side top -padx 3m -fill both -expand 1
    pack .def.but -side top -pady 3m -padx 3m -fill x -expand 1

    frame .def.view.left
    frame .def.view.right
    pack .def.view.left .def.view.right -side left -fill both \
	    -expand 1

    label .def.view.left.xlo -text "X low" -width 12
    label .def.view.left.xhi -text "X high" -width 12
    label .def.view.left.ylo -text "Y low" -width 12
    label .def.view.left.yhi -text "Y high" -width 12
    label .def.view.left.color -text Color -width 12
    label .def.view.left.size -text Size -width 12
    label .def.view.left.pattern -text Pattern -width 12
    label .def.view.left.orient -text Orientation -width 12
    label .def.view.left.shape -text Shape -width 12
    label .def.view.left.name -text Name -width 12
    pack .def.view.left.xlo .def.view.left.xhi \
	    .def.view.left.ylo .def.view.left.yhi \
	    .def.view.left.color .def.view.left.orient \
	    .def.view.left.size .def.view.left.pattern \
	    .def.view.left.shape -side top -pady 0.7m
    pack .def.view.left.name -side top -pady 3m

    entry .def.view.right.xlo -relief sunken -width 20 -textvariable xlo
    entry .def.view.right.xhi -relief sunken -width 20 -textvariable xhi
    entry .def.view.right.ylo -relief sunken -width 20 -textvariable ylo
    entry .def.view.right.yhi -relief sunken -width 20 -textvariable yhi
    menubutton .def.view.right.color -relief raised \
	    -textvariable color -menu .def.view.right.color.menu -width 20
    menubutton .def.view.right.size -relief raised \
	    -textvariable size -menu .def.view.right.size.menu -width 20
    menubutton .def.view.right.pattern -relief raised \
	    -textvariable pattern -menu .def.view.right.pattern.menu -width 20
    menubutton .def.view.right.orient -relief raised \
	    -textvariable orient -menu .def.view.right.orient.menu -width 20
    menubutton .def.view.right.shape -relief raised \
	    -textvariable shape -menu .def.view.right.shape.menu -width 20
    entry .def.view.right.name -relief sunken -width 20 -textvariable viewname
    pack .def.view.right.xlo .def.view.right.xhi \
	    .def.view.right.ylo .def.view.right.yhi \
	    .def.view.right.color .def.view.right.orient \
	    .def.view.right.size .def.view.right.pattern \
	    .def.view.right.shape -side top
    pack .def.view.right.name -side top -pady 3m

    menu .def.view.right.color.menu -tearoff 0
    foreach color $DEViseColors {
	set idx [lindex $color 0]
	set name [lindex $color 1]
	set devcolors($name) $idx
	.def.view.right.color.menu add radiobutton -label $name \
		-variable color -value $name
    }
    tk_menuBar .def.view.right .def.view.right.color
    set color red

    menu .def.view.right.size.menu -tearoff 0
    .def.view.right.size.menu add radiobutton -label 1 \
	    -variable size -value 1
    tk_menuBar .def.view.right .def.view.right.size
    set size 1

    menu .def.view.right.pattern.menu -tearoff 0
    .def.view.right.pattern.menu add radiobutton -label 0 \
	    -variable pattern -value 0
    tk_menuBar .def.view.right .def.view.right.pattern
    set pattern 0

    menu .def.view.right.orient.menu -tearoff 0
    .def.view.right.orient.menu add radiobutton -label 0 \
	    -variable orient -value 0
    tk_menuBar .def.view.right .def.view.right.orient
    set orient 0

    menu .def.view.right.shape.menu -tearoff 0
    foreach shape $DEViseShapes {
	set idx [lindex $shape 0]
	set name [lindex $shape 1]
	set devshapes($name) $idx
	.def.view.right.shape.menu add radiobutton -label $name \
		-variable shape -value $name
    }
    tk_menuBar .def.view.right .def.view.right.shape
    set shape Bar

    button .def.but.ok -text OK -width 10 \
	    -command {
	if {$viewname == ""} {
	    dialog .needInfo "Missing Information" \
		    "Please enter all requested information." \
		    "" 0 {OK}
	} else {
	    set err [catch {set exists $views($viewname)}]
	    if {!$err} {
		dialog .viewExists "View Exists" \
			"View $viewname exists already." \
			"" 0 {OK}
	    } else {
		destroy .def
	    }
	}
    }
    button .def.but.cancel -text Cancel -width 10 \
	    -command {
	set viewname ""
	destroy .def
    }
    pack .def.but.ok .def.but.cancel -padx 3m -side left -expand 1

    tkwait visibility .def
    grab set .def
    tkwait window .def

    if {$viewname != ""} {
	set defn [list $xlo $xhi $ylo $yhi white]
	set views($viewname) $defn
    }

    return $viewname
}

############################################################

proc DefLink {} {
    global links
    global x y color size pattern orient shape linkname
    global macroSelectColor

    if {[WindowVisible .def]} {
	return
    }

    toplevel .def
    wm title .def "Define Link"
    wm geometry .def +100+100
    selection clear .def

    set linkname "Default"
    set x 1
    set y 0
    set color 0
    set size 0
    set pattern 0
    set orient 0
    set shape 0

    label .def.label -text "Enter link parameters"
    frame .def.link
    frame .def.name
    frame .def.but
    pack .def.label -side top -pady 3m
    pack .def.link -side top -padx 3m -fill both -expand 1
    pack .def.name -side top -padx 3m -fill x -expand 1
    pack .def.but -side top -pady 3m -padx 3m -fill x -expand 1

    checkbutton .def.link.x -text X -variable x -anchor w \
	    -indicatoron 0 -selectcolor $macroSelectColor
    checkbutton .def.link.y -text Y -variable y -anchor w \
	    -indicatoron 0 -selectcolor $macroSelectColor
    checkbutton .def.link.color -text Color -variable color -anchor w \
	    -indicatoron 0 -selectcolor $macroSelectColor
    checkbutton .def.link.size -text Size -variable size -anchor w \
	    -indicatoron 0 -selectcolor $macroSelectColor
    checkbutton .def.link.pattern -text Pattern -variable pattern -anchor w \
	    -indicatoron 0 -selectcolor $macroSelectColor
    checkbutton .def.link.orient -text Orientation \
	    -variable orient -anchor w \
	    -indicatoron 0 -selectcolor $macroSelectColor
    checkbutton .def.link.shape -text Shape -variable shape -anchor w \
	    -indicatoron 0 -selectcolor $macroSelectColor
    pack .def.link.x .def.link.y .def.link.color .def.link.orient \
	    .def.link.size .def.link.pattern .def.link.shape \
	    -side top -fill x -expand 1

    label .def.name.label -text "Name"
    entry .def.name.name -relief sunken -textvariable linkname
    pack .def.name.label -side left -pady 3m -padx 3m
    pack .def.name.name -side right -pady 3m -fill x -expand 1

    button .def.but.ok -text OK -width 10 \
	    -command {
	if {$linkname == ""} {
	    dialog .needInfo "Missing Information" \
		    "Please enter all requested information." \
		    "" 0 {OK}
	} else {
	    set err [catch {set exists $links($linkname)}]
	    if {!$err} {
		dialog .linkExists "Link Exists" \
			"Link $linkname exists already." \
			"" 0 {OK}
	    } else {
		destroy .def
	    }
	}
    }
    button .def.but.cancel -text Cancel -width 10 \
	    -command {
	set linkname ""
	destroy .def
    }
    pack .def.but.ok .def.but.cancel -side left -padx 3m -expand 1

    tkwait visibility .def
    grab set .def
    tkwait window .def

    if {$linkname != ""} {
	# ask DEVise to create link
	set flag [expr $x | ($y << 1) | ($color << 2) | ($size << 3) | \
		       ($pattern << 4) | ($orient << 5) | ($shape << 6)]
	set result [DEVise create link Visual_Link $linkname $flag]
	if {$result == ""} {
	    dialog .linkError "Link Error" \
		    "Error creating link $linkname" "" 0 OK
	    return ""
	}
	set links($linkname) $flag
    }

    return $linkname
}

############################################################

proc CreateBitmapButton2 {w file title command} {
    global libdir

    button $w -command $command

    frame $w.stack -relief raised -bd 2

    pack $w.stack

    # create a button for the image
    label $w.stack.img -image [image create photo -file $libdir/$file] \
	    -bd 0 -relief flat -padx 1 -pady 1

    pack $w.stack.img

    # create a button for the title
    label $w.stack.title -text $title \
	-bd 0 -relief flat -font 6x10 \
	-padx 1 -pady 1
    
    pack $w.stack.title

    return $w
}

############################################################

proc CreateBitmapButton {w file title command {width 20m} {height 21m}} {
    global libdir

    frame $w -relief raised -bd 2 -width $width -height $height
    bind $w <Button-1> $command

    # create a button for the image
    button $w.img -image [image create photo -file $libdir/$file] \
	-bd 0 -relief flat -command $command

    # create a button for the title
    button $w.title -text $title -bd 0 -relief flat -command $command
    
    pack propagate $w 0
    pack $w.img $w.title -side top -padx 1 -pady 1

    return $w
}

############################################################

proc CreateTextBitmap {w file title {width 20m} {height 17m}} {
    global libdir

    frame $w -width $width -height $height

    # create a button for the image
    label $w.img -image [image create photo -file $libdir/$file] \
	-bd 0 -relief flat

    # create a button for the title
    label $w.title -text $title -bd 0 -relief flat
    
    pack propagate $w 0
    pack $w.img $w.title -side top -padx 1 -pady 1

    return $w
}

############################################################

proc CreateTitleBitmap {w file title {height 16m}} {
    global libdir

    frame $w -height $height
    frame $w.top
    pack $w.top -side top

    # create a button for the image
    label $w.img -image [image create photo -file $libdir/$file] \
	-bd 0 -relief flat -padx 1 -pady 1

    # create a button for the title
    label $w.title -text $title -bd 0 -relief flat -padx 1 -pady 1
    
    pack $w.img $w.title -in $w.top -side left -padx 8

    return $w
}

############################################################

proc CreateBitmapMenuButton { w file varname } {
    upvar varname var
    global libdir

    frame $w -relief raised -bd 2

    # create a button for the image
    button $w.img -image [image create photo -file $libdir/$file] \
	-bd 0 -relief flat -command $command

    pack $w.img

    # create a button for the title
    button $w.title -text $title \
	-bd 0 -relief flat -font 6x10 \
	-padx 1 -pady 1 \
	-command $command
    
    pack $w.title

    return $w
}

############################################################

proc setupAttrCheckButtons {win var schemaname grpname topgrp} {
    global $var macroSelectColor

    set row -1
    set col -1
    set maxcol 1
    set varcnt 0

    # We will do some preprocessing to figure out how to display the
    # the attributes - i.e. how many columns per row, size of menu
    # buttons and the size of the window itself.
    
    set grplist [DEVise getItems $schemaname $topgrp $grpname]

    # Find the max width of the attrs and the number of attrs
    set numattrs 0
    set maxwidth 0
    foreach itm $grplist {
	set subname [lindex $itm 0]
	set width [llength [split $subname {}]]
	if {$width > $maxwidth} {
	    set maxwidth $width
	}
	incr numattrs
    }

    if {$maxwidth < 13} {
	set maxwidth 13
    }
    incr maxwidth 2
    set maxcol [expr 75 / $maxwidth]
    if {$maxcol < 1} {
	set maxcol 1
    }
    set colwidth $maxwidth
    
    foreach itm $grplist {
	set subname [lindex $itm 0]
	set type [lindex $itm 1]
	set checkvar [format "%s(%s)" $var $subname]

	if {$col < 0} {
	    incr row
	    set col 0
	    frame $win.row$row
	    pack $win.row$row -side top -fill x \
		    -expand 1
	}

	# If regular attribute, add a check button; otherwise,
	# add a button which launches a submenu window

	if {$type != "intr"} {
	    checkbutton $win.row$row.col$col \
		    -text $subname -variable $checkvar \
		    -width $colwidth -indicatoron 0 \
		    -selectcolor $macroSelectColor
	    set $checkvar 0
	} else {
	    menubutton $win.row$row.col$col \
		    -relief raised \
		    -text $subname -width $colwidth \
		    -bg darkslategray4 -fg wheat \
		    -menu "$win.row$row.col$col.menu"
	    setupAttrCheckMenu $win.row$row.col$col.menu $var $schemaname \
		    $subname $topgrp
	}
	pack $win.row$row.col$col -side left \
		-fill x -expand 1
	incr col
	if {$col >= $maxcol} {
	    set col -1
	}
    }

    # Add empty frames at end of last row
    for {} {$row >= 0 && $col >= 0 && $col < $maxcol} {incr col} {
	label $win.row$row.col$col -text "" \
		-width $colwidth -relief flat -borderwidth 4
	pack $win.row$row.col$col -side left -fill x \
		-expand 1
    }
}

############################################################

proc setupAttrCheckMenu {menu var schemaname grpname topgrp} {
    global $var

    menu $menu -tearoff 0

    set grplist [DEVise getItems $schemaname $topgrp $grpname]

    foreach itm $grplist {
	set subname [lindex $itm 0]
	set type [lindex $itm 1]
	set checkvar [format "%s(%s)" $var $subname]

	# If regular attribute, add a check button; otherwise,
	# add a cascaded menu for group

	if {$type != "intr"} {
	    $menu add checkbutton -label $subname -variable $checkvar
	    set $checkvar 0
	} else {
	    $menu add cascade -label $subname -menu $menu.g$subname
	    setupAttrCheckMenu $menu.g$subname $var $schemaname \
		    $subname $topgrp
	}
    }
}

############################################################

proc setupAttrRadioMenu {menu var prefix schemaname grpname topgrp} {
    global $var

    menu $menu -tearoff 0

    set grplist [DEVise getItems $schemaname $topgrp $grpname]

    foreach itm $grplist {
	set subname [lindex $itm 0]
	set type [lindex $itm 1]

	# If regular attribute, add a check button; otherwise,
	# add a cascaded menu for group

	if {$type != "intr"} {
	    $menu add radiobutton -label $subname -variable $var \
		    -value $prefix$subname
	} else {
	    $menu add cascade -label $subname -menu $menu.g$subname
	    setupAttrRadioMenu $menu.g$subname $var $prefix $schemaname \
		    $subname $topgrp
	}
    }
}

############################################################

proc MacroImport {mode derivedOnly} {
    global dialogListVar sourceList derivedSourceList

    set tdata ""

    if {!$derivedOnly && $mode > 0} {
	set tdataSet [TdataSet]
	if {[llength $tdataSet] > 0} {
	    set answer [ dialogList .selectTData "Visualize Data Stream"  \
		    "Select a data stream" \
		    "" 2 { New Cancel Ok } $tdataSet ]
	    if {$answer == 1 || $dialogListVar(selected) == ""} {
		return
	    }
	    if {$answer == 2} { 
		set tdata $dialogListVar(selected)
	    } else {
		set tdata ""
	    }
	}
    }

    if {$tdata == ""} {
	set tdata [OpenNewDataSource $derivedOnly]
    }

    if {$tdata == ""} { return }

    if {$derivedOnly} {
	set schemafile [lindex $derivedSourceList($tdata) 3]
    } else {
	set schemafile [lindex $sourceList($tdata) 3]
    }

    MacroDefAutoNew $tdata $schemafile
}

############################################################

proc MacroDefAutoNew {tdata schemafile} {
    global x yvar viewselname bgcolor linksel windowsel titlesel
    global xaxissel yaxissel cancel newgdata viewsel
    global sourceList macroSelectColor macroMenuSelectColor
    global curView

    if {[WindowVisible .auto]} {

	return
    }
	
    set schema [ElimStringAttr [DEVise getSchema $tdata]]
    set schemaname [file tail $schemafile]
    set topgrp [SelectTopGroup $schemaname]

    toplevel .auto
    wm title .auto "Define Visualization"
    wm geometry .auto +50+50
    selection clear .auto
	
    label .auto.label -text "Define Visualization Parameters"

    frame .auto.top
    frame .auto.mid
    frame .auto.bot
    frame .auto.ysel -relief groove -borderwidth 2
    frame .auto.but

    pack .auto.label -side top -pady 3m -fill x -expand 1
    pack .auto.top -side top -pady 3m -fill x -expand 1
    pack .auto.mid -side top -pady 3m -fill x -expand 1
    pack .auto.bot -side top -pady 3m -fill x -expand 1
    pack .auto.ysel -side top -pady 3m -fill x -expand 1
    pack .auto.but -side top -pady 3m -fill x -expand 1

    frame .auto.windowsel -relief groove -borderwidth 2
    frame .auto.xsel -relief groove -borderwidth 2
    pack .auto.windowsel .auto.xsel -in .auto.top -side left \
	    -ipady 3m -padx 1m -fill x -expand 1

    frame .auto.viewsel -relief groove -borderwidth 2
    frame .auto.colorsel -relief groove -borderwidth 2
    frame .auto.gdatasel -relief groove -borderwidth 2
    pack .auto.viewsel .auto.colorsel .auto.gdatasel \
	    -in .auto.mid -side left -ipady 3m -padx 1m -fill x -expand 1

    frame .auto.titlesel -relief groove -borderwidth 2
    frame .auto.linksel -relief groove -borderwidth 2
    frame .auto.xaxissel -relief groove -borderwidth 2
    frame .auto.yaxissel -relief groove -borderwidth 2
    pack  .auto.titlesel .auto.linksel .auto.xaxissel .auto.yaxissel \
	    -in .auto.bot -side left -ipady 3m -padx 1m -fill x -expand 1
	

    label .auto.windowsel.label -text "Window:"
    menubutton .auto.windowsel.window -relief raised \
	    -textvariable windowsel -menu .auto.windowsel.window.menu \
	    -width 30
    pack .auto.windowsel.label .auto.windowsel.window -side left -padx 1m
    set windowsel ""
    if {$curView != ""} {
	set windowsel [DEVise getViewWin $curView]
    }
    if {$windowsel == ""} {
	set windowsel "None selected yet"
    }
   

    menu .auto.windowsel.window.menu -tearoff 0
    foreach w [WinSet] {

	.auto.windowsel.window.menu add command -label $w \
		-command "set windowsel {$w}"
    }

    .auto.windowsel.window.menu add separator
    .auto.windowsel.window.menu add command -label "New..." -command {
	set newwin [DoCreateWindow "Select window type"]
	

	if {$newwin != ""} {
	    set windowsel $newwin
	    .auto.windowsel.window.menu add command -label $windowsel \
		    -command "set windowsel {$windowsel}"
	}
    }

    label .auto.xsel.label -text "Select X:"
    menubutton .auto.xsel.attr -relief raised \
	    -textvariable x -menu .auto.xsel.attr.g$topgrp -width 20
    pack .auto.xsel.label .auto.xsel.attr -side left -padx 1m
    setupAttrRadioMenu .auto.xsel.attr.g$topgrp x "" $schemaname \
	    $topgrp $topgrp

    label .auto.viewsel.label -text "View Type:"
    menubutton .auto.viewsel.view -relief raised \
	    -textvariable viewselname -menu .auto.viewsel.view.menu -width 15
    pack .auto.viewsel.label .auto.viewsel.view -side left -padx 1m

    menu .auto.viewsel.view.menu -tearoff 0
    .auto.viewsel.view.menu add radiobutton -label "Scatter Plot" \
	    -variable viewselname -value "Scatter Plot" -command {
	set viewsel 0
    }
    .auto.viewsel.view.menu add radiobutton -label Image \
	    -variable viewselname -value Image -command {
	set viewsel 1
    }
    .auto.viewsel.view.menu add radiobutton -label "Bar Chart" \
	    -variable viewselname -value "Bar Chart" -command {
	set viewsel 2
    }
    set viewselname "Bar Chart"
    set viewsel 2

    checkbutton .auto.gdatasel.link -text "New Mappings" -variable newgdata
    pack .auto.gdatasel.link -side left -padx 3m
    set newgdata 1

    label .auto.colorsel.label -text "Background:"
    button .auto.colorsel.color -width 15 -textvariable bgcolor \
	-command "getColor bgcolor" -highlightthickness 0
    pack .auto.colorsel.label .auto.colorsel.color -side left -padx 1m
    set bgcolor "AntiqueWhite"

    checkbutton .auto.titlesel.title -text Title -variable titlesel
    pack .auto.titlesel.title -side left -padx 3m
    set titlesel 0

    checkbutton .auto.linksel.link -text "Link X" -variable linksel
    pack .auto.linksel.link -side left -padx 3m
    set linksel 1

    checkbutton .auto.xaxissel.xaxis -text "X Axis" -variable xaxissel
    pack .auto.xaxissel.xaxis -side left -padx 3m
    set xaxissel 0

    checkbutton .auto.yaxissel.yaxis -text "Y Axis" -variable yaxissel
    pack .auto.yaxissel.yaxis -side left -padx 3m
    set yaxissel 1
	
    if {$topgrp == "__default"} {

	set slabel "Select Y"
	set swidth 15
    } else {
	set slabel "Select Y from $topgrp"
	set swidth [expr [llength [split $topgrp {}]] + 15]
    }
    label .auto.ysel.label -text $slabel -width $swidth
    pack .auto.ysel.label -side top -fill x -expand 1 -pady 2m

    frame .auto.ysel.sel
    pack .auto.ysel.sel -side top -padx 3m -pady 1m -expand 1
    setupAttrCheckButtons .auto.ysel.sel yvar $schemaname $topgrp $topgrp

    # Try to select default X to be a sorted attribute
    set x [lindex [lindex $schema 0] 0]
    foreach attr $schema {
	set name [lindex $attr 0]
	set type [lindex $attr 1]
	set sorted [lindex $attr 2]
	if {$sorted > 0 && $name != "recId"} {
	    set x $name
	    break
	}
    }

    tk_menuBar .auto.xsel .auto.xsel.attr
    set cancel 0
	
    button .auto.but.ok -text OK -width 15 -command {
	if {![DEVise exists $windowsel]} {
	    dialog .winError "No Window Specified" \
		    "Please select a window for visualization." \
	    "" 0 OK
	   return
	}
	foreach yname [array names yvar] {
	    if {$yvar($yname) > 0} {
		set cancel 0
		return
	    }
	}
	dialog .autoError "Note" \
		"Please select one or more\n\
		Y attributes for automatic\n\
		mapping." "" 0 OK
	return
    }
    button .auto.but.cancel -text Cancel -width 15 -command {
	set cancel 1
    }
    pack .auto.but.ok .auto.but.cancel -side left -expand 1 -padx 3m
	

    tkwait variable cancel
    destroy .auto

    if {$cancel} {
	return
    }

    set ylist ""
    foreach yname [array names yvar] {
	if {$yvar($yname) > 0} {
	    lappend ylist $yname
	}
    }
    
    # puts "The value of x is $x"
    # puts "The ylist is $ylist"
    
    MacroDefAutoActualNew $tdata $viewsel $linksel $windowsel $bgcolor \
	    $titlesel $xaxissel $yaxissel $x $ylist $newgdata
}

############################################################

proc MacroDefAutoActualNew {tdata viewsel linksel window bgcolor
                            titlesel xaxissel yaxissel x ylist
                            newgdata} {
    global viewDefault

    set schema [ElimStringAttr [DEVise getSchema $tdata]]

    set sortedx 0
    set xlo ""
    set xhi ""

    # Find out type of X and whether it is sorted or not
    foreach attr $schema {
	set name [lindex $attr 0]
	if {$name != $x} {continue}
	set xtype [lindex $attr 1]
	set sortedx [lindex $attr 2]
	set hasxhi [lindex $attr 3]
	if {$hasxhi} {
	    set xhi [lindex $attr 4]
	}
	set hasxlo [lindex $attr 5]
	if {$hasxlo} {
	    set xlo [lindex $attr 6]
	}
	break
    }

    # also consult lo/hi values defined in .rc file
    set viewParams ""
    catch { set viewParams $viewDefault($xtype) }
    foreach param $viewParams {
	set pname [lindex $param 0]
	set value [lindex $param 1]
	if {$xlo == "" && $pname == "xlow"} {
	    set xlo $value
	}
	if {$xhi == "" && $pname == "xhigh"} {
	    set xhi $value
	}
    }

    # if no defaults specified anywhere, resort to these defaults
    if {$xhi == ""} {
	set xhi 0
    }
    if {$xlo == ""} {
	set xlo 100
    }

    if {$xlo == $xhi} {
	incr xlo -1
	incr xhi +1
    }

    # puts "Mapping will have xlo $xlo and xhi $xhi"

    if {$sortedx > 0} {
	set sortedx SortedX
    } else {
	set sortedx Scatter
    }

    if {$linksel} {
	set linkname [format "%s Link" $x]
	if {![DEVise exists $linkname]} {
	    # ask DEVise to create link
	    set result [DEVise create link Visual_Link $linkname 1]
	    if {$result == ""} {
		dialog .linkError "Link Error" \
			"Error creating link $linkname" "" 0 OK
		return
	    }
	}
    }

    set color 2
    set shape $viewsel
    set size 1
    set pattern 0
    set orient 0
    set shapeAttr0 ""
    set shapeAttr1 ""

    if {$shape == 1} {
	# set pixel width and height to one for image displays
	set shape 0
	set shapeAttr0 1
	set shapeAttr1 1
    }

    foreach attr $schema {
	set name [lindex $attr 0]
	if {[lsearch $ylist $name] < 0} { continue }

	set type [lindex $attr 1]
	set sorted [lindex $attr 2]
	set yhi ""
	set hasyhi [lindex $attr 3]
	if {$hasyhi} {
	    set yhi [lindex $attr 4]
	    if {$viewsel == 2} {
		set yhi [ScaleUpper $yhi]
	    }
	}
	set ylo ""
	set hasylo [lindex $attr 5]
	if {$hasylo} {
	    set ylo [lindex $attr 6]
	    if {$viewsel == 2} {
		set ylo [ScaleLower $ylo]
	    }
	}

	# also consult lo/hi values defined in .rc file
	set viewParams ""
	catch { set viewParams $viewDefault($type) }
	foreach param $viewParams {
	    set pname [lindex $param 0]
	    set value [lindex $param 1]
	    if {$ylo == "" && $pname == "ylow"} {
		set ylo $value
	    }
	    if {$yhi == "" && $pname == "yhigh"} {
		set yhi $value
	    }
	}

	# if no defaults specified anywhere, resort to these defaults
	if {$yhi == ""} {
	    set yhi 0
	}
	if {$ylo == ""} {
	    set ylo 100
	}

	# for bar shape, make ylo zero
	if {$shape == 2} {
	    set ylo 0
	}

	if {$ylo == $yhi} {
	    incr ylo -1
	    incr yhi +1
	}

	# puts "Mapping will have ylo $ylo and yhi $yhi"

	# ask DEVise to create view instance
	set sorted $sortedx
	set viewbasename "Data View"
	set viewinstance [UniqueName $viewbasename]
	if {[lsearch [ViewSet] $viewinstance] >= 0} {
	    dialog .viewError "View Error" \
		    "View $viewinstance exists already." "" 0 OK
	    return
	}
	set result [DEVise create view $sorted $viewinstance \
		$xlo $xhi $ylo $yhi $bgcolor]
	if {$result == ""} {
	    dialog .viewError "View Error" \
		    "Error creating view $viewinstance" "" 0 OK
	    return
	}
	
	# ask DEVise to turn on/off label
	set titletext "$name vs. $x"
	if {[llength $ylist] == 1} {
	    set titletext $tdata
	}
	if {$titlesel} {
	    DEVise setLabel $viewinstance 1 16 $titletext
	} else {
	    DEVise setLabel $viewinstance 0 12 $titletext
	}

	# ask DEVise to turn on/off X axis
	DEVise setAxisDisplay $viewinstance X $xaxissel

	# ask DEVise to turn on/off Y axis
	DEVise setAxisDisplay $viewinstance Y $yaxissel

	# if new mappings are requested, associate color with mapping,
	# otherwise associate color with view
	if {!$newgdata} {
	    DEVise setViewOverrideColor $viewinstance $color 1
	}

	set mapname [format "%s_vs_%s" $name $x]

	if {[lsearch [DEVise get mapping] $mapname] < 0} {
	    # ask DEVise to create interpreted mapping class
	    set result [DEVise createMappingClass $mapname]
	}

	set mapinstance "$tdata#$mapname"
	if {$newgdata} {
	    # new mappings are requested
	    set mapinstance [UniqueName $mapinstance]
	}
	if {[lsearch [GdataSet] $mapinstance] < 0} {
	    # ask DEVise to create an instance of mapping
	    set result [DEVise create mapping $mapname $tdata $mapinstance \
		    "" \$$x \$$name $color $size $pattern $orient $shape \
		    $shapeAttr0 $shapeAttr1]
	    DEVise setPixelWidth $mapinstance 1
	}

	# ask DEVise to insert $mapinstance into $viewinstance
	set result [DEVise insertMapping $viewinstance $mapinstance]
	# seems that there's no error code returned

	# ask DEVise to insert $viewinstance into $window
	set result [DEVise insertWindow $viewinstance $window]
	# seems that there's no error code returned

	if {$linksel} {
	    # ask DEVise to link $viewinstance to $linkname
	    set result [DEVise insertLink $linkname $viewinstance]
	    # seems that there's no error code returned
	}

	DEVise clearViewHistory $viewinstance
	DEVise insertViewHistory $viewinstance $xlo $ylo $xhi $yhi 0

	ProcessViewSelected $viewinstance

	incr color
    }
}

############################################################

# Initialize the macro definition utility

MacroDefInit
