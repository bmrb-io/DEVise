#  ========================================================================
#  DEVise Data Visualization Software
#  (c) Copyright 1992-1996
#  By the DEVise Development Group
#  Madison, Wisconsin
#  All Rights Reserved.
#  ========================================================================
#
#  Under no circumstances is this software to be copied, distributed,
#  or altered in any way without prior permission from the DEVise
#  Development Group.

############################################################

#	$Id$

#	$Log$
#	Revision 1.94  1997/09/14 23:18:49  donjerko
#	Tables are not open if they already exist. (topGroup thing)
#
#	Revision 1.93  1997/08/21 21:06:38  donjerko
#	Added Materialize button, added isDTEType to some code in views.tcl
#
#	Revision 1.92  1997/08/06 19:23:49  wenger
#	Changed 'Image' to 'Pixels' in 'Define Visualization' dialog.
#
#	Revision 1.91  1997/06/10 19:22:17  wenger
#	Removed (some) debug output.
#
#	Revision 1.90  1997/05/28 15:39:53  wenger
#	Merged Shilpa's layout manager code through the layout_mgr_branch_2 tag.
#
#	Revision 1.89.2.1  1997/05/20 16:11:29  ssl
#	Added layout manager to DEVise
#
#	Revision 1.88  1997/05/01 01:20:19  guangshu
#	Removed some comment lines and some minor cleaning up.
#
#	Revision 1.87  1997/04/25 16:54:17  wenger
#	Text labels are now sized in the same way as Rects; fixed font bug in
#	middle button query popup; removed the dialog that warns you about your
#	table name getting changed when you open an old data source.
#
#	Revision 1.86  1997/04/22 15:25:52  wenger
#	Conditionaled out lots of debug code; fixed data source visualization
#	window so the window for the data again defaults to 'New' if there are
#	no windows.
#
#	Revision 1.85  1997/04/21 23:06:28  guangshu
#	1. Make statistics deal with different DATE types.
#	2. Make Aggregates on TData and GData.
#	3. Change Max Avg Min to be HighLow shape
#	4. Improved title.
#	5. etc.
#
#	Revision 1.84  1997/04/18 21:35:20  donjerko
#	Made check to see if DTE table is already open.
#
#	Revision 1.83  1997/04/03 16:37:07  wenger
#	Reduced memory and CPU usage in statistics; fixed a memory leak in the
#	statistics code; switched devised back to listening on port 6100
#	(changed accidentally?); turned off a bunch of debug output.
#
#	Revision 1.82  1997/03/25 17:59:41  wenger
#	Merged rel_1_3_3c through rel_1_3_4b changes into the main trunk.
#
#	Revision 1.81  1997/03/23 23:46:27  donjerko
#	*** empty log message ***
#
#	Revision 1.80  1997/03/21 23:59:22  guangshu
#	Elliminate some comment lines.
#
#	Revision 1.79  1997/03/21 16:18:36  guangshu
#	Minor change to color of stats.
#
#	Revision 1.78  1997/03/20 22:32:55  guangshu
#	Changed statistics layout.
#
#	Revision 1.77  1997/03/20 20:46:06  donjerko
#	DTE Tdata generates unique names by appending sequential numbers to the
#	end of the table name. This way, same table can be opened multiple times.
#
#	Revision 1.76  1997/03/06 02:37:43  donjerko
#	Added window to create StandardTable
#
#	Revision 1.75  1997/03/02 00:47:27  donjerko
#	Tdata used to be created before "Define Visualisation" window.
#	For DTE types, it is now being created after this window because the
#	user options can make query more restrictive and therefore cheaper to execute.
#	This screws up the Mapping dialog because only the restricted set of
#	attributes is passed as tdata.
#	This needs to be fixed once we aggree how to go about it.
#
#	Revision 1.74  1997/02/18 18:07:50  donjerko
#	Added index deletions.
#
#	Revision 1.73  1997/02/14 16:48:05  wenger
#	Merged 1.3 branch thru rel_1_3_1 tag back into the main CVS trunk.
#
#	Revision 1.72  1997/02/03 04:12:38  donjerko
#	Catalog management moved to DTE
#
#	Revision 1.71.4.1  1997/02/09 16:14:45  wenger
#	Cleaned up the data source GUI a little more (as per suggestions from
#	Miron).
#
#	Revision 1.71  1997/01/06 19:12:04  wenger
#	Fixed the relative positions of 'OK' and 'Cancel' buttons on a number of
#	windows; view names now start with 'View 1' instead of 'View'; removed
#	some diagnostic output; added code to test the UniqueName procedure.
#
#	Revision 1.70  1996/12/27 14:59:49  donjerko
#	Import button is used only for importing new streams.
#	Added a button "Display" in the import window that immediately goes to
#	visualization.
#
#	Revision 1.69  1996/12/23 22:20:40  donjerko
#	  Commented out a bunch of non-working Tk/Tcl code.  Changed OK/Cancel
#	  pairs to have OK always on the left, Cancel on the right.  Renamed
#	  and moved around various menu items; to avoid confusion.
#
#	  More changes will follow later, after you're had time to adjust.
#
#	  Shaun/Donko
#
#	Revision 1.68  1996/12/16 11:14:38  kmurli
#	No change
#
#	Revision 1.67  1996/11/25 22:31:34  beyer
#	1. extended .devise.rc search
#	2. added DestroyView command
#	3. query window updated properly, history window update changed
#	4. filter properly set to (0,100) instead of (100,0) when high,low values
#	   are not known.
#
#	Revision 1.66  1996/11/15 10:06:25  kmurli
#	Changed importFile parameters and ParseCat parameters to take in the file type
#	and data file name so that a whole query can be formed if necessary for calling
#	DQL type. (In case of a query schema)
#
#	Revision 1.65  1996/11/03 18:20:55  kmurli
#	Changes for incorporating DQL type..
#
#	Revision 1.64  1996/11/01 19:29:01  kmurli
#	Changed to include the DQL type. Also calls importFileDQL command in
#	ParseAPI.c to facilitate the creation of the DQL classes.
#
#	Revision 1.63  1996/10/22 18:25:07  jussi
#	Replaced incr statements with conventional expressions because
#	incr doesn't work on floating point numbers.
#
#	Revision 1.62  1996/10/15 22:01:14  guangshu
#	Fixed Bug #051 when open text stat for views which have . in the names.
#
#	Revision 1.61  1996/10/15 17:49:16  wenger
#	Fixed bug 050 (problem with record IDs in mappings).
#
#	Revision 1.60  1996/08/29 22:28:38  guangshu
#	Get rid of several puts.
#
#	Revision 1.59  1996/08/07 15:35:52  guangshu
#	Added support to view statistics in text form.
#
#	Revision 1.58  1996/07/22 23:50:45  guangshu
#	Added statistics for gdata. The statistics includes count, ysum, max, mean, min.
#
#	Revision 1.57  1996/07/20 17:11:57  guangshu
#	Added support for Histogram and put Max Mean Min stats in the same view
#
#	Revision 1.56  1996/07/15 17:20:32  jussi
#	Fixed minor bug when opening a new non-UNIXFILE, non-WWW
#	data source.
#
#	Revision 1.55  1996/07/15 17:00:26  jussi
#	String attributes can now be "visualized" i.e. used as labels.
#
#	Revision 1.54  1996/07/13 17:30:45  jussi
#	Removed obsolete code (a lot was carried along for potential
#	future usage not none of the code was actually used). If a
#	schema has an attribute named Color, then the color field
#	in the mapping will use that attribute.
#
#	Revision 1.53  1996/07/13 00:36:40  jussi
#	Added nicer error messages for missing schema files.
#
#	Revision 1.52  1996/07/13 00:21:13  jussi
#	Broke OpenNewDataSource into two parts so the DoColorStat can
#	reuse the latter part of it.
#
#	Revision 1.51  1996/07/12 21:54:44  jussi
#	Fixed minor typo.
#
#	Revision 1.50  1996/07/08 17:08:02  jussi
#	Small fix in OpenDataSource.
#
#	Revision 1.49  1996/07/01 19:37:33  jussi
#	Made changes to reflect new TData constructor interface. Web
#	data caching is now handled in the server, not in the client.
#
#	Revision 1.48  1996/06/20 17:14:09  guangshu
#	Added support for derived TData sets (statistics for now).
#
#	Revision 1.47  1996/06/16 01:32:53  jussi
#	Added handling of case where xlo == xhi or ylo == yhi.
#
#	Revision 1.46  1996/06/13 23:00:22  jussi
#	Fixed minor bug with New Mapping check button.
#
#	Revision 1.45  1996/06/04 14:22:06  wenger
#	Ascii data can now be read from session files (or other files
#	where the data is only part of the file); added some assertions
#	to check for pointer alignment in functions that rely on this;
#	Makefile changes to make compiling with debugging easier.
#
#	Revision 1.44  1996/05/11 03:00:01  jussi
#	Minor improvements. Changes made towards caching multiple
#	data sources in one step.
#
#	Revision 1.43  1996/05/09 18:15:16  kmurli
#	No changes, just inserted some debugging print statements and
#	removed them
#
#	Revision 1.42  1996/05/05 03:05:11  jussi
#	Automatic adjustment of Y axis scale is done for bar charts only.
#
#	Revision 1.41  1996/04/23 20:39:10  jussi
#	Corrected default value of view label.
#
#	Revision 1.40  1996/04/23 14:40:25  jussi
#	Added mising variable name to global name list, fixed color
#	assignment with new mappings.
#
#	Revision 1.39  1996/04/11 18:23:02  jussi
#	Major changes in the organization of the user interface.
#
#	Revision 1.38  1996/03/26 21:16:13  jussi
#	Added scaling of axis values to nearest "reasonable" value.
#
#	Revision 1.37  1996/02/05 19:55:12  jussi
#	Background color is chosen from a palette of colors instead of
#	a list of color names.
#
#	Revision 1.36  1996/02/01 18:31:13  jussi
#	Improved handling of errors in extracting from data from
#	external source.
#
#	Revision 1.35  1996/01/30 00:06:13  jussi
#	Minor improvements in visual appearance.
#
#	Revision 1.34  1996/01/27 00:45:10  jussi
#	User can now select background color of a new window.
#
#	Revision 1.33  1996/01/23 20:48:48  jussi
#	Added MacroImport which, temporarily, uses almost identical
#	duplicates of MacroDefAuto and MacroDefAutoActual. When the
#	old interface is obsoleted, the older versions of these two
#	procedures will be removed.
#
#	Revision 1.32  1996/01/17 19:27:34  jussi
#	Minor fix.
#
#	Revision 1.31  1996/01/16 01:30:16  jussi
#	Some reorganization of code. Removed duplicate code etc.
#
#	Revision 1.30  1996/01/13 23:09:49  jussi
#	Added support for Z attribute and shape attribute 2.
#
#	Revision 1.29  1996/01/13 20:56:26  jussi
#	Reorganized code that opens a data source. The same routine
#	(OpenDataSource) is now used in the session file.
#
#	Revision 1.28  1996/01/11 21:01:44  jussi
#	Data stream is cached before schema is read; this is because
#	for SEQ the schema is produced as part of the caching step.
#
#	Revision 1.27  1996/01/10 18:48:46  jussi
#	Attribute hi/lo values now take their values from either the
#	schema or the .rc file (schema has precedence). For bar charts,
#	ylo is 0 by default.
#
#	Revision 1.26  1996/01/10 00:38:42  jussi
#	Added support for hi/lo values defined in schema.
#
#	Revision 1.25  1995/12/29 17:33:04  jussi
#	Changed format of view instance names created automatically.
#	Removed Double-Button-1 binding of group selection list.
#	Cleaned up code that initializes associative arrays.
#
#	Revision 1.24  1995/12/14 15:49:16  jussi
#	Added support for TileLayout with automatic or manual view layout
#	control.
#
#	Revision 1.23  1995/12/13 02:06:06  ravim
#	Changed criterion for not reloading the schema.
#
#	Revision 1.22  1995/12/04 18:28:15  jussi
#	Changed size of automatically created windows to depend on view
#	layout selected. For horizontal layout, the window is wide, for
#	vertical layout, it's tall.
#
#	Revision 1.21  1995/12/04 18:02:33  jussi
#	User can now choose to have a title, X axis, Y axis, X link enabled
#	or disabled in automatically generated views. Window name can be
#	specified too. Horizontal view layouts are available now.
#
#	Revision 1.20  1995/11/29 15:47:26  jussi
#	Removed constant size definition from some toplevel windows
#	because they will produce unexpected results on some window
#	managers.
#
#	Revision 1.19  1995/11/22 17:53:46  jussi
#	Added view type selection in automatic view generation. User can
#	now choose between a bar chart, an image, and a scatter plot.
#
#	Revision 1.18  1995/11/20 22:22:54  jussi
#	Changed sequence of caching data from tape to disk.
#	Restored missing history log.
#
#	Revision 1.17  1995/11/19 06:04:29  ravim
#	New way of displaying attributes and groups.
#
#	Revision 1.16  1995/11/18 01:49:46  ravim
#	Groups associated with schema. Also groups chosen at "Auto" stage.
#
#	Revision 1.15  1995/11/14 22:50:39  jussi
#	Interfaced new stream selection dialog into DefSource. Minor other
#	changes.
#
#	Revision 1.14  1995/11/07 20:24:48  jussi
#	Commented out some output statements.
#
#	Revision 1.13  1995/11/06 16:33:33  jussi
#	Increased minimum vertical size of .map window.
#
#	Revision 1.12  1995/10/29 01:01:12  ravim
#	Bug fix.
#
#	Revision 1.11  1995/10/27 21:05:03  ravim
#	Handles group names starting with capital letters.
#
#	Revision 1.10  1995/10/11 17:07:21  ravim
#	Minor changes.
#
#	Revision 1.9  1995/09/30 08:00:52  ravim
#	No changes - Ignore.
#
#	Revision 1.8  1995/09/30 07:59:18  ravim
#	Minor changes to group handling
#
#	Revision 1.7  1995/09/30 07:56:11  ravim
#	Initial implementation of schema browser - can create new schema files
#
#	Revision 1.6  1995/09/28 17:44:03  jussi
#	Included size, pattern, and orientation in all mapping definitions
#	although these are not used by DEVise currently. Minor other
#	touch-ups.
#
#	Revision 1.5  1995/09/27 17:20:34  ravim
#	Added support for groups in schemas.
#
#	Revision 1.4  1995/09/26 23:09:02  jussi
#	Added color/shape/size/pattern/orientation settings to view
#	definition.
#
#	Revision 1.3  1995/09/22 17:33:47  jussi
#	Added copyright message.
#
#	Revision 1.2  1995/09/21 15:36:27  jussi
#	Added small icons.
#
#	Revision 1.1  1995/09/13 14:24:07  jussi
#	Extracted macro definition code from control.tk.

############################################################

proc isDTEType {type} {
	if {$type == "SQLView" || $type == "Table" || $type == "DEVise"
		|| $type == "MaterView"
		|| $type == "Directory" || $type == "StandardTable" } {
		return 1
	} else {
		return 0
	}
}

proc SelectTopGroup {schemaname} {
    global selgrp

#puts "In SelectTopGroup schemaname=$schemaname"
    # get the list of top level group names from DEVise
    set topgrps [DEVise getTopGroups $schemaname]

    if {[llength $topgrps] == 1 && [lindex $topgrps 0] == "__default"} {
	return "__default"
    }

    # Create window to show list of top level group names
    toplevel .topgrps
    wm title .topgrps "Choose Attribute Group"
    wm geometry .topgrps +100+100
    selection clear .topgrps
    listbox .topgrps.list -relief raised -borderwidth 2 \
	    -yscrollcommand ".topgrps.scroll set" \
	    -font 9x15 -selectmode single
    scrollbar .topgrps.scroll -command ".topgrps.list yview"
    button .topgrps.ok -text OK -command {
	set selgrp [.topgrps.list get active]
	destroy .topgrps
    }
    pack .topgrps.ok -side bottom -fill x
    pack .topgrps.scroll -side right -fill y
    pack .topgrps.list -fill x 
    
    foreach i $topgrps {
	.topgrps.list insert end $i
    }
    
    tkwait visibility .topgrps
    grab set .topgrps
    tkwait window .topgrps

    return $selgrp
}

############################################################

proc OpenDataSource {sname} {
    global sourceList derivedSourceList

#    foreach name [array names derivedSourceList] {
#    	puts "$name $derivedSourceList($name)"
#	if { $name == $sname } { puts "They are equal" }
#    }
    set resName $sname
    set subName [string range $sname 0 9]
    if { $subName == "GstatXDTE:" } {
        set pos [string last ":" $sname]
        set mainName [string range $sname 0 [expr $pos-1]]
	set err [catch {set exists $derivedSourceList($sname)}]
	if {$err} {
	    set sname $mainName
	}
    } 
    set err [catch {set exists $derivedSourceList($sname)}]
    if {!$err} {
	set fname [isCached $sname -1 -1]
#	set fname [isCached $mainName -1 -1]
	if {$fname == ""} {
	    dialog .noDerivedData "No Derived Data" \
		    "Derived data \"$sname\" does not exist." \
		    "" 0 Ok
	    return ""
	}
	set stype [lindex $derivedSourceList($sname) 0]
#	set stype [lindex $derivedSourceList($mainName) 0]
#	set command [lindex $derivedSourceList($sname) 4]
	DEVise dataSegment $sname $fname 0 0
	return [list $resName $fname $stype]
#	return [list $sname $fname $stype]
    }

    # see if data source (still) defined (may be out-of-date in
    # a session file)

#   set err [catch {set exists $sourceList($sname)}]

	if {[string index $sname 0] != "."} {
		set newname ""
		regsub -all {\.| |,} $sname _ newname
		set newname ".$newname"
#		dialog .oldTableName "Old Table Name Format" \
#			"Table name $sname will be converted to $newname" \
#			"" 0 OK
		set sname $newname
	}
#	puts "looking up \"$sname\""
	set sourcedef [DEVise dteShowCatalogEntry $sname]
	set sourcedef [lindex $sourcedef 0]
	set err [expr [llength $sourcedef] == 0]
	if {$err == 0} {
		# entry exists
		set fname "[lindex $sourcedef 8]/[lindex $sourcedef 2]"
		set stype [lindex $sourcedef 1]
		set schemafile [lindex $sourcedef 4]
		set schema [lindex $sourcedef 3]
	}

    if {$err} {
	set but [dialog .sourceNotExists "Undefined Data Stream" \
		"Data stream \"$sname\" does not exist." \
		"" 0 OK "Select Another"]
	if {$but == 0} { return "" }
	while {1} {
	    set sname [selectStream]
	    if {$sname == ""} { return "" }
	    # must choose a single data stream
	    if {[llength $sname] > 1} {
		dialog .singleStream "Select Single Stream" \
			"You have selected more than one data stream.\
			Please select a single data stream." "" 0 Continue
		continue
	    }
	    break
	}
	set sname [lindex $sname 0]
    }

#   # cache data to disk right now
#   if {[isCached $sname -1 -1] == ""} {
#	set but [dialog .cacheData "Caching Data" \
#		"Cache \"$sname\" to disk now?" \
#		"" 1 Yes No]
#	if {$but == 1} {
#	    dialog .notCached "Must Cache Data Stream" \
#		    "Cannot visualize data without caching it to disk first." \
#		    "" 0 OK
#	    return ""
#	}
#   }
#
#   set fname [cacheData $sname -1 -1]
#   if {$fname == ""} {
#	return ""
#   }

    # Tell the C++ code whether this data is only a portion of a file.
#    set fileSeg [lindex $sourceList($sname) 8]
	set fileSeg [lindex $sourcedef 9]

	# fname for DQL was SQL command ??;
    DEVise dataSegment $sname $fname [lindex $fileSeg 0] [lindex $fileSeg 1]

#   set stype [lindex $sourceList($sname) 0]
#   if {$stype != "DQL" && $stype != "WWW" && $stype != "UNIXFILE"} {
#       set stype "UNIXFILE"
#   }

	if { ![isDTEType $stype] } {
		set stype "UNIXFILE"
	}

	return [list $sname $fname $stype $schemafile $schema]
}
############################################################

proc CacheMultipleDataSources {snames} {
    global sourceList

    set numnotcached 0
    foreach sname $snames {
	# see if data stream is on disk already
	if {[isCached $sname -1 -1] == ""} {
	    incr numnotcached
	}
    }

    if {$numnotcached > 0} {
	set but [dialog .cacheData "Caching Data" \
		"Will need to cache $numnotcached streams to disk now." \
		"" 0 OK Cancel]
	if {$but == 1} {
	    dialog .notCached "Cancel Visualization" \
		    "Cannot visualize data without caching it to disk first." \
		    "" 0 OK
	    return ""
	}
    }

    set sources [cacheMultipleData $snames -1 -1]
    return $sources
}

############################################################

proc OpenNewDataSource {derivedOnly} {
    # select data streams to display
    if {$derivedOnly} {
	set snames [selectDerivedStream]
    } else {
	set snames [selectStream]
    }

    if {$snames == ""} { return "" }

    # must choose a single data stream
#     if {[llength $snames] > 1} {
#	dialog .singleStream "Select Single Stream" \
#                "You have selected more than one data stream.\
#               Only the first stream will be visualized." "" 0 Continue
#   }
    return [ OpenAndDefineDataSources $derivedOnly $snames ]
}

############################################################

proc OpenAndDefineDataSources {derivedOnly snames} {
    global sourceList derivedSourceList

#    puts "In OpenAndDefineDataSources($derivedOnly, $snames)"

    if {[llength $snames] > 1} {
	dialog .singleStream "Select Single Stream" \
                "You have selected more than one data stream.\
                Only the first stream will be visualized." "" 0 Continue
	set snames [lindex $snames 0]
    }
    set result ""

    foreach sname $snames {

       set sname [string trimleft $sname "{"]
       set sname [string trimright $sname "}"]
       set sourcedef [OpenDataSource $sname]

        if {$sourcedef == ""} {
            return ""
        }

        set sname [lindex $sourcedef 0]
        set param [lindex $sourcedef 1]
        set stype [lindex $sourcedef 2]
	   set schemafile [lindex $sourcedef 3]
	   set schema [lindex $sourcedef 4]
      	
        # see if data stream already open
	set tdata_exist 0 
        if {[lsearch [TdataSet] $sname] >= 0} {
#	    set pos [string first : $sname ]
#	    if {$pos > 0} { 
#	    	set prefix [string range $sname 0 [expr $pos-1]]
#	    	if {$prefix == "Hist" || $prefix == "HistDate" || $prefix == "GstatX" 
#	        	|| $prefix == "GstatXDTE" || $prefix == "GstatXDate" 
#			|| $prefix == "GstatY" || $prefix == "GstatYDate" } { 
#			set tdata_exist 1 
#	    	} 
#	    }
	    set tdata_exist 1
        }

	if {$derivedOnly} {

	    set schema [lindex $derivedSourceList($sname) 2]
	    set schemafile [lindex $derivedSourceList($sname) 3]
        } else {
#           set schema [lindex $sourceList($sname) 2]
#           set schemafile [lindex $sourceList($sname) 3]
        }

        # load schema file if necessary - it is not sufficient to check if
        # the physical schema by the same name has been loaded because the same
        # physical schema may be shared by several logical schemas - the best
        # way of checking is to see that we have no groups defined under the 
        # logical schema name

	if { [isDTEType $stype] } {
		set schema $sname
		set topgrps [DEVise getTopGroups $sname]
        	if {[llength $topgrps] == 0} {
			set result [DEVise dteImportFileType $sname]
		}
		if {$tdata_exist == 0} {
			# do nothing
		} else { 
			set result [DEVise getTDataName $sname]
		}

   	} else {
          	set topgrps [DEVise getTopGroups [file tail $schemafile]]
		#puts "topgrps = $topgrps"
        	if {[llength $topgrps] == 0} {

            	    if {![file readable $schemafile]} {
                	dialog .schemaError "Schema Not Found" \
                          "Cannot open schema $schemafile" "" 0 OK
                	return ""
            	    }
			# Send the file type UNIXFILE etc.. 
			# followed by schemaFile Name
			# followed by the dataFile name (param)
			
			# this call appears to parse the schema ??? DD
			#
            	    set result [DEVise importFileType $stype $schemafile $param]
            
		    if {$result == ""} {
                	return ""
                    }
            	    if {$result != $schema} {
                	puts "File $schemafile appears to contain schema $result,\
                        	not $schema"
                	set schema $result
            	    }
                }

        statusWindow .info "Status" \
                "Creating an index on \"$sname\".\n\n\This may take a while."
        update

	if {$tdata_exist == 0} {
        	# ask DEVise to create tdata
        	set result [DEVise create tdata $schema $sname $stype $param]
	} else { 
		set result [DEVise getTDataName $sname]
	}

        catch {destroy .info}

        if {$result == ""} {
            dialog .tdataError "Data Stream Error" \
                    "Cannot open data stream $sname" "" 0 OK
            return ""
        }
	}
    }

    if { [isDTEType $stype] } {
	return [list [lindex $snames 0] $sname 1]
    } else {
	return [list $result [file tail $schemafile] 0]
    }
}

############################################################

proc setupAttrCheckButtons {win var schemaname grpname topgrp} {
    global $var

    set row -1
    set col -1
    set maxcol 1
    set varcnt 0

    # We will do some preprocessing to figure out how to display the
    # the attributes - i.e. how many columns per row, size of menu
    # buttons and the size of the window itself.
    
    set grplist [DEVise getItems $schemaname $topgrp $grpname]
#    puts "schemaname=$schemaname, topgrp=$topgrp, grpname=$grpname"
#    puts "after getItems grplist = $grplist"
	
    # Find the max width of the attrs and the number of attrs
    set numattrs 0
    set maxwidth 0
    foreach itm $grplist {
	set subname [lindex $itm 0]

	set width [llength [split $subname {}]]
	if {$width > $maxwidth} {
	    set maxwidth $width
	}
	incr numattrs
    }

    if {$maxwidth < 13} {
	set maxwidth 13
    }
    incr maxwidth 2
    set maxcol [expr 75 / $maxwidth]
    if {$maxcol < 1} {
	set maxcol 1
    }
    set colwidth $maxwidth
    
    foreach itm $grplist {
	set subname [lindex $itm 0]
	set type [lindex $itm 1]
	set checkvar [format "%s(%s)" $var $subname]

	if {$col < 0} {
	    incr row
	    set col 0
	    frame $win.row$row
	    pack $win.row$row -side top -fill x -expand 1
	}

	# If regular attribute, add a check button; otherwise,
	# add a button which launches a submenu window

	if {$type != "intr"} {
	    checkbutton $win.row$row.col$col \
		    -text $subname -variable $checkvar \
		    -width $colwidth -indicatoron 0 \
		    -selectcolor #e6ceb1
	    set $checkvar 0
	} else {
	    menubutton $win.row$row.col$col \
		    -relief raised \
		    -text $subname -width $colwidth \
		    -bg darkslategray4 -fg wheat \
		    -menu "$win.row$row.col$col.menu"
	    setupAttrCheckMenu $win.row$row.col$col.menu $var $schemaname \
		    $subname $topgrp
	}
	pack $win.row$row.col$col -side left -fill x -expand 1
	incr col
	if {$col >= $maxcol} {
	    set col -1
	}
    }

    # Add empty frames at end of last row
    for {} {$row >= 0 && $col >= 0 && $col < $maxcol} {incr col} {
	label $win.row$row.col$col -text "" \
		-width $colwidth -relief flat -borderwidth 4
	pack $win.row$row.col$col -side left -fill x -expand 1
    }
}

############################################################

proc setupAttrCheckMenu {menu var schemaname grpname topgrp} {
    global $var

    menu $menu -tearoff 0

    set grplist [DEVise getItems $schemaname $topgrp $grpname]

    foreach itm $grplist {
	set subname [lindex $itm 0]
	set type [lindex $itm 1]
	set checkvar [format "%s(%s)" $var $subname]

	# If regular attribute, add a check button; otherwise,
	# add a cascaded menu for group

	if {$type != "intr"} {
	    $menu add checkbutton -label $subname -variable $checkvar
	    set $checkvar 0
	} else {
	    $menu add cascade -label $subname -menu $menu.g$subname
	    setupAttrCheckMenu $menu.g$subname $var $schemaname \
		    $subname $topgrp
	}
    }
}

############################################################

proc setupAttrRadioMenu {menu var prefix schemaname grpname topgrp} {
    global $var

    menu $menu -tearoff 0

    set grplist [DEVise getItems $schemaname $topgrp $grpname]

    set default ""
    set defaultset 0
#    set $var ""

    foreach itm $grplist {
	set subname [lindex $itm 0]
	set type [lindex $itm 1]

	# If regular attribute, add a check button; otherwise,
	# add a cascaded menu for group

	if {$type != "intr"} {
		if {!$defaultset} {
			# set default value of var to the first in list
			set defaultset 1
			set default $prefix$subname
		}
	    $menu add radiobutton -label $subname -variable $var \
		    -value $prefix$subname
	} else {
	    $menu add cascade -label $subname -menu $menu.g$subname
	    setupAttrRadioMenu $menu.g$subname $var $prefix $schemaname \
		    $subname $topgrp
	}
    }
    return $default
}

############################################################

proc MacroImport {mode derivedOnly} {
    global schemadir
    global dialogListVar sourceList derivedSourceList

    set tdata ""

    if {!$derivedOnly && $mode > 0} {
	set tdataSet [TdataSet]
	if {[llength $tdataSet] >= 0} {
	    set answer [ dialogList .selectTData "Visualize Data Stream"  \
		    "Select a data stream" \
		    "" 0 { OK Cancel } $tdataSet ]
	    if {$answer == 1 || $dialogListVar(selected) == ""} {
		return
	    }
	    if {$answer == 0} { 
		set tdata $dialogListVar(selected)
	    } else {
		set tdata ""
	    }
	}
    }

    if {$tdata == ""} {
	set name_schema_pair [OpenNewDataSource $derivedOnly]
	set tdata [lindex $name_schema_pair 0]
	set schemaname [lindex $name_schema_pair 1]
	set is_dte_type [lindex $name_schema_pair 2]
#	puts "is_dte_type = $is_dte_type"
	set schemafile "$schemadir/$schemaname"
    }
    
    if {$tdata == ""} { return }

    if {$derivedOnly} {
	set schemafile [lindex $derivedSourceList($tdata) 3]
    } else {
#	set schemafile [lindex $sourceList($tdata) 3]
    }

    if {$mode && $derivedOnly} {
	StatText $tdata $schemafile
    } else {
#        set schemaname [file tail $schemafile]
	MacroDefAuto $tdata $schemaname $is_dte_type
    }
}

#############################################################

proc StatText {tdata schemafile} {
    global curView viewselname bgcolor 
    
    set pos ""
    set subder ""
    set vname ""
    set pos [string first : $tdata]
    if {$pos > 0} {
        set subder [string range  $tdata 0 [expr $pos-1]]
        set vname  [string range  $tdata [expr $pos+1] end]
        set subder [string trim $subder]
        set vname  [string trim $vname]
	set vname [string tolower $vname]
	set nchar [string first . $vname]
	regsub  -all {[^a-zA-Z0-9]} $vname "_"  vname
    }

    if {[WindowVisible .$vname]} {
	return
     }
	 
     set schema [DEVise getSchema $tdata]
     set schemaname [file tail $schemafile]
#	 puts " TOP GROUP IS CALLE DIN STAT TEXT "
     set topgrp [SelectTopGroup $schemaname]

     toplevel .$vname
     wm title .$vname "Text Statistics"
     wm geometry .$vname +50+50

     frame .$vname.name -relief raised -bd 2 -height 2
     frame .$vname.text -background LightBlue
     set namelist [DEVise getItems $schemaname $topgrp $topgrp]
     set nlist ""
     foreach entry $namelist {
	set name [lindex $entry 0]
	if {$name != "recId"} {
	    lappend nlist $name
	    label .$vname.s$name -text $name
	    listbox .$vname.l$name -yscroll ".$vname.scroll set" \
		-relief raised 
	    pack .$vname.s$name -side left -in .$vname.name -expand 1 -fill x
	    pack .$vname.l$name -side left -in .$vname.text -expand 1 -fill x
	}
     }
     scrollbar .$vname.scroll -command "AllList {$vname $nlist}"

     pack .$vname.scroll -side right -in .$vname.text -fill y

     set buffList ""
     set buffList [DEVise getStatBuffer $tdata]

     foreach line $buffList {
	 set temp [split $line " "]
	 set j 0
         foreach name $nlist {
	     .$vname.l$name insert end [lindex $temp $j]
	     incr j 1
         }
     }

     button .$vname.close -text Close -command "Close .$vname" -width 10
     pack .$vname.close -side bottom

     pack .$vname.name .$vname.text -side top -fill x -expand 1
}

#############################################################

proc Close {name} {
     destroy $name
}

############################################################

proc AllList {list  args} {
     set viewname [lindex $list 0]
     foreach name $list {
        if {$name != $viewname} {
	    eval .$viewname.l$name yview $args
        }
     }
}

#############################################################
proc MacroDefAuto {tdata schemaname {is_dte_type 0}} {
    global x yvar viewselname bgcolor linksel windowsel titlesel
    global xaxissel yaxissel cancel newgdata viewsel
    global sourceList global curView
    
    if {[WindowVisible .auto]} {
	return
    }
    
    #    puts "In MacroDefAuto($tdata, $schemaname)"
    
    #    set schema [DEVise getSchema $tdata]
    #   set schemaname [file tail $schemafile]
    
    set topgrp [SelectTopGroup $schemaname]
    
    #    puts "schemaname = $schemaname, topgrp = $topgrp"
    
    toplevel .auto
    wm title .auto "Define Visualization"
    wm geometry .auto +50+50
    selection clear .auto
    
    label .auto.label -text "Define Visualization Parameters"
    
    frame .auto.top
    frame .auto.mid
    frame .auto.bot
    frame .auto.ysel -relief groove -borderwidth 2
    frame .auto.but

    pack .auto.label -side top -pady 3m -fill x -expand 1
    pack .auto.top -side top -pady 3m -fill x -expand 1
    pack .auto.mid -side top -pady 3m -fill x -expand 1
    pack .auto.bot -side top -pady 3m -fill x -expand 1
    pack .auto.ysel -side top -pady 3m -fill x -expand 1
    pack .auto.but -side top -pady 3m -fill x -expand 1

    frame .auto.windowsel -relief groove -borderwidth 2
    frame .auto.xsel -relief groove -borderwidth 2
    pack .auto.windowsel .auto.xsel -in .auto.top -side left \
	    -ipady 3m -padx 1m -fill x -expand 1

    frame .auto.viewsel -relief groove -borderwidth 2
    frame .auto.colorsel -relief groove -borderwidth 2
    frame .auto.gdatasel -relief groove -borderwidth 2
    pack .auto.viewsel .auto.colorsel .auto.gdatasel \
	    -in .auto.mid -side left -ipady 3m -padx 1m -fill x -expand 1

    frame .auto.titlesel -relief groove -borderwidth 2
    frame .auto.linksel -relief groove -borderwidth 2
    frame .auto.xaxissel -relief groove -borderwidth 2
    frame .auto.yaxissel -relief groove -borderwidth 2
    pack  .auto.titlesel .auto.linksel .auto.xaxissel .auto.yaxissel \
	    -in .auto.bot -side left -ipady 3m -padx 1m -fill x -expand 1
	

    label .auto.windowsel.label -text "Window:"
    menubutton .auto.windowsel.window -relief raised \
	    -textvariable windowsel -menu .auto.windowsel.window.menu \
	    -width 30
    pack .auto.windowsel.label .auto.windowsel.window -side left -padx 1m

    set windowsel ""
    if {[DEVise getWinCount] <= 1} {
    	set windowsel New
    } elseif {$curView != ""} {
	set windowsel [DEVise getViewWin $curView]
    }
    if {$windowsel == ""} {
	set windowsel "None selected yet"
    }
   
    menu .auto.windowsel.window.menu -tearoff 0
    foreach w [WinSet] {
	.auto.windowsel.window.menu add command -label $w \
		-command "set windowsel {$w}"
    }

    .auto.windowsel.window.menu add separator
    .auto.windowsel.window.menu add command -label "New" -command {
	    set windowsel New
    }
    #	set newwin [DoCreateWindow "Select window type"]
    #	if {$newwin != ""} {
	#	    set windowsel $newwin
	#	    .auto.windowsel.window.menu add command -label $windowsel \
		#		    -command "set windowsel {$windowsel}"
	#	}
	
	label .auto.xsel.label -text "Select X:"
	menubutton .auto.xsel.attr -relief raised \
		-textvariable x -menu .auto.xsel.attr.g$topgrp -width 20
	pack .auto.xsel.label .auto.xsel.attr -side left -padx 1m
	#    puts "Before setupAttrRadioMenu, schemaname=$schemaname, topgrp=$topgrp"
	set defaultx [setupAttrRadioMenu \
		.auto.xsel.attr.g$topgrp x "" $schemaname $topgrp $topgrp]
	
	label .auto.viewsel.label -text "View Type:"
	menubutton .auto.viewsel.view -relief raised \
		-textvariable viewselname -menu .auto.viewsel.view.menu -width 15
	pack .auto.viewsel.label .auto.viewsel.view -side left -padx 1m
	
	menu .auto.viewsel.view.menu -tearoff 0
	.auto.viewsel.view.menu add radiobutton -label "Scatter Plot" \
	    -variable viewselname -value "Scatter Plot" -command {
	set viewsel 0
    }
    .auto.viewsel.view.menu add radiobutton -label Pixels \
	    -variable viewselname -value Pixels -command {
	set viewsel 1
    }
    .auto.viewsel.view.menu add radiobutton -label "Bar Chart" \
	    -variable viewselname -value "Bar Chart" -command {
	set viewsel 2
    }
    set viewselname "Bar Chart"
    set viewsel 2
    
    checkbutton .auto.gdatasel.link -text "New Mappings" -variable newgdata
    pack .auto.gdatasel.link -side left -padx 3m
    set newgdata 1

    label .auto.colorsel.label -text "Background:"
    button .auto.colorsel.color -width 15 -textvariable bgcolor \
	-command "getColor bgcolor" -highlightthickness 0
    pack .auto.colorsel.label .auto.colorsel.color -side left -padx 1m
    set bgcolor "AntiqueWhite"

    checkbutton .auto.titlesel.title -text Title -variable titlesel
    pack .auto.titlesel.title -side left -padx 3m
    set titlesel 1

    checkbutton .auto.linksel.link -text "Link X" -variable linksel
    pack .auto.linksel.link -side left -padx 3m
    set linksel 1

    checkbutton .auto.xaxissel.xaxis -text "X Axis" -variable xaxissel
    pack .auto.xaxissel.xaxis -side left -padx 3m
    set xaxissel 1

    checkbutton .auto.yaxissel.yaxis -text "Y Axis" -variable yaxissel
    pack .auto.yaxissel.yaxis -side left -padx 3m
    set yaxissel 1
	
    if {$topgrp == "__default"} {
	set slabel "Select Y"
	set swidth 15
    } else {
	set slabel "Select Y from $topgrp"
	set swidth [expr [llength [split $topgrp {}]] + 15]
    }
    label .auto.ysel.label -text $slabel -width $swidth
    pack .auto.ysel.label -side top -fill x -expand 1 -pady 2m

	# clear the yvar array 
	catch {unset yvar}

    frame .auto.ysel.sel
    pack .auto.ysel.sel -side top -padx 3m -pady 1m -expand 1
    setupAttrCheckButtons .auto.ysel.sel yvar $schemaname $topgrp $topgrp

#   x is set to the first variable in the list (DD)

    set x $defaultx

#   set schema [DEVise dteListAttributes $tdata]
#   set x [lindex [lindex $schema 0] 0]

#   # Try to select default X to be a sorted attribute
#   foreach attr $schema {
#	set name [lindex $attr 0]
#	set type [lindex $attr 1]
#	set sorted [lindex $attr 2]
#	if {$sorted > 0 && $name != "recId"} {
#	    set x $name
#	    break
#	}
#   }

    tk_menuBar .auto.xsel .auto.xsel.attr
    set cancel 0
	
    button .auto.but.ok -text OK -width 15 -command {
#	if {![DEVise exists $windowsel]} {
#	    dialog .winError "No Window Specified" \
#		    "Please select a window for visualization." \
#	    "" 0 OK
#	   return
#	}

	# See whether we've selected any Y attributes.
	foreach yname [array names yvar] {
	    if {$yvar($yname) > 0} {
		# Yes, a Y attr has been selected.  Now create a window
              # if necessary, and make sure that it exists.  Prompt the
              # user to select a window if one has not been selected.
              if {$windowsel == "New"} {
                set newwin [DoCreateWindow "Select window type"]
                if {$newwin != ""} {
                  set windowsel $newwin
                }
              }
              if {![DEVise exists $windowsel]} {
                  dialog .winError "No Window Specified" \
                          "Please select a window for visualization." \
                  "" 0 OK
                 return
              } else {
                set cancel 0
                return
              }
	    }
	}

	# No -- no Y attr has been selected.  Prompt the user to do so.
	dialog .autoError "Note" \
		"Please select one or more\n\
		Y attributes for automatic\n\
		mapping." "" 0 OK
	return
    }
    button .auto.but.cancel -text Cancel -width 15 -command {
	set cancel 1
    }
    pack .auto.but.ok .auto.but.cancel -side left -expand 1 -padx 3m
	

    tkwait variable cancel
    destroy .auto

    if {$cancel} {
	return
    }

    set ylist ""
    foreach yname [array names yvar] {
	if {$yvar($yname) > 0} {
	    lappend ylist $yname
	}
    }
    
#    puts "The value of x is $x"
#    puts "The ylist is $ylist"
    
if {$is_dte_type} {
    #            set result [DEVise create tdata $tdata $tdata "$x $ylist"]
    #            set tdata $result
    #	    puts "In MacroDefAuto XXXXX After dte creates tdata x=$x ylist=$ylist tdata=$tdata" 
    
    # see if data stream already open
    if {[lsearch [TdataSet] $tdata] < 0} {
	
	# not open
	
	set result [DEVise create tdata $tdata $tdata "$x $ylist"]
	set tdata $result
    }
    
}
MacroDefAutoActual $tdata $viewsel $linksel $windowsel $bgcolor \
	$titlesel $xaxissel $yaxissel $x $ylist $newgdata
}

############################################################

# all attrs except 'attr' are passed by reference
proc ProcessAttrInfo { attr aname atype issorted ahi alo color whichattr \
	{viewsel 0}}  {
    upvar $aname name
    upvar $atype type
    upvar $issorted sorted
    upvar $ahi hi
    upvar $alo lo
    upvar $color colorAttr

    set hi ""
    set lo ""
    # The mapping may be an expression. So we set  defaults for lo and hi
    # values. This is not needed in the COre devise as the initial mapping
    # always chooses attributes but the LM shows the mapping box instead
    # and hence I did this to reuse code -Shilpa.
    
    #puts "Processing attr $attr"
    if { $attr != "__Unknown__"} { 
	set name [lindex $attr 0]
	set type [lindex $attr 1]
	if {[string tolower $name] == "color" && $type == "int"} {
	set colorAttr $name
	}
	set sorted [lindex $attr 2]
	set hashi [lindex $attr 3]
	if {$hashi} {
	    set hi [lindex $attr 4]
	    if {$viewsel == 2 && $whichattr == "y" } {
		set hi [ScaleUpper $hi]
	    }
	}
	set haslo [lindex $attr 5]
	if {$haslo} {
	    set lo [lindex $attr 6]
	    if {$viewsel == 2 && $whichattr == "y" } {
		set lo [ScaleLower $lo]
	    }
	}
    }
    
    # Also consult lo/hi values defined in .rc file
    set viewParams ""
    catch { set viewParams $viewDefault($type) }
    foreach param $viewParams {
        set pname [lindex $param 0]
        set value [lindex $param 1]
	if { $whichattr == "x" } {

	    if {$lo == "" &&  $pname == "xlow"} {
		set lo $value
	    }
	    if {$hi == "" && $pname == "xhigh"} {
		set hi $value
	    }
	} elseif { $whichattr == "y" } {
	    if {$lo == "" &&  $pname == "ylow"} {
		set lo $value
	    }
	    if {$hi == "" && $pname == "yhigh"} {
		set hi $value
	    }
	}
    }
    
    # if no defaults specified anywhere, resort to these defaults
    if {$hi == ""} {
        set hi 100
    }
    if {$lo == ""} {
        set lo 0
    }
    
    if {$lo == $hi} {
        set lo [expr $lo - 1]
        set hi [expr $hi + 1]
    }

    #puts "Mapping will have xlo $xlo and xhi $xhi"
}    

proc CleanName { name } { 	
    set clean_name ""
    if { [string first "max(" $name ] > 0 } {
	set clean_name "Max"
    } elseif { [string first "min(" $name] > 0} {
	     set clean_name "Min"
    } elseif { [string first "avg(" $name] > 0} {
	set clean_name "Avg"
    } elseif { [string first "count(" $name] > 0} {
	set clean_name "Count"
    } elseif { [string first "sum(" $name] > 0} {
	set clean_name "Sum"
    } else {
	set clean_name $name
    }
    
    return $clean_name
}


proc MacroDefAutoActual {tdata viewsel linksel window bgcolor \
	titlesel xaxissel yaxissel x ylist \
	newgdata {ofAttr ""}} {
    #    puts "In MacroDefAutoActual tdata=$tdata $viewsel $linksel \
    #          $window $bgcolor \
    #          $titlesel $xaxissel $yaxissel $x $ylist $newgdata"
    
    
    #    puts "In MacroDefAutoActual, schema = $schema"
    
    global viewDefault DEViseShapes curView
    
    set pos ""
    set subder ""
    set vname ""
    set tdata [string trimleft $tdata "{"]
    set tdata [string trimright $tdata "}"]
    set pos [string first : $tdata]

    if {$pos > 0} {
        set subder [string range  $tdata 0 [expr $pos-1]]
	set vname  [string range  $tdata [expr $pos+1] end]
	set subder [string trim $subder]
	set vname  [string trim $vname]
    } 
    
    #puts "Before getSchema $tdata"
    
    set schema [DEVise getSchema $tdata]

    set colorAttr ""
    set sortedx 0
    set xlo ""
    set xhi ""

    # Find out type of X and whether it is sorted or not.
    # Also find out if there is a 'color' attribute.

    foreach attr $schema {
	if { [lindex $attr 0] == $x } {
	    break;
	}
    }
    ProcessAttrInfo $attr xname xtype sortedx  xhi xlo colorAttr \
	    "x" $viewsel

    #puts "$xname $xtype $sortedx $colorAttr $xhi $xlo"
    if {$sortedx > 0} {
        set sortedx SortedX
    } else {
        set sortedx Scatter
    }
    set color 2
    set shape $viewsel
    set size 1
    set pattern 0
    set orient 0
    set shapeAttr0 ""
    set shapeAttr1 ""
    set shapeAttr2 ""

    set view_exist 0
    set titletext ""
    set mmmtext ""
    set mmm_view ""

    if {$shape == 1} {
        # set pixel width and height to one for image displays
        set shape 0
        set shapeAttr0 1
        set shapeAttr1 1
    }

    if {$linksel} {
        set linkname [format "%s Link" $x]
        if {![DEVise exists $linkname]} {
            # ask DEVise to create link
            set result [DEVise create link Visual_Link $linkname 1]
            if {$result == ""} {
                dialog .linkError "Link Error" \
                        "Error creating link $linkname" "" 0 OK
                return
            }
        }
    }

    #    puts "schema=$schema"
    foreach attr $schema {
        set name [lindex $attr 0]
	
	set clean_name [CleanName $name]
	
	#puts "clean_name = $clean_name "
	set is_mmm 0
	if {[lsearch $ylist $clean_name] < 0}  {
	    continue
	}
	if {$clean_name=="Max"||$clean_name=="Min"||$clean_name=="Avg"} {
	    set is_mmm 1
	}
	if {$mmm_view != "" && $is_mmm == 1} { 
	    continue
	}
	
	set colorY ""
	
	# for bar shape, make ylo zero

	if {$shape == 2 } {
	    set ylo 0
	}

	ProcessAttrInfo $attr yname type sorted yhi ylo colorY "y" $viewsel
	#puts "$yname $type $sorted $colorY $yhi $ylo"
	
	if {$clean_name=="Count"} { set color 2 }
	if {$clean_name=="Sum"} { set color 3 }
	if {$clean_name=="Max"} { set color 0 }
	if {$clean_name=="Avg"} { set color 2 }
	if {$clean_name=="Min"} { set color 3 }
	
        if {$subder == "Stat" \
		|| $subder == "GstatX" \
		|| $subder == "GstatXDTE" \
		|| $subder == "GstatY" \
		|| $subder == "GstatXDate" \
		|| $subder == "GstatYDate" } {
            if {$clean_name=="Max"} {
		set shapeAttr0 0.2
            }
            if {$clean_name=="Avg" || $clean_name=="Mean"} {
		set shapeAttr0 0.2
            }
            if {$clean_name=="Min"||$clean_name=="Count"} {
		set shapeAttr0 0.2
            }
	    if {$subder == "Stat" } { 
		if {$clean_name=="Min" \
			||$clean_name=="Max" \
			||$clean_name=="Avg"} {
		    set shape [findNumericCaseValue $DEViseShapes {RectX}] 
		}
	    }
    	} elseif {$subder == "Hist"  } {
	    set shape [findNumericCaseValue $DEViseShapes {Bar}]
        }
	
        # ask DEVise to create view instance
        set sorted $sortedx
        set viewbasename "View 1"
	
	set mmm_list {Max Mean Avg Min}	
	set stat_list {Stat GstatX GstatXDTE GstatY GstatXDate GstatYDate}
	set histView ""
	if {$subder == "Hist" || $subder == "HistDate" } {
	    set histView [DEVise getHistViewname $curView]
	}
	
	if {[DEVise exists $histView]} {
		set viewinstance $histView
	} elseif {[lsearch $stat_list $subder] < 0 \
		|| !$view_exist  \
		|| [lsearch $mmm_list $clean_name] < 0} {
	    set viewinstance [UniqueName $viewbasename]
	    if {[lsearch [ViewSet] $viewinstance] >= 0} {
		dialog .viewError "View Error" \
			"View $viewinstance exists already." "" 0 OK
		return
	    }
	    set result [DEVise create view $sorted $viewinstance \
		    $xlo $xhi $ylo $yhi $bgcolor]
	    if {$result == ""} {
		dialog .viewError "View Error" \
			"Error creating view $viewinstance" "" 0 OK
		return
	    }
	    if {$subder == "Hist" || $subder == "HistDate" } {
	    	DEVise setHistViewname $curView $viewinstance
	    }
	    if {$clean_name == "Max" || $clean_name == "Mean" || $clean_name == "Avg"
	    || $clean_name == "Min" } {
		set view_exist 1 
	    	set mmm_view $viewinstance 
	    }
	} else {
	    set viewinstance $mmm_view
	}
	
        # ask DEVise to turn on/off label
	if {$subder == "Stat" \
		|| $subder == "GstatX" \
		|| $subder == "GstatXDTE" \
		|| $subder == "GstatY" \
		|| $subder == "GstatXDate" \
		|| $subder == "GstatYDate" } {
	    if {$clean_name == "Max" \
		    || $clean_name == "Mean" \
		    || $clean_name == "Avg"  \
		    || $clean_name == "Min"} {
		if {$mmmtext==""} {
		    set titletext "Max|Avg|Min\($ofAttr\) vs. $x"
		    set mmmtext $titletext
		} else { 
		    lappend mmmtext "$name vs. $x"
		    set titletext $mmmtext
		}
	    } else {
		set titletext "$name\($ofAttr\) vs. $x"
	    }
	} else {
	    set titletext "$name\($ofAttr\) vs. $x"
	}
	
	if {[llength $ylist] == 1 && $titletext == "" } {
	    set titletext $tdata
	}
	if {$titlesel} {
	    DEVise setLabel $viewinstance 1 16 $titletext
	} else {
	    DEVise setLabel $viewinstance 0 12 $titletext
	}
	
	# ask DEVise to turn on/off X axis
	DEVise setAxisDisplay $viewinstance X $xaxissel
	
	# ask DEVise to turn on/off Y axis
	DEVise setAxisDisplay $viewinstance Y $yaxissel
	
	# if new mappings are requested, associate color with mapping,
	# otherwise associate color with view
	if {0 && !$newgdata} {
	    DEVise setViewOverrideColor $viewinstance $color 1
	}
	
	# for map color, either use constant color, or variable
	# if defined in the schema
	set mapColor $color
	if {$colorAttr != ""} {
	    set mapColor \$$colorAttr
	}
	set mapname [format "%s_vs_%s" $name $x]
	
	if {[lsearch [DEVise get mapping] $mapname] < 0} {
	    # ask DEVise to create interpreted mapping class
	    set result [DEVise createMappingClass $mapname]
	}
	
	set mapinstance "$tdata#$mapname"
	if {$newgdata} {
	    # new mappings are requested
	    set mapinstance [UniqueName $mapinstance]
	}
	if {[lsearch [GdataSet] $mapinstance] < 0} {
	    if {$is_mmm == 1} { 
		set name "Avg"
		set shape [findNumericCaseValue $DEViseShapes \
			{HighLow}]
		set shapeAttr0 "\$Max"
		set shapeAttr1 "\$Min"
		set size 3
		if {$x == "DATE"} {set size 4000000 }
		set result [DEVise create mapping \
			$mapname $tdata $mapinstance \
			"" \$$x \$$name "" $mapColor \
			$size $pattern $orient $shape \
			"" $shapeAttr0 $shapeAttr1 ]
	    } else {
		# ask DEVise to create an instance of mapping
		set result [DEVise create mapping $mapname $tdata \
			$mapinstance \
			"" \$$x \$$name $mapColor $size $pattern\
			$orient $shape \
			$shapeAttr0 $shapeAttr1]
	    }
	    DEVise setPixelWidth $mapinstance 1
	}
	
	# ask DEVise to insert $mapinstance into $viewinstance
	set result [DEVise insertMapping $viewinstance $mapinstance]
	# seems that there's no error code returned
	
	# ask DEVise to insert $viewinstance into $window
	set result [DEVise insertWindow $viewinstance $window]
	# seems that there's no error code returned
	
	if {$linksel} {
	    # ask DEVise to link $viewinstance to $linkname
	    set result [DEVise insertLink $linkname $viewinstance]
	    # seems that there's no error code returned
	}
	
	DEVise clearViewHistory $viewinstance
	DEVise insertViewHistory $viewinstance $xlo $ylo $xhi $yhi 0
	
	ProcessViewSelected $viewinstance
	if {$colorAttr == ""} { incr color }
    }
}








