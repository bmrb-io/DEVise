#  ========================================================================
#  DEVise Data Visualization Software
#  (c) Copyright 1992-1996
#  By the DEVise Development Group
#  Madison, Wisconsin
#  All Rights Reserved.
#  ========================================================================
#
#  Under no circumstances is this software to be copied, distributed,
#  or altered in any way without prior permission from the DEVise
#  Development Group.

############################################################

#	$Id$	

#	$Log$
#	Revision 1.6  1995/11/21 23:38:20  jussi
#	The user can now select either constant values for a mapping
#	attribute, or a field from TData schema.
#
#	Revision 1.5  1995/09/22 17:33:40  jussi
#	Added copyright message.
#
#	Revision 1.4  1995/09/05 22:47:59  jussi
#	Added/updated CVS header.
#
#	Revision 1.3  1995/09/05 22:43:50  jussi
#	Updated CVS header.

############################################################

# tian zhang 01/20/95
# mod by jussi myllymaki 09/04/95
# -- mappings are changed using pull-down menus rather than separate dialogs
#
# this procedure use a dialog box to input and edit mapping.
# The interface of dialogMapping:
# proc dialogMapping {w title text bitmap mappings GetName}
#
# w: window name
# title: window title
# text: text message
# bitmap: bitmap to be displayed
# mappings: mapping params in the following form:
# { { name1 {{attr type} {attr type} ...} {default mapping 1} }
#   { name2 {{attr type} {attr type} ...} {default mapping 2}}
#  ...
# }
# For example:
# { {x { {time date} {name string} {temp int} } time }
#   {y { {time date} {name string} {temp int} } temp }
#   {color { {1 black} {2 red} {3 yellow} } 3 }
#  ...
# }
# getName: set true to display the name of the mapping.
# REturn: 
#	if netName == false, the new mapping.
#	else, a list containing {mappingName mapping}
#############################################################################

# Find maximum length of labels
# { {label {val1 val2 ...} defvalue} ... }
proc FindMaxLabelLength { mappings } {
    set maxlen 1
    foreach item $mappings {
	set len [string length [lindex $item 0]]
	if {$len > $maxlen} {
	    set maxlen $len
	}
    }
    return $maxlen
}

# Find maximum length of values
# { {label {val1 val2 ...} defvalue} ... }
proc FindMaxValueLength { mappings } {
    set maxlen 1
    foreach item $mappings {
	foreach val [lindex $item 1] {
	    set len [string length $val]
	    if {$len > $maxlen} {
		set maxlen $len
	    }
	}
    }
    return $maxlen
}

proc dialogMapping {w title text bitmap attrlist mappings {getName 0} } { 
    global button1

    # default options for Frame, Button
    set tmpFrameOpt ""
    set tmpButtonOpt ""

    # destroy the old widget with the same name if there exists one
    catch {destroy $w}

    # toplevel widget parameters
    toplevel $w -borderwidth 2
    catch "$w config $tmpFrameOpt"
    wm geometry $w +50+50
    # wm geometry $w 400x150
    wm maxsize $w 1000 1000
    wm minsize $w 100 100
    wm title $w $title
    wm iconname $w DialogMapping

    #########################################################################

    # display TEXT or BITMAP in a sub widget
    label $w.message -text "$text" -bitmap "$bitmap" \
	    -font -*-*-medium-r-normal-*-140-*-*-m-*
    catch "$w.message config $tmpFrameOpt" 

    #########################################################################

    # handle mapping: {x y color shape ...} in a sub widget
    frame $w.mapping
    catch "$w.mapping config $tmpFrameOpt"
    frame $w.mapping.label
    catch "$w.mapping.label config $tmpFrameOpt"
    frame $w.mapping.value
    catch "$w.mapping.value config $tmpFrameOpt"

    # calculate width of label and value fields
    set labelWidth [expr [FindMaxLabelLength $mappings] + 5]
    set valueWidth [expr [FindMaxValueLength $mappings] + 5]
    if {$valueWidth < 30} {
	set valueWidth 30
    }

    # create the name widget
    set nameMsgWidget ""
    set nameEntryWidget ""
    if { $getName } {
	set nameMsgWidget $w.mapping.label.mapNameMsg
	set nameEntryWidget $w.mapping.value.mapNameEntry
	label $nameMsgWidget -text Name -width $labelWidth
	entry $nameEntryWidget -relief sunken -width $valueWidth
	set item0 [lindex $mappings 0]
	set item1 [lindex $mappings 1]
	set initName [UniqueName [format {%s_vs_%s} \
		[lindex $item1 2] [lindex $item0 2]]]
	$nameEntryWidget insert 0 $initName
    }

    set xname [lindex [lindex $mappings 0] 0]
    set xval mappingValue$xname
    set yname [lindex [lindex $mappings 1] 0]
    set yval mappingValue$yname

    foreach item $mappings {
	set itemname [lindex $item 0]
	set itemval [lindex $item 2]
	global mappingValue$itemname
	set mappingValue$itemname $itemval
	label $w.mapping.label.p$itemname -text $itemname \
		-width $labelWidth
	catch "$w.mapping.label.p$itemname config $tmpButtonOpt"

	menubutton $w.mapping.value.p$itemname -relief raised \
		-textvariable mappingValue$itemname \
		-menu $w.mapping.value.p$itemname.menu \
		-width $valueWidth
	catch "$w.mapping.value.p$itemname config $tmpButtonOpt"
	menu $w.mapping.value.p$itemname.menu -tearoff 0
	$w.mapping.value.p$itemname.menu add cascade -label Constant \
		-menu $w.mapping.value.p$itemname.menu.constant
	$w.mapping.value.p$itemname.menu add cascade -label Variable \
		-menu $w.mapping.value.p$itemname.menu.variable
	$w.mapping.value.p$itemname.menu add command -label "Expression..." \
		-command "editExpression $itemname"

	menu $w.mapping.value.p$itemname.menu.constant -tearoff 0
	foreach val [lindex $item 1] {
	    set value [lindex $val 0]
	    if {[llength $val] > 1} {
		set value [lindex $val 1]
	    }
	    if {$getName} {
		$w.mapping.value.p$itemname.menu.constant add radiobutton \
			-label $value -variable mappingValue$itemname \
			-value $value \
			-command "updateMapName $nameEntryWidget $xval $yval"
	    } else {
		$w.mapping.value.p$itemname.menu.constant add radiobutton \
			-label $value -variable mappingValue$itemname \
			-value $value
	    }
	}

	menu $w.mapping.value.p$itemname.menu.variable -tearoff 0
	foreach val $attrlist {
	    if {$getName} {
		$w.mapping.value.p$itemname.menu.variable add radiobutton \
			-label $val -variable mappingValue$itemname \
			-value \$$val \
			-command "updateMapName $nameEntryWidget $xval $yval"
	    } else {
		$w.mapping.value.p$itemname.menu.variable add radiobutton \
			-label $val -variable mappingValue$itemname \
			-value \$$val
	    }
	}

	tk_menuBar $w.mapping.value $w.mapping.value.p$itemname
    }

    #########################################################################
    # handle decision: ok cancel in a sub widget
    #########################################################################
    frame $w.decision
    catch "$w.decision config $tmpFrameOpt"

    # Ok: return new mapping
    button $w.decision.ok -text OK -width 10 -command { set button1 1 }
    catch "$w.decision.ok config $tmpButtonOpt"

    # Cancel: return old mapping
    button $w.decision.cancel -text Cancel -width 10 -command { set button1 0 }
    catch "$w.decision.cancel config $tmpButtonOpt"

    #########################################################################
    # packings
    #########################################################################

    pack $w.decision.ok $w.decision.cancel -side left -padx 3m

    foreach item $mappings {
	set itemname [lindex $item 0]
	pack $w.mapping.label.p$itemname -side top -fill x -pady 0.7m
	pack $w.mapping.value.p$itemname -side top -fill x
    }

    # Pack the mapping name widget
    if { $getName } {
	pack $nameMsgWidget -in $w.mapping.label -side top -fill x -pady 0.7m
	pack $nameEntryWidget -in $w.mapping.value -side top -fill x
    }

    pack $w.mapping.label -side left -fill x
    pack $w.mapping.value -side right -fill x

    pack $w.message $w.mapping -side top -fill x -pady 2m
    pack $w.decision -side top -pady 3m

    #########################################################################

    tkwait variable button1
    set newmap ""
    if { $button1 == 1 } {
	foreach item $mappings {
	    set itemname [lindex $item 0]
	    lappend newmap [deref mappingValue$itemname]
	}
	if {$getName } {
	    set newmap [list [$nameEntryWidget get] $newmap]
	}
    }
 
    catch {destroy $w}

    return $newmap
}

proc editExpression {varname} {
    global mappingValue$varname edit$varname

    set winname ".edit$varname"
    set edit$varname [deref mappingValue$varname]

    # see if $winname window already exists; if so, just return
    set err [catch {wm state $winname}]
    if {!$err} { wm deiconify $winname; return }

    toplevel $winname
    wm title $winname "Edit Expression"
    wm geometry $winname +150+150
    selection clear $winname

    frame $winname.top -relief groove -borderwidth 2
    frame $winname.bot
    pack $winname.top -side top -pady 5m -fill both -expand 1
    pack $winname.bot -side top -pady 5m -fill x
    frame $winname.bot.but
    pack $winname.bot.but -side top

    label $winname.top.label -text "Enter expression for $varname"
    pack $winname.top.label -side top -pady 5m

    entry $winname.top.e1 -relief sunken -textvariable edit$varname -width 30
    pack $winname.top.e1 -side left -padx 2m -pady 5m -fill x -expand 1

    button $winname.bot.but.ok -text OK -width 10 -command \
	    "SetExpression mappingValue$varname edit$varname $winname"
    button $winname.bot.but.clear -text Clear -width 10 -command \
	    "set edit$varname {}"
    button $winname.bot.but.cancel -text Cancel -width 10 -command \
	    "destroy $winname"
    pack $winname.bot.but.ok $winname.bot.but.clear \
	    $winname.bot.but.cancel -side left -padx 5m

    tkwait visibility $winname
    grab set $winname
    tkwait window $winname
}

proc SetExpression {mapvar editvar winname} {
    global $mapvar $editvar
    set $mapvar [deref $editvar]
    destroy $winname
}

proc deref {var} {
    upvar $var vderef
    return $vderef
}

proc updateMapName {w xval yval} {
    upvar $xval x
    upvar $yval y
    set name [UniqueName [format "%s_vs_%s" $y $x]]
    $w delete 0 end
    $w insert 0 $name
}
