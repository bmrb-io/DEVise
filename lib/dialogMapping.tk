#  ========================================================================
#  DEVise Data Visualization Software
#  (c) Copyright 1992-1996
#  By the DEVise Development Group
#  Madison, Wisconsin
#  All Rights Reserved.
#  ========================================================================
#
#  Under no circumstances is this software to be copied, distributed,
#  or altered in any way without prior permission from the DEVise
#  Development Group.

############################################################

#	$Id$	

#	$Log$
#	Revision 1.8  1996/01/23 20:52:30  jussi
#	Added support for hierarchical schemas.
#
#	Revision 1.7  1996/01/09 16:39:53  jussi
#	Added support for Tcl expressions as mappings.
#
#	Revision 1.6  1995/11/21 23:38:20  jussi
#	The user can now select either constant values for a mapping
#	attribute, or a field from TData schema.
#
#	Revision 1.5  1995/09/22 17:33:40  jussi
#	Added copyright message.
#
#	Revision 1.4  1995/09/05 22:47:59  jussi
#	Added/updated CVS header.
#
#	Revision 1.3  1995/09/05 22:43:50  jussi
#	Updated CVS header.

############################################################

proc dialogMapping {w title text bitmap schemaname mappings {getName 0}} { 
    global button1

    set topgrp [SelectTopGroup $schemaname]

    # destroy the old widget with the same name if there exists one
    catch {destroy $w}

    toplevel $w
    wm geometry $w +50+50
    wm title $w $title

    label $w.message -text $text

    frame $w.mapping
    frame $w.mapping.label
    frame $w.mapping.value

    set labelWidth 20
    set valueWidth 30

    set nameMsgWidget ""
    set nameEntryWidget ""
    if { $getName } {
	set nameMsgWidget $w.mapping.label.mapNameMsg
	set nameEntryWidget $w.mapping.value.mapNameEntry
	label $nameMsgWidget -text Name -width $labelWidth
	entry $nameEntryWidget -relief sunken -width $valueWidth
	set item0 [lindex $mappings 0]
	set item1 [lindex $mappings 1]
	set initName [UniqueName [format {%s_vs_%s} \
		[lindex $item1 2] [lindex $item0 2]]]
	$nameEntryWidget insert 0 $initName
    }

    set xname [lindex [lindex $mappings 0] 0]
    set xval mappingValue$xname
    set yname [lindex [lindex $mappings 1] 0]
    set yval mappingValue$yname

    foreach item $mappings {
	set itemname [lindex $item 0]
	set itemlist [lindex $item 1]
	set itemval [lindex $item 2]

	global mappingValue$itemname
	set mappingValue$itemname $itemval

	label $w.mapping.label.p$itemname -text $itemname -width $labelWidth

	menubutton $w.mapping.value.p$itemname -relief raised \
		-textvariable mappingValue$itemname \
		-menu $w.mapping.value.p$itemname.menu \
		-width $valueWidth
	menu $w.mapping.value.p$itemname.menu -tearoff 0
	tk_menuBar $w.mapping.value $w.mapping.value.p$itemname

	if {$itemname == "Color"} {
	    $w.mapping.value.p$itemname.menu add command -label "Constant..." \
		    -command "getColor mappingValue$itemname"
	} else {
	    $w.mapping.value.p$itemname.menu add cascade -label Constant \
		    -menu $w.mapping.value.p$itemname.menu.constant
	}
	$w.mapping.value.p$itemname.menu add cascade -label Variable \
		-menu $w.mapping.value.p$itemname.menu.variable
	$w.mapping.value.p$itemname.menu add command -label "Expression..." \
		-command "editExpression $itemname"

	setupAttrRadioMenu $w.mapping.value.p$itemname.menu.variable \
		mappingValue$itemname "\$" $schemaname $topgrp $topgrp
	if {$getName} {
	    $w.mapping.value.p$itemname.menu.variable configure \
		    -command "updateMapName $nameEntryWidget $xval $yval"
	}

	if {$itemname == "Color"} {
	    continue
	}

	menu $w.mapping.value.p$itemname.menu.constant -tearoff 0
	foreach val $itemlist {
	    set value [lindex $val 0]
	    if {[llength $val] > 1} {
		set value [lindex $val 1]
	    }
	    $w.mapping.value.p$itemname.menu.constant add radiobutton \
		    -label $value -variable mappingValue$itemname \
		    -value $value
	    if {$getName} {
		$w.mapping.value.p$itemname.menu.constant configure \
			-command "updateMapName $nameEntryWidget $xval $yval"
	    }
	}
    }

    frame $w.but
    button $w.but.ok -text OK -width 10 -command { set button1 1 }
    button $w.but.cancel -text Cancel -width 10 -command { set button1 0 }
    pack $w.but.ok $w.but.cancel -side left -padx 3m

    foreach item $mappings {
	set itemname [lindex $item 0]
	pack $w.mapping.label.p$itemname -side top -fill x -pady 0.7m
	pack $w.mapping.value.p$itemname -side top -fill x
    }

    if { $getName } {
	pack $nameMsgWidget -in $w.mapping.label -side top -fill x -pady 0.7m
	pack $nameEntryWidget -in $w.mapping.value -side top -fill x
    }

    pack $w.mapping.label -side left -fill x
    pack $w.mapping.value -side right -fill x

    pack $w.message $w.mapping -side top -fill x -pady 2m
    pack $w.but -side top -pady 3m

    tkwait variable button1

    set newmap ""
    if { $button1 == 1 } {
	foreach item $mappings {
	    set itemname [lindex $item 0]
	    lappend newmap [deref mappingValue$itemname]
	}
	if {$getName } {
	    set newmap [list [$nameEntryWidget get] $newmap]
	}
    }
 
    catch {destroy $w}

    return $newmap
}

proc editExpression {varname} {
    global mappingValue$varname edit$varname

    set winname ".edit$varname"
    set edit$varname [deref mappingValue$varname]

    # see if $winname window already exists; if so, just return
    set err [catch {wm state $winname}]
    if {!$err} { wm deiconify $winname; return }

    toplevel $winname
    wm title $winname "Edit Expression"
    wm geometry $winname +150+150
    selection clear $winname

    frame $winname.top -relief groove -borderwidth 2
    frame $winname.bot
    pack $winname.top -side top -pady 5m -fill both -expand 1
    pack $winname.bot -side top -pady 5m -fill x
    frame $winname.bot.but
    pack $winname.bot.but -side top

    label $winname.top.label -text "Enter expression for $varname"
    pack $winname.top.label -side top -pady 5m

    entry $winname.top.e1 -relief sunken -textvariable edit$varname -width 30
    pack $winname.top.e1 -side left -padx 2m -pady 5m -fill x -expand 1

    button $winname.bot.but.ok -text OK -width 10 -command \
	    "SetExpression mappingValue$varname edit$varname $winname"
    button $winname.bot.but.clear -text Clear -width 10 -command \
	    "set edit$varname {}"
    button $winname.bot.but.cancel -text Cancel -width 10 -command \
	    "destroy $winname"
    pack $winname.bot.but.ok $winname.bot.but.clear \
	    $winname.bot.but.cancel -side left -padx 5m

    tkwait visibility $winname
    grab set $winname
    tkwait window $winname
}

proc SetExpression {mapvar editvar winname} {
    global $mapvar $editvar
    set $mapvar [deref $editvar]
    destroy $winname
}

proc deref {var} {
    upvar $var vderef
    return $vderef
}

proc updateMapName {w xval yval} {
    upvar $xval x
    upvar $yval y
    set name [UniqueName [format "%s_vs_%s" $y $x]]
    $w delete 0 end
    $w insert 0 $name
}
