#  ========================================================================
#  DEVise Data Visualization Software
#  (c) Copyright 1992-1997
#  By the DEVise Development Group
#  Madison, Wisconsin
#  All Rights Reserved.
#  ========================================================================
#
#  Under no circumstances is this software to be copied, distributed,
#  or altered in any way without prior permission from the DEVise
#  Development Group.

############################################################

#       $Id$

#       $Log$
#       Revision 1.31  1997/06/13 18:01:25  wenger
#       Added 'Clear' option to mapping dialog menus.
#
#       Revision 1.30  1997/05/28 15:39:51  wenger
#       Merged Shilpa's layout manager code through the layout_mgr_branch_2 tag.
#
#       Revision 1.29.4.1  1997/05/20 16:11:26  ssl
#       Added layout manager to DEVise
#
#       Revision 1.29  1997/04/30 18:27:23  wenger
#       Added session text description capability.
#
#       Revision 1.28  1997/04/29 17:35:29  wenger
#       Minor fixes to new text labels; added fixed text label shape;
#       CheckDirSpace() no longer prints an error message if it can't get disk
#       status.
#
#       Revision 1.27  1997/04/25 16:54:16  wenger
#       Text labels are now sized in the same way as Rects; fixed font bug in
#       middle button query popup; removed the dialog that warns you about your
#       table name getting changed when you open an old data source.
#
#       Revision 1.26  1997/04/21 23:03:54  guangshu
#       Changes to deal with more statistics cases.
#
#       Revision 1.25  1997/04/18 20:47:30  donjerko
#       Removed tdata name chopping.
#
#       Revision 1.24  1997/04/16 18:53:47  wenger
#       Text labels can now show non-string attributes; fixed a bug in constant
#       strings in mapping (non-terminated string); added constant attributes to
#       GData attribute list; commented out some debug code in mapping dialog.
#
#       Revision 1.23  1997/04/11 18:49:30  wenger
#       Added dashed line support to the cslib versions of WindowReps; added
#       option to not maintain aspect ratio in Tasvir images; re-added shape
#       help file that somehow didn't get added in 1.3 merges; removed code
#       for displaying GIFs locally (including some of the xv code).
#
#       Revision 1.22  1997/03/23 23:46:26  donjerko
#       *** empty log message ***
#
#       Revision 1.21  1997/03/20 22:59:48  guangshu
#       Reorganized the code in UpdateMappingDialog a little bit.
#
#       Revision 1.20  1997/03/20 20:46:02  donjerko
#       DTE Tdata generates unique names by appending sequential numbers to the
#       end of the table name. This way, same table can be opened multiple times.
#
#       Revision 1.19  1997/03/20 01:32:18  wenger
#       Fixed a bug in color allocation; color chooser for data shows old colors
#       (temporarily); background conversion of GData defaults to off.
#
#       Revision 1.18  1997/02/26 16:32:04  wenger
#       Merged rel_1_3_1 through rel_1_3_3c changes; compiled on Intel/Solaris.
#
#       Revision 1.17  1997/02/25 22:16:53  donjerko
#       Fixed some bugs in tcl - dte communication
#
#       Revision 1.16  1997/02/14 16:48:02  wenger
#       Merged 1.3 branch thru rel_1_3_1 tag back into the main CVS trunk.
#
#       Revision 1.15.4.14  1997/02/21 15:18:14  wenger
#       Minor improvement to shape attribute names.
#
#       Revision 1.15.4.13  1997/02/20 20:50:55  wenger
#       Changed mapping to use ShapeAttr4 for line width.
#
#       Revision 1.15.4.12  1997/02/20 18:33:55  wenger
#       Committed Shilpa's fix to flashing problem when viewer selects
#       different views.
#
#       Revision 1.15.4.11  1997/02/19 23:29:59  wenger
#       More bug fixes to shape attribute menus...
#
#       Revision 1.15.4.10  1997/02/19 23:01:25  wenger
#       A few minor changes in the shape menu stuff to make the GUI more consistent
#       with the rest of Devise; added some more info to the shape help;
#       shape menu doesn't disable shape attributes (extra ones sometimes needed
#       for 3D, etc.); fixed a bug in how Cancel works in the Color Chooser;
#       various bug fixes in shape attribute menus.
#
#       Revision 1.15.4.9  1997/02/19 19:44:57  weaver
#       Added "Shape Help" button to display ShapeHelp.txt. Adjusted
#       context-sensitive ShapeAttr menus to change for constant
#       shapes only.
#
#       Revision 1.15.4.8  1997/02/18 20:57:27  weaver
#       Added shape-context-sensitive shapeattr menu titles to the mapping dialog.
#
#       Revision 1.15.4.7  1997/02/11 23:16:50  weaver
#       Removed shape justification pending release...
#
#       Revision 1.15.4.6  1997/02/11 02:08:15  weaver
#       Added shape position control.
#
#       Revision 1.15.4.5  1997/02/10 23:54:24  wenger
#       Moved view and window Destroy selections to the bottoms of the menus;
#       added a direct means to create a new window; minor improvements to
#       mapping dialog.
#
#       Revision 1.15.4.4  1997/02/10 19:10:37  ssl
#       Fixed mapping dialog to do the apply immediately for piled views
#
#       Revision 1.15.4.3  1997/02/10 16:13:38  ssl
#       Fixed minor typos.
#
#       Revision 1.15.4.2  1997/02/09 16:45:28  wenger
#       Added standard source file header.
#

############################################################

#SSL - new mapping box implementation
# Do editing for mapping

# CEW - added for simplistic shape positioning control
# List items are {descriptionInMappingMenu offsetInXUnits offsetInYUnits}
# For now, offset unit = 1/2 the size of the shape drawn in each dimension
#set DEViseShapePositions {{center 0 0} {NW -1 1} {N 0 1} {NE 1 1} {E 1 0} \
#		{SE 1 -1} {S 0 -1} {SW -1 -1} {W -1 0}}

proc DoEditMapping {} {
    global curView

    if {![CurrentView]} {
	return
    }

#TEMPTEMP -- check for compiled mapping here
    
    if {[WindowVisible .editMapping]}  {
	return
    }

    # Bring up the mapping dialog and initialize for the current View

    BringUpMappingDialog  .editMapping $curView
    UpdateMappingDialog .editMapping $curView
}

proc BringUpMappingDialog { w curview } {
    global dialogParamVar dialogListVar DEViseOldColors DEViseShapes
	global mappingValueShape
#	global DEViseShapePositions
    
    toplevel $w
    wm geometry $w +50+50
    wm title $w "Edit Mapping"
    frame $w.message
    label $w.message.txt
    
#currently only enabled for piled views
    button $w.message.flip -text Flip -state disabled \
	    -command { FlipStackedView }
    
    frame $w.mapping
    frame $w.mapping.label
    frame $w.mapping.value
    
    set labelWidth 20
    set valueWidth 30
    
    set mappings [list \
	    [list X {0 1 2 3 4 5 6 7 8 9 10} ] \
	    [list Y {0 1 2 3 4 5 6 7 8 9 10} ] \
	    [list Z {0 1 2 3 4 5 6 7 8 9 10} ] \
	    [list Color $DEViseOldColors ] \
	    [list Size {0 1 2 3 4} ] \
	    [list Pattern {0 1 2 3 4 5 6 7 8 9 10}] \
	    [list Orientation {0 90 180 270} ] \
	    [list Shape $DEViseShapes ] \
	    [list "ShapeAttr0" {0 0.1 0.5 1 2}] \
	    [list "ShapeAttr1" {0 0.1 0.5 1 2}] \
	    [list "ShapeAttr2" {0 0.1 0.5 1 2}] \
	    [list "ShapeAttr3" {0 0.1 0.5 1 2}] \
	    [list "ShapeAttr4" {0 0.1 0.5 1 2}]]
#	    [list "ShapePosition" $DEViseShapePositions]

    set xname  [lindex [lindex $mappings 0] 0]
    set xval mappingValue$xname
    set yname  [lindex [lindex $mappings 1] 0]
    set yval mappingValue$yname

    foreach item $mappings {
		set itemname [lindex $item 0]
		set itemList [lindex $item 1]
		set itemVal ""
	
		global mappingValue$itemname
		set mappingValue$itemname $itemVal
	
		label $w.mapping.label.p$itemname -text $itemname -width $labelWidth
	
		menubutton $w.mapping.value.p$itemname -relief raised \
			-textvariable mappingValue$itemname \
			-menu $w.mapping.value.p$itemname.menu \
			-width $valueWidth

		menu $w.mapping.value.p$itemname.menu -tearoff 0
		tk_menuBar $w.mapping.value $w.mapping.value.p$itemname 

		# Build the shape positioning menu
#		if {$itemname == "ShapePosition"} {
#			foreach val $itemList {
#				set value [lindex $val 0]
#				$w.mapping.value.p$itemname.menu add radiobutton \
#					-label $value -variable mappingValue$itemname \
#					-value $value
#			}
#
#			continue
#		}

		if {$itemname == "Color"} {
			$w.mapping.value.p$itemname.menu add command -label "Constant..." \
				-command "getColor mappingValue$itemname true"
		} else {
			$w.mapping.value.p$itemname.menu add cascade -label "Constant" \
				-menu $w.mapping.value.p$itemname.menu.constant
		}

		if {$itemname == "Shape"} {
			$w.mapping.value.p$itemname.menu add cascade -label Variable \
				-menu $w.mapping.value.p$itemname.menu.variable
			$w.mapping.value.p$itemname.menu add command \
				-label "Expression..." \
				-command " editExpression $itemname
			               UpdateShapeAttrs $w {} "
			$w.mapping.value.p$itemname.menu add command \
				-label "Clear" \
				-command "set mappingValue$itemname {}"
		} else {
			$w.mapping.value.p$itemname.menu add cascade -label Variable \
				-menu $w.mapping.value.p$itemname.menu.variable
			$w.mapping.value.p$itemname.menu add command \
				-label "Expression..." \
				-command " editExpression $itemname"
			$w.mapping.value.p$itemname.menu add command \
				-label "Clear" \
				-command "set mappingValue$itemname {}"
		}

		if {$itemname == "Color"} {
			continue
		}

		menu $w.mapping.value.p$itemname.menu.constant -tearoff 0

		foreach val $itemList {
			set value [lindex $val 0]
			if { [llength $val] > 1 } {
				set value [lindex $val 1]
			}

			if {$itemname == "Shape"} {
				$w.mapping.value.p$itemname.menu.constant add radiobutton \
					-label $value -variable mappingValue$itemname \
					-value $value \
					-command " UpdateShapeAttrs {$w} {$value} "
			} else {
			    $w.mapping.value.p$itemname.menu.constant add radiobutton \
				    -label $value -variable mappingValue$itemname \
				    -value $value
			}
		}
    }
    
    frame $w.but
    
    button $w.but.apply -text Apply -width 8
    button $w.but.shapeHelp -text "Shape Help" -width 12 \
			-command { DoShapeHelp }
    button $w.but.cancel -text Close -width 8 -command " \
            destroy $w 
            return "
    pack $w.but.apply $w.but.shapeHelp $w.but.cancel -side left -padx 3m
    
    foreach item $mappings {
		set itemname [lindex $item 0]
		pack $w.mapping.label.p$itemname -side top -fill x -pady 0.7m
		pack $w.mapping.value.p$itemname -side top -fill x
    }

    pack $w.mapping.label -side left -fill x
    pack $w.mapping.value -side right -fill x
    
    pack $w.message.txt $w.message.flip -side left -expand 1 -pady 0.7m
    pack $w.message $w.mapping -side top -fill x -pady 2m
    pack $w.but -side top -pady 3m
    
 }

proc UpdateMappingDialog { w curView } {
     global DEViseOldColors DEViseShapes

     if {! [winfo exists $w] } {
	 return
     }
     if { $curView == "" } {
	 ClearMappingDialog $w
     } 	 
     if {[DEVise getViewPileMode $curView]} {
	 set win [DEVise getViewWin $curView]
	 set curView [lindex [DEVise getWinViews $win] end]
	 $w.message.flip configure -state normal
     } else {
	 $w.message.flip configure -state disabled
     }
     
     $w.message.txt configure -text "Edit Mapping for : $curView"
     
     # Get mapping for the view (first one)
     set map [lindex [DEVise getViewMappings $curView] 0]
     #See if map is interpreted
     set found 0
     foreach m [InterpretedGData] {
	 if {$m == $map} {
	     set found 1
	     break
	 }
     }
     if {!$found} {
	 dialog .editError "Mapping Not Interpreted" \
		 "View has a compiled mapping which cannot be edited." "" 0 OK
	     ClearMappingDialog $w
	 return
     }
     global sourceList derivedSourceList
     # Get parameters for the mapping
     set params [DEVise getInstParam $map]
     
     if {$params == ""} {
	 dialog .editError "No Mapping Parameters" \
		 "Mapping has no parameters." "" 0 OK
	 ClearMappingDialog $w
	 return
     }
     
     #     puts "params ========== $params"
     set tdata [lindex [lindex $params 0] 1]
     set schemaname ""
     set error [catch {set sfname [lindex $derivedSourceList($tdata) 3]}]
     
     if {$error > 0} {
	 
	 #	set nextToLast [string length $tdata]
	 #	set nextToLast [expr $nextToLast - 2]
	 #	set tdata [string range $tdata 0 $nextToLast]
	 
	 set sourcedef [DEVise dteShowCatalogEntry $tdata]
	 # 	puts "hack: ********** tdata: $tdata  sourcedef: $sourcedef"
	 set sourcedef [lindex $sourcedef 0]
	 
	 set err [expr [llength $sourcedef] == 0]
	 
	 if {$err == 0} {
	     # file exists
	     set stype [lindex $sourcedef 1]
	     if {[isDTEType $stype]} {
		 set schemaname $tdata
	     } else { 
		 set sfname [lindex $sourcedef 4]
		 set schemaname [file tail $sfname]
	     }
	 } 
     }
     set pos [string first : $tdata]
     set categ ""
     if {$pos > 0} {
	 set categ [string range $tdata 0 [expr $pos - 1]]
     } else {
	 set categ $tdata
     }
     set stat 0
     if { $categ == "Hist" || $categ == "HistDate" || $categ == "Stat" || \
	     $categ == "GstatX" || $categ == "GstatXDTE" || $categ == "GstatXDate"|| \
	     $categ == "GstatY" || $categ == "GstatYDate" } {
	 set stat 1
     }
     if {$schemaname == "" && $stat == 1} {
	 set schemaname [file tail $sfname]
     }
     
     #     puts "schemaname = $schemaname"
     set xParm [lindex [lindex $params 3] 1]
     set yParm [lindex [lindex $params 4] 1]
     set zParm [lindex [lindex $params 5] 1]
     set colorParm [findNameValue $DEViseOldColors [lindex [lindex $params 6] 1]]
     set sizeParm [lindex [lindex $params 7] 1]
     set patternParm [lindex [lindex $params 8] 1]
     set orientParm [lindex [lindex $params 9] 1]
     set shapeParm [findNameValue $DEViseShapes [lindex [lindex $params 10] 1]]
     set shapeAttr0 [lindex [lindex $params 11] 1]
     set shapeAttr1 [lindex [lindex $params 12] 1]
     set shapeAttr2 [lindex [lindex $params 13] 1]
     set shapeAttr3 [lindex [lindex $params 14] 1]
     set shapeAttr4 [lindex [lindex $params 15] 1]
#	 set shapePosition [lindex [lindex $params 15] 1]

     set mappings [list \
	     [list X $xParm] \
	     [list Y $yParm] \
	     [list Z $zParm] \
	     [list Color $colorParm] \
	     [list Size $sizeParm] \
	     [list Pattern $patternParm] \
	     [list Orientation $orientParm] \
	     [list Shape $shapeParm ] \
	     [list "ShapeAttr0" $shapeAttr0] \
	     [list "ShapeAttr1" $shapeAttr1] \
	     [list "ShapeAttr2" $shapeAttr2] \
	     [list "ShapeAttr3" $shapeAttr3] \
	     [list "ShapeAttr4" $shapeAttr4]]
#		 [list "ShapePosition" $shapePosition]
     
#    set topgrp [SelectTopGroup $schemaname]

#	it cannot find the top group for some reason???
#	but it should be there!	 DD

	set topgrp __default

#     $w.mapping.value.p$itemname configure -state normal

     foreach item $mappings {
	 set itemname [lindex $item 0]
	 set itemval [lindex $item 1]
	 
#		 if {$itemname == "ShapePosition"} {
#			 continue
#		 }

	 global mappingValue$itemname
	 catch { destroy $w.mapping.value.p$itemname.menu.variable }

	 setupAttrRadioMenu $w.mapping.value.p$itemname.menu.variable \
		 mappingValue$itemname "\$" $schemaname $topgrp $topgrp
	 set mappingValue$itemname $itemval
     }
     $w.but.apply configure -command \
	     " UpdateMappings {$map} {$params} {$mappings} "

	 UpdateShapeAttrs $w $shapeParm
}


proc ClearMappingDialog { w } {
    if {! [WindowVisible $w ] } {
	return
    }
    set mappings [list X Y Z Color Size Pattern Orientation Shape \
	    "ShapeAttr0" "ShapeAttr1" ShapeAttr2" "ShapeAttr3" "ShapeAttr4" \ # "ShapePosition" \
    ]
    foreach item $mappings  {
	global mappingValue$item
	set mappingValue$item ""
	$w.mapping.value.p$item configure -state disabled
    }
}


proc editExpression {varname} {
    global mappingValue$varname edit$varname

    set winname ".edit$varname"
    set edit$varname [deref mappingValue$varname]

    if {[WindowVisible $winname]} {
	return
    }

    toplevel $winname
    wm title $winname "Edit Expression"
    wm geometry $winname +150+150
    selection clear $winname

    frame $winname.top -relief groove -borderwidth 2
    frame $winname.bot
    pack $winname.top -side top -pady 5m -fill both -expand 1
    pack $winname.bot -side top -pady 5m -fill x
    frame $winname.bot.but
    pack $winname.bot.but -side top

    label $winname.top.label -text "Enter expression for $varname"
    pack $winname.top.label -side top -pady 5m

    entry $winname.top.e1 -relief sunken -textvariable edit$varname -width 30
    pack $winname.top.e1 -side left -padx 2m -pady 5m -fill x -expand 1

    button $winname.bot.but.ok -text OK -width 8 -command \
	    "SetExpression mappingValue$varname edit$varname $winname"
#    button $winname.bot.but.apply -text Apply -width 8 -command \
#	    "SetExpression mappingValue$varname edit$varname $winname; \
#	    UpdateMappings {$map} {$params} {$mappings}"
    button $winname.bot.but.clear -text Clear -width 8 -command \
	    "set edit$varname {}"
    button $winname.bot.but.cancel -text Cancel -width 8 -command \
	    "destroy $winname"
    pack $winname.bot.but.ok $winname.bot.but.clear \
	    $winname.bot.but.cancel -side left -padx 3m
#    pack $winname.bot.but.ok $winname.bot.but.apply \
#	    $winname.bot.but.clear \
#	    $winname.bot.but.cancel -side left -padx 3m
    tkwait visibility $winname
    grab set $winname
    tkwait window $winname
}


proc SetExpression {mapvar editvar winname} {
    global $mapvar $editvar
    set $mapvar [deref $editvar]
    destroy $winname
}

proc deref {var} {
    upvar $var vderef
    return $vderef
}

proc updateMapName {w xval yval} {
    upvar $xval x
    upvar $yval y
    set name [UniqueName [format "%s_vs_%s" $y $x]]
    $w delete 0 end
    $w insert 0 $name
}

proc ChangeParams { map oldparams newmap } {
    global dialogParamVar dialogListVar DEViseOldColors DEViseShapes 

    if { $newmap == ""} {
	return
    }

    # extract parameters
    set newparams [list [lindex [lindex $oldparams 0] 1] \
	    [lindex [lindex $oldparams 1] 1] \
	    [lindex [lindex $oldparams 2] 1] \
	    [lindex $newmap 0] \
	    [lindex $newmap 1] \
	    [lindex $newmap 2] \
	    [findNumericValue $DEViseOldColors [lindex $newmap 3]] \
	    [lindex $newmap 4] \
	    [lindex $newmap 5] \
	    [lindex $newmap 6] \
	    [findNumericValue $DEViseShapes [lindex $newmap 7]] \
	    [lindex $newmap 8] [lindex $newmap 9] \
	    [lindex $newmap 10] [lindex $newmap 11] \
	    [lindex $newmap 12] \
	    ]
    
    # Change parameter
    set cmd "DEVise changeParam \{$map\} $newparams"
    eval $cmd
    return
}


proc ChangeViewMapping { map } {
    # Refresh all views that use this mapping
    set views [ViewSet]
    foreach view $views {
	set mappings [DEVise getViewMappings $view]
	set contains 0
	foreach m $mappings {
	    if {$m == $map} {
		set contains 1
		break
	    }
	}
	if {$contains > 0} {
	    if {[DEVise getViewPileMode $view]} {
		set win [DEVise getViewWin $view]
		set view [lindex [DEVise getWinViews $win] 0]
	    }
	    DEVise invalidatePixmap $view
	    DEVise refreshView $view
	}
    }
    return
}


proc UpdateMappings { map params mappings } {
    set newmap ""
    foreach item $mappings {
	set itemname [lindex $item 0]
	global mappingValue$itemname
	lappend newmap [deref mappingValue$itemname]
    }
    #puts $newmap
    ChangeParams $map $params $newmap
    ChangeViewMapping $map

    return
}

#*******************************************************************************
# Shape Attributes
#*******************************************************************************

# Changed labels for ShapeAttr# labels in mapping dialog to labels specific to
# each shape and attr# (e.g. Rect Attr1 => Width)
###############Added a new shape : View 
set DEViseShapeAttrNames { \
	{Rect Width Height "Cloud Width" "Cloud Height" "Line Width"} \
	{RectX "Relative Width" "Relative Height" "" "" "Line Width"} \
	{Bar Width "" "" "" "Line Width"} \
	{Line "" "" "" "" "Line Width"} \
	{"Line Shade" "" "" "" "" ""} \
	{"Regular Polygon" Width Height Segments "" "Line Width"} \
	{Oval Width Height "" "" "Line Width"} \
	{Vector "X Length (Height)" "Y Length (Width)" "" "" "Line Width"} \
	{HorLine "" "" "" "" "Line Width"} \
	{Segment Width Height "" "" "Line Width"} \
	{HighLow Width "High (Y max)" "Low (Y min)" "" "Line Width"} \
	{Polyline "" "" "" "" ""} \
	{Image "Filename/Image" "Image Type" "Aspect" "" ""} \
	{"Polyline File" Filename Format "" "" "Line Width"} \
	{"Text Label" "Label Text" "Format" "Width" "Height" "Outline"} \
	{"Tcl/Tk Window" "Script File" "Arg Count" "Arg 0" "Arg 1" "Arg 2"} \
	{"View" "Name" Width Height } \
	{"Fixed Text Label" "Label Text" "Format" "" "" ""} \
}

# Adjusts the labels of the five ShapeAttr menu labels to descriptive terms
# (from DEViseShapeAttrNames) appropriate to the current Shape. (Could be done
# much more efficiently if I knew Tcl better...clean up.)
proc UpdateShapeAttrs { w shape } {
	global DEViseShapeAttrNames

	set i 0
	set j 1

	foreach shapeAttrList $DEViseShapeAttrNames {
		set foundShape [lindex $shapeAttrList 0]
		if { $foundShape == $shape } {
			break
		}
		incr i
	}

	# If the shape wan't found, use the default labels
	if { $i == [llength $DEViseShapeAttrNames] } {
		UpdateDefaultShapeAttrs $w
		return
	}

    foreach item {"ShapeAttr0" "ShapeAttr1" "ShapeAttr2" "ShapeAttr3" \
	  "ShapeAttr4"} {
		set text [lindex [lindex $DEViseShapeAttrNames $i] $j]

		# Change attr menu labels to reflect specific shape
		$w.mapping.label.p$item config -text $text

# Don't disable the attr menus -- there are special cases, like 3D, where
# we need access to ones that might be disabled otherwise.  I want to err
# on the side of not screwing things up and preventing the users from being
# able to do something they should be able to do.  RKW 2/19/97.
#		if { $text == "" } {
#			set state disabled
#		} else {
#			set state normal
#		}

#		# Disable irrelevant attr menus
#		$w.mapping.value.p$item config -state $state

		incr j
	}
}

# Adjusts the lables of the five ShapeAttr menu labels to default (not context-
# sensitive) for shapes which are determined by a variable or an expression.
proc UpdateDefaultShapeAttrs { w } {

    foreach item {"ShapeAttr0" "ShapeAttr1" "ShapeAttr2" "ShapeAttr3" \
	  "ShapeAttr4"} {
		$w.mapping.label.p$item config -text $item
		$w.mapping.value.p$item config -state normal
	}
}

#*******************************************************************************
# Shape Help
#*******************************************************************************

# Displays a simple text window with the contents of file ShapeHelp.txt
# (Needs error checking for the file operation...)
proc DoShapeHelp {} {
	global libdir

    if {[WindowVisible .shapeHelp]}  {
		return
    }

	set w .shapeHelp

	toplevel $w
    wm geometry $w +50+50
    wm title $w "Shape Help"

	frame $w.body
	frame $w.cntl

	# Read message text from help file
	set filename "$libdir/ShapeHelp.txt"
	set stream [open $filename]
	set text [read $stream]
	close $stream

	set t [text $w.body.text -width 60 -height 24 -relief groove \
		-wrap none -yscrollcommand "$w.body.scroll set"]

	$t insert 1.0 $text
	$t configure -state disabled

	scrollbar $w.body.scroll -command "$w.body.text yview"

    button $w.cntl.ok -text "OK" -width 8 \
		-command "destroy $w"

	pack $w.body $w.cntl -side top -fill both
	pack $w.body.scroll -side right -fill y
	pack $w.body.text -side left -fill both -expand true
	pack $w.cntl.ok -side right -fill x -expand 1
}

#*******************************************************************************
# Note: these procedures assume that BringUpMappingDialog is called with
# .editMapping as the top-level window name.

proc EnableMappingFlip {} {
    if {![WindowExists .editMapping]} {
      return
    }
    .editMapping.message.flip config -state normal
}

proc DisableMappingFlip {} {
    if {![WindowExists .editMapping]} {
      return
    }
    .editMapping.message.flip config -state disabled
}

#*******************************************************************************
