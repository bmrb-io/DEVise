#  ========================================================================
#  DEVise Data Visualization Software
#  (c) Copyright 1992-1996
#  By the DEVise Development Group
#  Madison, Wisconsin
#  All Rights Reserved.
#  ========================================================================
#
#  Under no circumstances is this software to be copied, distributed,
#  or altered in any way without prior permission from the DEVise
#  Development Group.

############################################################

#	$Id$	

#	$Log$
#	Revision 1.10  1996/04/10 03:05:33  jussi
#	Checking of whether a top-level window already exists is now
#	made via WindowVisible (utils.tcl).
#
#	Revision 1.9  1996/02/02 21:26:39  jussi
#	User is given a color palette to choose from rather than
#	a list of names of colors.
#
#	Revision 1.8  1996/01/23 20:52:30  jussi
#	Added support for hierarchical schemas.
#
#	Revision 1.7  1996/01/09 16:39:53  jussi
#	Added support for Tcl expressions as mappings.
#
#	Revision 1.6  1995/11/21 23:38:20  jussi
#	The user can now select either constant values for a mapping
#	attribute, or a field from TData schema.
#
#	Revision 1.5  1995/09/22 17:33:40  jussi
#	Added copyright message.
#
#	Revision 1.4  1995/09/05 22:47:59  jussi
#	Added/updated CVS header.
#
#	Revision 1.3  1995/09/05 22:43:50  jussi
#	Updated CVS header.

############################################################


proc dialogMapping {w title text bitmap schemaname params map {getName 0}} { 
    global dialogParamVar dialogListVar DEViseColors DEViseShapes 
    global button1 mappingWinOpened

    set xParm [lindex [lindex $params 3] 1]
    set yParm [lindex [lindex $params 4] 1]
    set zParm [lindex [lindex $params 5] 1]
    set colorParm [findNameValue $DEViseColors [lindex [lindex $params 6] 1]]
    set sizeParm [lindex [lindex $params 7] 1]
    set patternParm [lindex [lindex $params 8] 1]
    set orientParm [lindex [lindex $params 9] 1]
    set shapeParm [findNameValue $DEViseShapes [lindex [lindex $params 10] 1]]
    set shapeAttr0 [lindex [lindex $params 11] 1]
    set shapeAttr1 [lindex [lindex $params 12] 1]
    set shapeAttr2 [lindex [lindex $params 13] 1]
    set shapeAttr3 [lindex [lindex $params 14] 1]

    set mappings [list \
	    [list X {0 1 2 3 4 5 6 7 8 9 10} $xParm] \
	    [list Y {0 1 2 3 4 5 6 7 8 9 10} $yParm] \
	    [list Z {0 1 2 3 4 5 6 7 8 9 10} $zParm] \
	    [list Color $DEViseColors $colorParm] \
	    [list Size {0 1 2 3 4} $sizeParm] \
	    [list Pattern {0 1 2 3 4 5 6 7 8 9 10} $patternParm] \
	    [list Orientation {1} $orientParm] \
	    [list Shape $DEViseShapes $shapeParm] \
	    [list "ShapeAttr0" {0 0.1 0.5 1 2} $shapeAttr0] \
	    [list "ShapeAttr1" {0 0.1 0.5 1 2} $shapeAttr1] \
	    [list "ShapeAttr2" {0 0.1 0.5 1 2} $shapeAttr2] \
	    [list "ShapeAttr3" {0 0.1 0.5 1 2} $shapeAttr3] \
	    ]

    set topgrp [SelectTopGroup $schemaname]

    # destroy the old widget with the same name if there exists one
    #catch {destroy $w}
    
    toplevel $w
    wm geometry $w +50+50
    wm title $w $title

    label $w.message -text $text

    frame $w.mapping
    frame $w.mapping.label
    frame $w.mapping.value

    set labelWidth 20
    set valueWidth 30

    set nameMsgWidget ""
    set nameEntryWidget ""
    if { $getName } {
	set nameMsgWidget $w.mapping.label.mapNameMsg
	set nameEntryWidget $w.mapping.value.mapNameEntry
	label $nameMsgWidget -text Name -width $labelWidth
	entry $nameEntryWidget -relief sunken -width $valueWidth
	set item0 [lindex $mappings 0]
	set item1 [lindex $mappings 1]
	set initName [UniqueName [format {%s_vs_%s} \
		[lindex $item1 2] [lindex $item0 2]]]
	$nameEntryWidget insert 0 $initName
    }

    set xname [lindex [lindex $mappings 0] 0]
    set xval mappingValue$xname
    set yname [lindex [lindex $mappings 1] 0]
    set yval mappingValue$yname

    foreach item $mappings {
	set itemname [lindex $item 0]
	set itemlist [lindex $item 1]
	set itemval [lindex $item 2]

	global mappingValue$itemname
	set mappingValue$itemname $itemval

	label $w.mapping.label.p$itemname -text $itemname -width $labelWidth

	menubutton $w.mapping.value.p$itemname -relief raised \
		-textvariable mappingValue$itemname \
		-menu $w.mapping.value.p$itemname.menu \
		-width $valueWidth
	menu $w.mapping.value.p$itemname.menu -tearoff 0
	tk_menuBar $w.mapping.value $w.mapping.value.p$itemname

	if {$itemname == "Color"} {
	    $w.mapping.value.p$itemname.menu add command -label "Constant..." \
		    -command "getColor mappingValue$itemname"
	} else {
	    $w.mapping.value.p$itemname.menu add cascade -label Constant \
		    -menu $w.mapping.value.p$itemname.menu.constant
	}
	$w.mapping.value.p$itemname.menu add cascade -label Variable \
		-menu $w.mapping.value.p$itemname.menu.variable
	$w.mapping.value.p$itemname.menu add command -label "Expression..." \
		-command "editExpression $itemname"

	setupAttrRadioMenu $w.mapping.value.p$itemname.menu.variable \
		mappingValue$itemname "\$" $schemaname $topgrp $topgrp
	if {$getName} {
	    $w.mapping.value.p$itemname.menu.variable configure \
		    -command "updateMapName $nameEntryWidget $xval $yval"
	}

	if {$itemname == "Color"} {
	    continue
	}

	menu $w.mapping.value.p$itemname.menu.constant -tearoff 0
	foreach val $itemlist {
	    set value [lindex $val 0]
	    if {[llength $val] > 1} {
		set value [lindex $val 1]
	    }
	    $w.mapping.value.p$itemname.menu.constant add radiobutton \
		    -label $value -variable mappingValue$itemname \
		    -value $value
	    if {$getName} {
		$w.mapping.value.p$itemname.menu.constant configure \
			-command "updateMapName $nameEntryWidget $xval $yval"
	    }
	}
    }

    frame $w.but 

    button $w.but.apply -text Apply -width 10 -command " \
	    UpdateMappings {$map} {$params} {$mappings} "
    button $w.but.ok -text OK -width 10 -command " \
    	    set mappingWinOpened 0 
            destroy $w 
	    return "
    button $w.but.cancel -text Cancel -width 10 -command " \
	    set mappingWinOpened 0 
            destroy $w 
            return "
    pack $w.but.apply $w.but.ok $w.but.cancel -side left -padx 3m

    foreach item $mappings {
	set itemname [lindex $item 0]
	pack $w.mapping.label.p$itemname -side top -fill x -pady 0.7m
	pack $w.mapping.value.p$itemname -side top -fill x
    }

    if { $getName } {
	pack $nameMsgWidget -in $w.mapping.label -side top -fill x -pady 0.7m
	pack $nameEntryWidget -in $w.mapping.value -side top -fill x
    }

    pack $w.mapping.label -side left -fill x
    pack $w.mapping.value -side right -fill x

    pack $w.message $w.mapping -side top -fill x -pady 2m
    pack $w.but -side top -pady 3m
}

proc editExpression {varname} {
    global mappingValue$varname edit$varname

    set winname ".edit$varname"
    set edit$varname [deref mappingValue$varname]

    if {[WindowVisible $winname]} {
	return
    }

    toplevel $winname
    wm title $winname "Edit Expression"
    wm geometry $winname +150+150
    selection clear $winname

    frame $winname.top -relief groove -borderwidth 2
    frame $winname.bot
    pack $winname.top -side top -pady 5m -fill both -expand 1
    pack $winname.bot -side top -pady 5m -fill x
    frame $winname.bot.but
    pack $winname.bot.but -side top

    label $winname.top.label -text "Enter expression for $varname"
    pack $winname.top.label -side top -pady 5m

    entry $winname.top.e1 -relief sunken -textvariable edit$varname -width 30
    pack $winname.top.e1 -side left -padx 2m -pady 5m -fill x -expand 1

    button $winname.bot.but.ok -text OK -width 10 -command \
	    "SetExpression mappingValue$varname edit$varname $winname"
    button $winname.bot.but.clear -text Clear -width 10 -command \
	    "set edit$varname {}"
    button $winname.bot.but.cancel -text Cancel -width 10 -command \
	    "destroy $winname"
    pack $winname.bot.but.ok $winname.bot.but.clear \
	    $winname.bot.but.cancel -side left -padx 5m
    tkwait visibility $winname
    grab set $winname
    tkwait window $winname
}


proc SetExpression {mapvar editvar winname} {
    global $mapvar $editvar
    set $mapvar [deref $editvar]
    destroy $winname
}

proc deref {var} {
    upvar $var vderef
    return $vderef
}

proc updateMapName {w xval yval} {
    upvar $xval x
    upvar $yval y
    set name [UniqueName [format "%s_vs_%s" $y $x]]
    $w delete 0 end
    $w insert 0 $name
}

proc ChangeParams { map oldparams newmap } {
    global dialogParamVar dialogListVar DEViseColors DEViseShapes 

    if { $newmap == ""} {
	return
    }

    # extract parameters
    set newparams [list [lindex [lindex $oldparams 0] 1] \
	    [lindex [lindex $oldparams 1] 1] \
	    [lindex [lindex $oldparams 2] 1] \
	    [lindex $newmap 0] \
	    [lindex $newmap 1] \
	    [lindex $newmap 2] \
	    [findNumericValue $DEViseColors [lindex $newmap 3]] \
	    [lindex $newmap 4] \
	    [lindex $newmap 5] \
	    [lindex $newmap 6] \
	    [findNumericValue $DEViseShapes [lindex $newmap 7]] \
	    [lindex $newmap 8] [lindex $newmap 9] \
	    [lindex $newmap 10] [lindex $newmap 11] \
	    ]
    
    # Change parameter
    set cmd "DEVise changeParam \{$map\} $newparams"
    eval $cmd
    return
}


proc ChangeViewMapping { map } {
    # Refresh all views that use this mapping
    set views [ViewSet]
    foreach view $views {
	set mappings [DEVise getViewMappings $view]
	set contains 0
	foreach m $mappings {
	    if {$m == $map} {
		set contains 1
		break
	    }
	}
	if {$contains > 0} {
	    DEVise invalidatePixmap $view
	    DEVise refreshView $view
	}
    }
    return
}


proc UpdateMappings { map params mappings } {
    set newmap ""
    foreach item $mappings {
	set itemname [lindex $item 0]
	global mappingValue$itemname
	lappend newmap [deref mappingValue$itemname]
    }
    puts $newmap
    ChangeParams $map $params $newmap
    ChangeViewMapping $map
    return
}

