#  ========================================================================
#  DEVise Data Visualization Software
#  (c) Copyright 1992-1995
#  By the DEVise Development Group
#  Madison, Wisconsin
#  All Rights Reserved.
#  ========================================================================
#
#  Under no circumstances is this software to be copied, distributed,
#  or altered in any way without prior permission from the DEVise
#  Development Group.

############################################################

#	$Id$	

#	$Log$
#	Revision 1.38  1995/12/15 03:39:37  ravim
#	KGraph can display count. Schema browsing capabilities determined by the user
#	mode.
#
#	Revision 1.37  1995/12/14 15:46:35  jussi
#	Added support for TileLayout view layout with automatic or manual
#	layout control.
#
#	Revision 1.36  1995/12/12 01:47:18  ravim
#	Physical/logical schema support.
#
#	Revision 1.35  1995/12/08 23:47:46  ravim
#	Window name is passed as parameter in creating KGraph.
#
#	Revision 1.34  1995/12/07 02:17:07  ravim
#	User can choose the stats to be displayed.
#
#	Revision 1.33  1995/12/06 05:42:03  ravim
#	Added function to display a KGraph.
#
#	Revision 1.32  1995/12/04 18:04:45  jussi
#	User can now specify a view title which appears at the top of the view.
#	Changed statistics toggling to use getViewStatistics and
#	setViewStatistics so that a single view or all views can be toggled,
#	based on the status of the currently selected view.
#
#	Revision 1.31  1995/12/02 21:45:17  jussi
#	Added support for TK_WINDOW i.e. Tcl/Tk controls surrounding each
#	view and window.
#
#	Revision 1.30  1995/11/29 17:58:39  jussi
#	Slightly better interface to removing a window.
#
#	Revision 1.29  1995/11/29 17:49:48  jussi
#	Added RemoveWindow command.
#
#	Revision 1.28  1995/11/28 05:34:48  ravim
#	Support for statistics.
#
#	Revision 1.27  1995/11/28 00:03:41  jussi
#	Added printing of views to menu.
#
#	Revision 1.26  1995/11/27 15:21:12  jussi
#	Instead of reading a single, host-dependent config file, control.tk now
#	reads a common, host-independent config file, followed by a smaller
#	host-dependent config file *if one exists*.
#
#	Revision 1.25  1995/11/24  07:47:27  ravim
#	Mapping between different types of data sources can be defined.
#	Anything that cannot be resolved automatically can be handled manually.
#
#	Revision 1.24  1995/11/22 00:33:13  jussi
#	Fixed bug in function that saves session files; spaces embedded
#	in TData names needed to be protected by braces.
#
#	Revision 1.23  1995/11/21 23:36:19  jussi
#	Made complex mappings editable. Edit Mapping function now allows the
#	user to edit all parameters of an interpreted mapping. E.g. color can
#	be made to depend on an attribute in user data or constant. Made pixel
#	width and height information visible to the user.
#
#	Revision 1.22  1995/11/20 22:21:33  jussi
#	Added schemadir, cachedir, and sessiondir.
#
#	Revision 1.21  1995/11/19 06:03:59  ravim
#	New schema options - user/superuser
#
#	Revision 1.20  1995/11/14 22:53:17  jussi
#	Moved stream selection dialog to be part of macro definition
#	utility (DefSource in macrodef.tk). Elimininated 'Source'
#	menu bar and moved remaining menu option (Define Source)
#	to the Visualize menu (Sources... option).
#
#	Revision 1.19  1995/11/10 21:56:54  jussi
#	Minor fix.
#
#	Revision 1.18  1995/11/10 21:45:05  jussi
#	Changed interface to ISSM and Compustat to be through
#	sources.tcl.
#
#	Revision 1.17  1995/11/02 16:45:59  jussi
#	Removed confirmation message when removing a view from a window.
#	When moving a view from one window to another, current selection
#	determines the view to be moved; the user is not asked to select
#	a view from a list. Reorganized some View menu items.
#
#	Revision 1.16  1995/10/11 17:03:27  ravim
#	Schema browser invoked from the main menu bar.
#
#	Revision 1.15  1995/09/28 17:45:16  jussi
#	Added 'Save as Template' command. Minor other improvements.
#
#	Revision 1.14  1995/09/22 17:33:35  jussi
#	Added copyright message.
#
#	Revision 1.13  1995/09/21 15:36:16  jussi
#	Added import data types.
#
#	Revision 1.12  1995/09/19 16:56:18  jussi
#	Added interfacing to Compustat. Fixed bug in GetClass.
#
#	Revision 1.11  1995/09/13 14:24:56  jussi
#	Extracted macro definition code and moved it to macrodef.tk.
#	Added interfacing to SEQ and SQL queries.
#
#	Revision 1.10  1995/09/12 22:05:45  jussi
#	Fixed some problems in interfacing new user interface to
#	DEVise. New user interface was creating too many mapping
#	classes and instances of mappings.
#
#	Revision 1.9  1995/09/11 22:27:07  jussi
#	Further integration of the new user interface and DEVise.
#	User can now select 1 to n attributes in the automatic
#	map generator.
#
#	Revision 1.8  1995/09/08 22:17:57  jussi
#	Integrated creation of TData source, windows, and links in DEVise.
#
#	Revision 1.7  1995/09/08 20:35:25  jussi
#	Added definition of data source and size of new windows.
#
#	Revision 1.6  1995/09/07 22:59:41  jussi
#	Implemented saving and loading sessions (new type) and automatic
#	view creation.
#
#	Revision 1.5  1995/09/07 20:34:21  jussi
#	Finished an intermediate stage in designing an integrated
#	tdata/window/map/view/link definition.
#
#	Revision 1.4  1995/09/05 22:47:55  jussi
#	Added/updated CVS header.
#
#	Revision 1.3  1995/09/05 22:45:33  jussi
#	Updated CVS header.

############################################################

# The following are linked to global C variables: fileName, fileAlias,
# gdataName, windowName, sessionName, argv0,  template

# Keep the following for monochrome model
#set green white
#set blue black
#tk colormodel . monochrome

set green green
set blue blue

# use color model used in old Tk library (bisque color)
tk_bisque

. configure -bg LightBlue

# set colors and shapes
set DEViseColors {{0 black} {1 white} {2 red} {3 blue} {4 orange} \
	{5 tan} {6 green} {7 purple} {8 aquamarine} {9 peru} {10 chocolate} \
	{11 tomato} {12 pink} {13 plum} {14 azure1} {15 cyan1} {16 SeaGreen1} \
	{17 khaki1} {18 goldenrod1} {19 yellow} {20 sienna1} {21 green} \
	{22 blue} {23 orange} {24 LightGray} {25 red1} {26 red2} \
	{27 green1} {28 green2} {29 blue1} {30 blue2} {31 gold1} {32 gold2} \
	{33 blue1} {34 blue2} {35 blue3} {36 blue4}}
set DEViseShapes {{0 Rect} {1 RectX} {2 Bar} {3 Polygon} {4 Oval}}

# global to control.tk: curView: current view selected.
# lastView: last view selected.
# historyOpen: true if history window has been opened.
set curView ""
set lastView ""
set historyWinOpened false

set libdir "."
if { [info exists env(DEVISE_LIB)] } {
    set libdir $env(DEVISE_LIB)
}
set datadir "."
if { [info exists env(DEVISE_DAT)] } {
    set datadir $env(DEVISE_DAT)
}
set cachedir "."
if { [info exists env(DEVISE_CACHE)] } {
    set cachedir $env(DEVISE_CACHE)
}
set schemadir "."
if { [info exists env(DEVISE_SCHEMA)] } {
    set schemadir $env(DEVISE_SCHEMA)
}
set sessiondir "."
if { [info exists env(DEVISE_SESSION)] } {
    set sessiondir $env(DEVISE_SESSION)
}

set mode 0
DEVise changeMode $mode

set hostCfg $libdir/config.tcl
if {![file exists $hostCfg]} {
    puts "Cannot read configuration file $hostCfg"
}
puts "Reading configuration file $hostCfg"
source $hostCfg
set hostCfg $libdir/config.$env(HOSTNAME)
if {[file exists $hostCfg]} {
    puts "Reading configuration file $hostCfg"
    source $hostCfg
}

source $libdir/dialog.tk
source $libdir/FSBox.tk
source $libdir/dialogList.tk
source $libdir/dialogParam.tk
source $libdir/dialogCkBut.tk
source $libdir/dialogMapping.tk
source $libdir/help.tk
source $libdir/macrodef.tk
source $libdir/sources.tcl
source $libdir/schema.tk
source $libdir/mapping.tk
source $libdir/util.tcl

# abstract data type for dictionary
# Insert name and val into dictionary. Return new dictionary.
proc DictInsert { dict name val }  {
    set element [list $name $val]
    return [lappend dict $element]
}

# lookup val based on name
proc DictLookup { dict name } {
    foreach element $dict {
	if {$name == [lindex $element 0]} {
	    return [lindex $element 1]
	}
    }
    return ""
}

# Create a new unique name based on old name
proc UniqueName { name} {
    #  puts "UniqueName incoming $name"
    while { [DEVise exists $name] } {
	set len [string length $name]
	set lastChar [string index $name [expr $len-1]]
	if { [scan $lastChar "%d" temp] == 1 } {
	    # numeric for the last character
	    set name [format "%s%d" [string range $name 0 [expr $len-2]] \
		    [expr $lastChar+1]]
	} else {
	    set name [format "%s%d" $name 1]
	}
    }
    return $name
}

set helpWindowCreated 0
# Create menu
wm geometry . +0+0

# Get all instances for a category
proc CategoryInstances {category } {
    set inst {}
    set classes [ DEVise get $category ]
    foreach c $classes {
	set inst [ concat $inst [ DEVise get $category $c ] ]
    }
    return $inst
}

# Get the class of an instance belonging to category
proc GetClass { category instance } {
    set classes [DEVise get $category ]
    foreach c $classes {
	set insts [DEVise get $category $c]
	foreach inst $insts {
	    # puts "comparing $category $c $inst"
	    if {$inst == $instance} {
		return $c
	    }
	}
    }
}

# All instances of tdata that we have
# Form: {tdatafilebasename1 tdatafilebasename2 ...}
proc TdataSet {} {
    return [CategoryInstances "tdata" ]
}

# All instances of GData
# Form: {gdataname1 gdataname2 ...}
proc GdataSet {} {
    return [ CategoryInstances "mapping" ]
}

# All interpreted GData
proc InterpretedGData {} {
    set gSet [ GdataSet ]
    set result ""
    foreach gdata  $gSet {
	if { [DEVise isInterpretedGData $gdata ] } {
	    lappend result $gdata
	}
    }
    return $result
}

# list of all views
proc ViewSet {} {
    return [ CategoryInstances "view" ]
}

#list of all cursors
proc CursorSet {} {
    return [ CategoryInstances "cursor" ]
}

# list of all links
proc LinkSet {} { 
    return [ CategoryInstances "link" ]
}

# list of all windows
proc WinSet {} {
    return [ CategoryInstances "window" ]
}

# list of all axis 
proc AxisSet {} {
    return [ CategoryInstances "axisLabel" ]
}

# list of all actions
proc ActionSet {} {
    return [ CategoryInstances "action" ]
}

# build top level menu
frame .mbar -relief raised -bd 2 -background LightBlue 
menubutton .mbar.session -text Session -underline 0 \
	-menu .mbar.session.menu -bg LightBlue
menubutton .mbar.file -text Visualize -underline 7 \
	-menu .mbar.file.menu -bg LightBlue
menubutton .mbar.view -text View -underline 0 \
	-menu .mbar.view.menu -bg LightBlue
# menubutton .mbar.link -text Link -underline 0 \
#	-menu .mbar.link.menu -bg LightBlue
menubutton .mbar.cursor -text Cursor -underline 0 \
	-menu .mbar.cursor.menu -bg LightBlue
menubutton .mbar.window -text Window -underline 0 \
	-menu .mbar.window.menu -bg LightBlue
menubutton .mbar.schema -text Schema -underline 0 \
	-menu .mbar.schema.menu -bg LightBlue
menubutton .mbar.mapping -text Mapping -underline 0 \
	-menu .mbar.mapping.menu -bg LightBlue

menu .mbar.session.menu -tearoff 0
.mbar.session.menu add command -label "Open" -command {DoOpen 0}
.mbar.session.menu add command -label "Open as Template" -command {DoOpen 1}
.mbar.session.menu add command -label "Close" -command DoClose
.mbar.session.menu add command -label "Save" -command DoSave
.mbar.session.menu add command -label "Save as" -command {DoSaveAs 0}
.mbar.session.menu add command -label "Save as Template" -command {DoSaveAs 1}
.mbar.session.menu add command -label "Print" -command PrintView
.mbar.session.menu add command -label "Quit" -command DoExit

menu .mbar.file.menu -tearoff 0
.mbar.file.menu add command -label "Define" -command MacroDefStart
#.mbar.file.menu add separator
#.mbar.file.menu add command -label "Sources..." -command NotImplemented
.mbar.file.menu add separator
.mbar.file.menu add command -label "File" -command DoVisualizeFile
.mbar.file.menu add command -label "TData" -command DoVisualizeTData
.mbar.file.menu add command -label "GData" -command DoVisualizeGData

menu .mbar.view.menu -tearoff 0
.mbar.view.menu add command -label "Edit Mapping" -command DoEditMapping
.mbar.view.menu add command -label "Switch TData" -command DoSwitchTData
.mbar.view.menu add separator
.mbar.view.menu add command -label "Swap View Position" -command DoSwapView
.mbar.view.menu add command -label "Move To Window" -command DoViewMove
.mbar.view.menu add command -label "Remove From Window" -command DoViewRemove
.mbar.view.menu add command -label "Bring Back To Window" -command DoBringView
.mbar.view.menu add separator
.mbar.view.menu add command -label "Link" -command DoViewLink
.mbar.view.menu add command -label "Unlink" -command DoViewUnlink
.mbar.view.menu add command -label "XAxis" -command {DoViewAxis x}
.mbar.view.menu add command -label "YAxis" -command {DoViewAxis y}
.mbar.view.menu add cascade -label "Toggle X Axis" \
	-menu .mbar.view.menu.xaxismenu
.mbar.view.menu add cascade -label "Toggle Y Axis" \
	-menu .mbar.view.menu.yaxismenu
.mbar.view.menu add cascade -label "Toggle Statistics" \
	-menu .mbar.view.menu.statmenu
.mbar.view.menu add cascade -label "Show KGraph" \
	-menu .mbar.view.menu.kmenu
.mbar.view.menu add separator
.mbar.view.menu add command -label "Title" -command DoSetTitle

#.mbar.view.menu add command -label "Action" -command DoViewAction
#.mbar.view.menu add command -label "Save Pixmap" -command DoSavePixmap
#.mbar.view.menu add command -label "Load Pixmap" -command DoLoadPixmap

menu .mbar.view.menu.xaxismenu -tearoff 0
.mbar.view.menu.xaxismenu add command -label "Current View" \
	-command {DoToggleAxis X}
.mbar.view.menu.xaxismenu add command -label "All Views" \
	-command {DoToggleAxisAllViews X}

menu .mbar.view.menu.yaxismenu -tearoff 0
.mbar.view.menu.yaxismenu add command -label "Current View" \
	-command {DoToggleAxis Y}
.mbar.view.menu.yaxismenu add command -label "All Views" \
	-command {DoToggleAxisAllViews Y}

menu .mbar.view.menu.statmenu -tearoff 1
.mbar.view.menu.statmenu add checkbutton -label Mean -variable statmean
.mbar.view.menu.statmenu add checkbutton -label Max -variable statmax
.mbar.view.menu.statmenu add checkbutton -label Min -variable statmin
.mbar.view.menu.statmenu add separator
.mbar.view.menu.statmenu add radiobutton -label "No Conf. Intervals" \
	-variable statcilevel -value "000"
.mbar.view.menu.statmenu add radiobutton -label "85% CI" \
	-variable statcilevel -value "100"
.mbar.view.menu.statmenu add radiobutton -label "90% CI" \
	-variable statcilevel -value "010"
.mbar.view.menu.statmenu add radiobutton -label "95% CI" \
	-variable statcilevel -value "001"
.mbar.view.menu.statmenu add separator
.mbar.view.menu.statmenu add radiobutton -label "Current View" \
	-variable statcurr -value 1
.mbar.view.menu.statmenu add radiobutton -label "All Views" \
	-variable statcurr -value 0
.mbar.view.menu.statmenu add separator
.mbar.view.menu.statmenu add command -label "Apply..." \
	-command {DoToggleStatistics}
#defaults
set statmean 1
set statmax 0
set statmin 0
set statcurr 1
set statcilevel "000"

menu .mbar.view.menu.kmenu -tearoff 1
.mbar.view.menu.kmenu add radiobutton -label Mean -variable kval -value 0
.mbar.view.menu.kmenu add radiobutton -label Max -variable kval -value 1
.mbar.view.menu.kmenu add radiobutton -label Min -variable kval -value 2
.mbar.view.menu.kmenu add radiobutton -label Count -variable kval -value 3
.mbar.view.menu.kmenu add separator
.mbar.view.menu.kmenu add radiobutton -label "Use Current" \
	-variable kcurr -value 1
.mbar.view.menu.kmenu add radiobutton -label "Specify Views" \
	-variable kcurr -value 0
.mbar.view.menu.kmenu add separator
.mbar.view.menu.kmenu add radiobutton -label "New Graph" \
	-variable knew -value 1
.mbar.view.menu.kmenu add radiobutton -label "Reuse Graph" \
	-variable knew -value 0
.mbar.view.menu.kmenu add separator
.mbar.view.menu.kmenu add command -label "Apply..." \
	-command {ShowKGraph}
#defaults
set kval 0
set kcurr 1
set knew 0

# menu .mbar.link.menu -tearoff 0
#.mbar.link.menu add command -label "Create" -command DoLinkCreate
#.mbar.link.menu add command -label "Modify" -command DoModifyLink
#.mbar.link.menu add command -label "Link View" -command DoViewLink

menu .mbar.cursor.menu -tearoff 0
.mbar.cursor.menu add command -label "Create" -command DoCursorCreate
.mbar.cursor.menu add command -label "Set src" -command DoSetCursorSrc
.mbar.cursor.menu add command -label "Set Dst" -command DoSetCursorDst

menu .mbar.window.menu -tearoff 0
.mbar.window.menu add command -label "Layout" -command {SetWindowLayout ""}
.mbar.window.menu add command -label "Remove" -command {RemoveWindow ""}
.mbar.window.menu add separator
.mbar.window.menu add command -label "Demo" -command DoDemo
.mbar.window.menu add command -label "Help" -command DoHelp
.mbar.window.menu add command -label "History" -command OpenHistory
.mbar.window.menu add command -label "Duplicate" -command DupWindow

menu .mbar.schema.menu -tearoff 0
# Command to execute for browsing schema depends on whether we are in 
# the user or the superuser mode. 
.mbar.schema.menu add command -label "Browse.." -command SchemaBrowse

menu .mbar.mapping.menu -tearoff 0
.mbar.mapping.menu add command -label "Define" -command DefineMapping
.mbar.mapping.menu add command -label "Resolve" -command ResolveMapping

pack .mbar.session .mbar.file .mbar.view .mbar.cursor \
	.mbar.window .mbar.schema .mbar.mapping -side left -fill x

# status widgets
frame .status  -background LightBlue 
frame .status.left -background LightBlue 
frame .status.right -relief sunken  -background LightBlue -background LightBlue

# .status.right configure -background LightBlue
if { $mode == 0 } {
    set modeText "display mode"
} else {
    setmodeText "layout mode"
}

button .status.left.mode -text $modeText -command {ChangeMode} \
	-background turquoise
pack .status.left.mode -side left -fill x -expand 1

label .status.right.stat -text "status:" -bg LightBlue
label .status.right.stat_msg -bitmap questhead -background LightBlue
pack .status.right.stat_msg .status.right.stat -side right

pack .status.left  -side left 
pack .status.right -side right

# build current view widgets
frame .viewFrame -relief sunken -background LightBlue

label .viewFrame.label -text "Current View:" -bg lavender
label .viewFrame.viewName -text "" -width 50  -bg lavender -fg red
pack .viewFrame.label .viewFrame.viewName  -side left 

# build control widgets
frame .topFrame -background LightBlue

frame .control -relief sunken -background LightBlue
frame .control.level1 -background LightBlue
frame .control.level2 -background LightBlue
frame .control.level3 -background LightBlue

# Do the buttons
button .control.left -bitmap @$libdir/left.bit \
	-command { ProcessLeftButton} -bg cyan1
set left_amount 0.5

button .control.right -bitmap @$libdir/right.bit \
	-command {ProcessRightButton} -bg cyan1
set right_amount 0.5

button .control.up -bitmap @$libdir/up.bit \
	-command { ProcessUpButton } -bg cyan1
set up_amount 0.5

button .control.down -bitmap @$libdir/down.bit \
	-command { ProcessDownButton } -bg cyan1
set down_amount 0.5

button .control.in -bitmap @$libdir/zoominx.bit \
	-command { ProcessInButton } -bg orange
set in_amount 0.5

button .control.out -bitmap @$libdir/zoomoutx.bit \
	-command {ProcessOutButton} -bg orange
set out_amount 1.5

button .control.yin -bitmap @$libdir/zoominy.bit \
	-command {ProcessYInButton} -bg orange
button .control.yout -bitmap @$libdir/zoomouty.bit \
	-command {ProcessYOutButton} -bg orange

pack .control.in .control.left .control.yin -in .control.level1 -side top
pack .control.up -side top -in .control.level2 
pack .control.down -side bottom -in .control.level2 -fill y 
pack .control.out .control.right .control.yout -in .control.level3 -side top
pack .control.level1 .control.level2 .control.level3 -in .control  -side left

# build history widgets
frame .history -relief sunken -bd 2 -background LightBlue

frame .history.heading1 -background LightBlue
frame .history.heading2 -background LightBlue
label .history.xlowHeading -text xlow -bg LightBlue
label .history.xhighHeading -text xhigh -bg LightBlue
label .history.ylowHeading -text ylow -bg LightBlue
label .history.yhighHeading -text yhigh  -bg LightBlue
pack .history.xlowHeading .history.ylowHeading -in .history.heading1 \
	-side top
pack .history.xhighHeading .history.yhighHeading -in .history.heading2 \
	-side top

frame .history.entry1 -bg LightBlue
frame .history.entry2 -bg LightBlue
entry .history.xlow -text "" -relief sunken -width 20 -bg yellow -fg $blue
entry .history.xhigh -text "" -relief sunken -width 20 -bg yellow -fg $blue
entry .history.ylow -text "" -relief sunken -width 20 -bg LightGray 
entry .history.yhigh -text "" -relief sunken -width 20 -bg LightGray
pack .history.xlow .history.ylow  -in .history.entry1 -side top \
	-expand 1 -fill x
pack .history.xhigh .history.yhigh -in .history.entry2 -side top  \
	-expand 1 -fill x

frame .history.buttonFrame  -background LightBlue
button .history.button -text "use" -relief raised -bg $green \
	-command { ProcessUseButton }
button .history.undo -text "undo-edit" -bg $green -relief raised \
	-command {DoUndoEdit}
button .history.back -text "back one" -bg $green -relief raised \
	-command {DoGoBackOne}
button .history.history -text "history" -bg $green -relief raised \
	-command {DoHistoryToggle}
pack .history.button .history.undo .history.back .history.history \
	-in .history.buttonFrame -side left -expand 1 -fill x

pack .history.buttonFrame -side bottom -expand 1 -fill x
pack .history.heading1 .history.entry1 .history.heading2 \
	.history.entry2 -side left -expand 1 -fill x

pack .mbar .status .viewFrame .topFrame -side top -fill x -expand 1
pack .control .history -side left -fill x -expand 1

tk_menuBar .mbar .mbar.session .mbar.file .mbar.view \
	.mbar.link .mbar.window .mbar.help
focus .mbar

# Create a new instance of file of the given type.
proc DoCreateTData { file type } {
    global dialogParamVar fileName fileAlias
    set fileName $file
    set fileAlias [ file tail $file ]
    set paramNames [ DEVise getparam tdata $type ]
    set tempParams [ lrange $paramNames 1 [expr [llength $paramNames]-1]]

    set button [ dialogParam .fileParam "FileParam" \
	    "Enter Alias for file\n\
	    $file\n\
	    (Note: it may take a while for the program\n\
	    to come back after clicking <OK>)"  "" 1  \
	    { Cancel OK } $tempParams]
    if { $button == 0} {
	return
    }

    set fileAlias [ lindex $dialogParamVar(params) 0 ]
    if { [DEVise exists $fileAlias] } {
	# This file alias already exists in memory.
	set but [dialog .fileExist "FileExist" \
		"Warning: TData $fileAlias	exists" "" \
		1 {cancel} {Use Existing}]
	if { $but == 0 } {
	    return
	} else {
	    return $fileAlias
	}
    }

    set params $dialogParamVar(params)
    set params [linsert $params 0 $file ]
    set cmd "DEVise create tdata $type $params"
 
    set result [eval $cmd]
    if {$result == ""} {
	set but [ dialog .createError "CreateError" \
		"Can't import file $file of type $type" \
		"" 0 OK ]
	return
    }

    return $result
}

#import a new file type
#Return name of file type, or ""
proc ImportFileType {} {
    global fsBox schemadir
    set fsBox(path) $schemadir/logical
    set fsBox(pattern) *
    set ftypeFile [FSBox "Select schema file"]
    if {$ftypeFile == ""} {
	return
    }
    
    set result [DEVise importFileType $ftypeFile]
    if {$result == ""} {
	dialog .fileTypeError "Schema File Error" \
		"Error reading schema file $ftypeFile" \
		"" 0 OK
	return
    }
    return $result
}

# Check to see if file already exists 
proc FileExist { file } {
    foreach tdata [ TdataSet] {
	if {$file == [DEVise tdataFileName $tdata]} {
	    return 1
	}
    }
    return 0
}

# Select a file and make it into a TData
proc DoSelectFile {} {
    global dialogListVar fsBox datadir
    # Get file name
    set fsBox(path) $datadir
    set fsBox(pattern) *
   set file [ FSBox ]

    # Map file into TData classes
    if {$file == ""} {
	return
    }

    if  { [FileExist $file ] } {
	set but [dialog .fileExist "File Exists" \
		"File $file already loaded\n\
		Please use Visualize/TData menu" "" 0 Continue]
	return
    }

    # find file type (TData class name )
    while { 1 } {
	set tclass [ DEVise get tdata]

	if { [ llength $tclass ] == 0 } {
	    set but [dialog .noTdata "No File Type" \
		    "No existing file type.\n\
		    Import schema for file\n$file?" "" 1 \
		    Cancel OK ]
	    if { $but == 0} {
		return
	    }
	    set result [ImportFileType]
	    if {$result == ""} {
		return
	    }
	    set ftype $result
	    break
	} 
	set button [ dialogList .fileType "fileType" \
		"Select file type for file \n$file"\
		"" 2  { Cancel new OK } $tclass ]
	set ftype $dialogListVar(selected)
	if { $button  == 0 } {
	    return
	} elseif { $button == 1 } {
	    set result [ImportFileType]
	    if {$result == ""} {
		return
	    }
	    set ftype $result
	    break
	} elseif {$dialogListVar(selected) == ""} {
	    return
	} else {
	    break
	}
    }

    set alias [ DoCreateTData $file $ftype ]
    if {$alias == ""} {
	return
    }

    return $alias
}

proc DoSelectTData {} {
    global dialogListVar
    set tdataSet [ TdataSet ]
    if { [ llength $tdataSet  ] == 0 } {
	return [ DoSelectFile ]
    } else {
	set answer [ dialogList .selectTData "SelectTData"  \
		"Select a TData" \
		"" 2 { New Cancel Ok } $tdataSet ]
	if { $answer == 0 } {
	    # Select a new file
	    return [ DoSelectFile ]
	} elseif { $answer == 1 || $dialogListVar(selected) == "" } {
	    # Cancel selected or no file selected.
	    return 
	} else {
	    # Get the selection
	    return $dialogListVar(selected)
	}
    }
}

# eliminate string attributes from schema
proc ElimStringAttr { attrs } {
    set newAttrs ""
    foreach attr $attrs {
	set attrType [lindex $attr 1]
	if {$attrType != "string"} {
	    lappend newAttrs $attr
	}
    }
    return $newAttrs
}

# drop attribute types and sorted flags
proc DropAttrTypes { attrs } {
    set newAttrs ""
    foreach attr $attrs {
	lappend newAttrs [list [lindex $attr 0]]
    }
    return $newAttrs
}

# Find default X attribute name.
# The default is the sorted X attribute other than recId, if one exists.
# Otherwise, it's the recId.
# otherwise, it's the 0th attribute.

proc FindDefaultXAttr { attrs } {
    set numAttrs 0
    foreach attr $attrs {
	# puts "attr= $attr"
	if { [lindex $attr 2] > 0 } {
	    set temp($numAttrs) [lindex $attr 0]
	    incr numAttrs
	    if {$numAttrs >= 2 } {
		break
	    }
	}
    }
    if { $numAttrs == 0 } {
	# puts "numAttrs == 0"
	return [lindex [lindex $attrs 0] 0]
    } elseif { $numAttrs == 1 } {
	# puts "numAttrs == 1"
	return $temp(0)
    } else {
	# puts "numAttrs >= 2"
	if { $temp(0) == "recId"} {
	    return $temp(1)
	} else {
	    return $temp(0)
	}
    }
}

# Create an interpreted mapping 
proc CreateInterpretedMapping { tdata } {
    global dialogParamVar DEViseColors DEViseShapes

    set attrs [lsort [ElimStringAttr [DEVise getSchema $tdata]]]
    set simpleAttrs [DropAttrTypes $attrs]
    set defX [FindDefaultXAttr $attrs]
    set defY [lindex $simpleAttrs 0]
    if {$defX != "recId"} {
	set defY [lindex $simpleAttrs 1]
    }
    set defColor 2
    set defShape 2
    
    set parm [dialogMapping .enterMapping "Enter Mapping" \
	    "Enter Mapping" ""  \
	    $simpleAttrs \
	    [list  \
	    [list x $simpleAttrs $defX] \
	    [list y $simpleAttrs $defY]\
	    [list color $DEViseColors $defColor]\
	    [list shape $DEViseShapes $defShape]\
	    ] 1 ] 
    if {$parm == ""} {
	return
    }
    
    # extract parameters
    set mapName [lindex $parm 0]
    set parm [lindex $parm 1]
    
    # extract parameters
    set params [list $tdata $mapName {} \
	    \$[lindex $parm 0] \$[lindex $parm 1]  [lindex $parm 2] \
	    {} {} {} [lindex $parm 3] {} {} ]
    
    set cmd "DEVise createInterp $params"
    set result [eval $cmd]
    if {$result == ""} {
	set but [dialog .CreateError \
		"Can't create mapping for tdata $tdata" \
		"" 0 OK ]
	return 
    }
    
    return $result
}

# Actually create gdata and return its name
proc DoActualCreateGData { tdata mapping } {
    global dialogParamVar gdataName fileAlias
    set fileAlias $tdata
    set gdataName [UniqueName [ format "%s#%s" $tdata $mapping ]]

    # if { [DEVise exists $gdataName ] } {
	# set but [dialog .gdataExist "gdataExist" \
		# "Error: gdata $gdataName already exists" \
		# "" 0 {Cancel} ]
	# return
    # }

    set paramNames [ DEVise getparam mapping $mapping ]

    # puts "checking if interpreted $mapping"
    if {! [DEVise isInterpreted $mapping] } {
	# not interpreted mapping 
	set button [ dialogParam .mappingParam "MappingParam" \
		"Enter parameters to create gdata from file $tdata\n\
		and mapping $mapping"\
		"" 1 { Cancel OK } $paramNames ]
	if { $button == 0} {
	    return
	}

	set cmd "DEVise create mapping $mapping $dialogParamVar(params)"
	set result [eval $cmd]
	if {$result == ""} {
	    set but [ dialog .CreateError \
		    "Can't create mapping using $mapping" \
		    "" 0 OK ]
	    return
	}
	return $result
    } else {
	# interpreted mapping
	set parm1 "gdata $tdata#$mapping"
	set parms [list $parm1 ]
	set button [ dialogParam .mappingName GDataName \
		"Enter GData Name " "" 1 { Cancel OK } \
		$parms ]
	if { $button == 0 } {
	    return
	}
	set initParm $dialogParamVar(params)
	
	set gdataName [lindex $initParm 0]
	if { [DEVise exists $gdataName ] } {
	    set but [dialog .gdataExist "gdataExist" \
		    "Error: gdata $gdataName already exists" \
		    "" 0 {Cancel} ]
	    return
	}
	
	# extract parameters
	# puts "paramNames are: $paramNames"
	set params [list $tdata [lindex $initParm 0] \
		[ lindex [lindex $paramNames 2] 1] \
		[ lindex [lindex $paramNames 3] 1] \
		[ lindex [lindex $paramNames 4] 1] \
		[ lindex [lindex $paramNames 5] 1] \
		[ lindex [lindex $paramNames 6] 1] \
		[ lindex [lindex $paramNames 7] 1] \
		[ lindex [lindex $paramNames 8] 1] \
		[ lindex [lindex $paramNames 9] 1] \
		[ lindex [lindex $paramNames 10] 1] \
		[ lindex [lindex $paramNames 11] 1]] 
	
	set cmd "DEVise create mapping $mapping $params"
	set result [eval $cmd]
	if {$result == ""} {
	    set but [ dialog .CreateError \
		    "Can't create mapping using $mapping" \
		    "" 0 OK ]
	    return
	}
	return $result
    }
}

# Create a new GData from TData
proc DoCreateGData { tdata } {
    global dialogListVar
    set schema [DEVise getSchema $tdata ]

    while { 1 } {
	set tmappings [ DEVise get mapping ]
	if {$tmappings == ""} {
	    set but [dialog .noMap "No Mapping" \
		    "No existing mapping.\n\
		    Create mapping for tdata\n$tdata?" "" 1 \
		    Cancel OK ]
	    if { $but == 0} {
		return
	    }
	    set mapping [CreateInterpretedMapping $tdata]
	    if {$mapping == ""} {
		return
	    }
	    break
	}
	set answer [ dialogList .mapGData "MapFile"  \
		"Select mapping to map tdata\n $tdata\ninto gdata" \
		"" 0 { Cancel New OK } $tmappings ]
	if { $answer == 1} {
	    set mapping [CreateInterpretedMapping $tdata]
	    if {$mapping == ""} {
		return
	    }
	    break
	} elseif {$answer == 0  || $dialogListVar(selected) == ""} {
	    # no answer 
	    return 
	} else {
	    set mapping $dialogListVar(selected)
	    break
	}
    }
    # Create the actual gdata
    return [ DoActualCreateGData $tdata $mapping ]
}

# Get a GData for display
proc DoGetGData {} {
    global dialogListVar
    set gdataSet [ GdataSet ]
    if { [ llength $gdataSet ] == 0 } {
	set answer [ dialog .getDataError "Visualize GData Error" \
		"There is currently no GData.\n\
		Please use menu File/Visualize to\n\
		create GData for visualization"  "" 0 { Ok } ]
	return
    } else {
	set answer [ dialogList .getGData \
		"GetGData" "Select GData for display" \
		"" 0 { New Cancel OK } \
		$gdataSet ]
	if { $answer == 0 } {
	    # Create a new one
	    set tdata [ DoSelectTData ]
	    if {$tdata == ""} {
		return
	    }
	    return [ DoCreateGData $tdata ]
	} elseif {$answer == 1 || $dialogListVar(selected) == ""} {
	    return
	} else {
	    return $dialogListVar(selected)
	}
    }
}

proc DoActualCreateView { viewType name } {
    global dialogParamVar viewName
    set viewName $name
    # if { [DEVise exists $name ] } {
	# set but [dialog .viewExists "ViewExists" \
		# "Error: View $name exists" "" 0 {Cancel}]
	# return
    # }

    set paramNames [ DEVise getparam view $viewType ]
    puts "paramNames $paramNames"

    set button [ dialogParam .viewParam "ViewParam" \
	    "Enter parameters to create view\n$viewName"\
	    "" 1 { Cancel OK } $paramNames ]
    if { $button == 0} {
	return
    }
    set name [lindex $dialogParamVar(params) 0]
    if { [DEVise exists $name ] } {
	set but [dialog .viewExists "ViewExists" \
		"Error: View\n$name exists" "" 0  {Cancel}]
	return
    }

    set cmd "DEVise create view $viewType $dialogParamVar(params)"
    set result [eval $cmd]
    if {$result == ""} {
	set but [ dialog .viewError "ViewError" \
		"Can't create view using $viewType" "" 0 OK ]
	return
    }
    return $result
}

# Do create a new view
proc DoCreateView { message gdata} {
    global dialogListVar

    set viewClasses [ DEVise get view ]
    set answer [ dialogList .createView "CreateView" $message \
	    "" 0 { Cancel OK } $viewClasses 0]
    if {$answer == 0 || $dialogListVar(selected) == ""} {
	return
    } else {
	return [ DoActualCreateView $dialogListVar(selected) \
		$gdata#$dialogListVar(selected) ]
    }
}

proc DoGetView { gdata } {
    global dialogListVar
    set viewSet [ ViewSet ]

    # Use this to always create a new view
    return [ DoCreateView "Select type of view to display\n$gdata" \
	    $gdata ]

    #	use this when we have overlapping views
    if { [ llength $viewSet ] == 0 } {
	return [ DoCreateView "Select type of view to display $gdata" \
		$gdata ]
    } else {
	set answer [ dialogList .getView "GetView" "Select a view to \
		display $gdata, or press <New> to create a new one" "" 2 \
		{ Cancel New OK } $viewSet ]
	if { $answer == 1 } {
	    return [ DoCreateView  \
		    "Select type of view to display $gdata" $gdata ]
	} elseif {$answer == 0 || $dialogListVar(selected) == ""} {
	    return
	} else {
	    return $dialogListVar(selected)
	}
    }
}

proc DoActualCreateWindow { winType } {
    global dialogParamVar windowName
    set windowName [UniqueName DEViseWn0]
    set paramNames [ DEVise getparam window $winType ]

    set button [ dialogParam .windowParam "WindowParam" \
	    "Enter parameters to create window $winType"\
	    "" 1 { Cancel OK } $paramNames ]
    if { $button == 0} {
	return
    }
    set cmd "DEVise create window $winType $dialogParamVar(params)"
    set result [eval $cmd ]
    if {$result == ""} {
	set but [ dialog .winError "winError" \
		"Can't create window using $winType" "" 0 OK ]
	return
    }
    return $result
}

# Create a new window
proc DoCreateWindow { message } {
    global dialogListVar
    set winTypes [ DEVise get window ]
    if { [llength $winTypes] == 1 } {
	return [ DoActualCreateWindow [lindex $winTypes 0] ]
    }
    set answer [ dialogList .createWin "CreateWindow"  \
	    $message "" "" { Cancel Ok } $winTypes ]
    if {$answer == 0 || $dialogListVar(selected) == ""} {
	return
    } else {
	return [ DoActualCreateWindow $dialogListVar(selected) ]
    }
}

# Get a window 
proc DoGetWindow {} {
    global dialogListVar

    set winSet [ WinSet ]

    if { [ llength $winSet ] == 0 } {
	return [ DoCreateWindow "Select window type" ]
    }

    set answer [ dialogList .window "Select Window" \
	    "Select a window to display view in" "" "" \
	    { Cancel New Ok } $winSet ]
    if { $answer == 1 } {
	return [ DoCreateWindow "Select window type" ]
    }

    if {$answer == 0  || $dialogListVar(selected) == ""} {
	return 
    }

    return $dialogListVar(selected)
}

proc DoVisualizeTData {} {
    set tdata [ DoSelectTData ]
    DoActualVisualizeTData $tdata
}

proc DoVisualizeFile {} {
    set tdata [ DoSelectFile ]
    DoActualVisualizeTData $tdata
}

# Do File/TData command. Return 1 if OK, else return nothing
proc DoActualVisualizeTData { tdata } {
    if {$tdata == ""} {
	# no tdata selected.
	return
    }
    
    # Do mapping for tdata
    set gdata [ DoCreateGData $tdata ]
    if {$gdata == ""} {
	# no tdata selected.
	return
    }
    
    # put gdata into view 
    set view [ DoGetView $gdata ]
    if {$view == ""} {
	return
    }
    set res [DEVise insertMapping $view $gdata ]

    # Find a window for view
    set window [ DoGetWindow ]
    if {$window == ""}  { 
	return
    }
    set res [ DEVise insertWindow $view $window ]
    
    ProcessViewSelected $view
}

proc DoVisualizeGData {} {
    set gdata [ DoGetGData ]
    if {$gdata == ""} {
	return
    }

    # gdata into view 
    set view [ DoGetView $gdata ]
    if {$view == ""} {
	return
    }
    set res [DEVise insertMapping $view $gdata ]
    
    # Find a window for view
    set window [ DoGetWindow ]
    if {$window == ""}  { 
	return
    }
    set res [ DEVise insertWindow $view $window ]
    
    ProcessViewSelected $view
}

proc DoExit {} {
    set answer [ dialog .quit "Quit" \
	    "Are you sure you want to quit?" "" 1 \
	    { Cancel} { Ok } ]
    if { $answer == 1 } {
	DEVise exit
    }
}


# Process View/Create menu
proc DoViewCreate {} {
    set ans [ DoCreateView "Select a view type" ]
}

# Destroy a view
proc DoViewDestroy {} {
    set answer [ dialogList .destroyView "DestroyView" \
	    "Select a view to destroy" "" 0 { Cancel OK } [ViewSet] ]
    if { $answer == 0 } {
	return
    } else {
	# Delete view here
	return
    }
}

# Remove view from window
proc DoViewRemove {} {
    global curView
    if {$curView == ""} {
	dialog .removeView "Remove View" \
		"Select a view first by clicking in it." "" 0 { OK }
	return
    }

    # Remove view
    set ans [DEVise removeView $curView]
    if {$ans != ""} {
	dialogList .removeError "RemoveError" $ans "" 0 OK
	return
    }

    # Unselect current view
    ProcessViewSelected ""
}

# Move view to another window
proc DoViewMove {} {
    global dialogListVar curView

    if {$curView == ""} {
	set answer [ dialogList .removeView "Move View" \
		"Select view to move." "" 0 { Cancel OK } \
		[ViewSet] ]
	if {$answer == 0} {
	    return
	}
	set viewName $dialogListVar(selected)
    } else {
	set viewName $curView
    }    

    set winName [ DoGetWindow ]
    if {$winName == ""} {
	return
    }
    
    DEVise insertWindow $viewName $winName
    ProcessViewSelected $viewName
}

# Bring back view to window
proc DoBringView {} {
    global dialogListVar

    set answer [ dialogList .removeView "Move View" \
	    "Select view to move to a window" "" 0 { Cancel OK } [ViewSet] ]
    if {$answer == 0} {
	return
    }
    set viewName $dialogListVar(selected)
    
    set winName [ DoGetWindow ]
    if {$winName == ""} {
	return
    }
    
    DEVise insertWindow $viewName $winName
    ProcessViewSelected $viewName
}

# Save a info about creating a class instance into file f
proc SaveInstance { f category class instance } {
    set params [ DEVise getCreateParam $category $class $instance ]
    puts $f "DEVise create $category $class $params"
    flush $f
}

# Save all instances of a given class into file f
proc SaveClass { f category class } {
    set instances [ DEVise get $category $class]
    foreach i $instances {
	SaveInstance $f $category $class $i 
    }
}

# Save all instances of a given category into file f
proc SaveCategory { f category } {
    set classes [ DEVise get $category ]
    foreach i $classes {
	SaveClass $f $category $i 
    }
}

# Print the name of all instances in category
proc PrintCategory { category } {
    set classes [ DEVise get $category ]
    puts "classes $classes"
    foreach c  $classes {
	set instances [ DEVise get $category $c]
	foreach i $instances {
	    puts -nonewline "$i "
	}
    }
    puts ""
}

# Save info about mappings to all views into file f
proc SaveAllViewMappings { f mappingDict viewDict } {
    # Get all mapping classes
    set viewClasses [ DEVise get "view" ]
    foreach vClass $viewClasses {
	# Get all views for this class
	set views [ DEVise get "view" $vClass ]
	foreach v $views {
	    set viewVar [DictLookup $viewDict $v]
	    # Get all mappings for this view
	    set mappings [ DEVise getViewMappings $v ]
	    foreach map $mappings {
		set mapVar [DictLookup $mappingDict $map]
		puts $f "DEVise insertMapping \$$viewVar \$$mapVar"
	    }
	}
    }
}

# Save info about axis labels to all views 
proc SaveAllViewAxisLabel { f viewDict } {
    set viewClasses [ DEVise get "view" ]
    foreach vClass $viewClasses {
	# Get all views for this class
	set views [ DEVise get "view" $vClass ]
	foreach v $views {
	    set viewVar [DictLookup $viewDict $v]
	    set xAxisLabel [ DEVise getAxis $v x]
	    if {$xAxisLabel != ""} {
		puts $f "DEVise setAxis \$$viewVar $xAxisLabel x"
	    }
	    
	    set yAxisLabel [ DEVise getAxis $v y]
	    if {$yAxisLabel != ""} {
		puts $f "DEVise setAxis \$$viewVar $yAxisLabel y"
	    }
	    
	    # Set axis display on/off.
	    set stat [DEVise getAxisDisplay $v X]
	    puts $f "DEVise setAxisDisplay \$$viewVar X $stat"
	    
	    set stat [DEVise getAxisDisplay $v Y]
	    puts $f "DEVise setAxisDisplay \$$viewVar Y $stat"
	}
    }
}


# Save info about action
proc SaveAllViewAction { f dict} {
    set viewClasses [ DEVise get "view" ]
    foreach vClass $viewClasses {
	# Get all views for this class
	set views [ DEVise get "view" $vClass ]
	foreach v $views {
	    set viewVar [DictLookup $dict $v]
	    set action [DEVise getAction $v]
	    if {$action != ""} {
		puts $f "DEVise setAction \$$viewVar $action"
	    }
	}
    }
}

# Save info about views inserted into windows into file f
proc SaveAllWindowViews { f viewDict} {
    # Get all window classes
    set windowClasses [ DEVise get "window" ]
    foreach winClass $windowClasses {
	# Get all windows for this class
	set windows [ DEVise get "window" $winClass ]
	foreach win $windows {
	    # Get all views inserted into this window
	    set views [DEVise getWinViews $win ]
	    foreach v $views {
		set viewVar [DictLookup $viewDict $v]
		puts $f "DEVise insertWindow \$$viewVar \{$win\}"
	    }
	}
    }
}

# Save name of views in links
proc SaveLinkViews { file dict} {
    set linkSet [LinkSet]
    foreach link $linkSet {
	set views [DEVise getLinkViews $link]
	foreach view $views {
	    set viewVar [DictLookup $dict $view]
	    puts $file "DEVise insertLink \{$link\} \$$viewVar"
	}
    }
}

# Save name of views in cursors
proc SaveCursorViews { file dict} {
    set cursorSet [CursorSet]
    foreach cursor $cursorSet {
	set views [DEVise getCursorViews $cursor]
	set src [DictLookup $dict [lindex $views 0]]
	set dst [DictLookup $dict [lindex $views 1]]
	if {$src != ""} {
	    puts $file "DEVise setCursorSrc $cursor \$$src"
	}
	if {$dst != ""} {
	    puts $file "DEVise setCursorDst $cursor \$$dst"
	}
    }
}

# Save session
proc DoActualSave { infile asTemplate } {
    global mode curView

    ChangeStatus 1
    # copy existing file to a backup file
    if { [ file exists $infile ] } {
	set src [open $infile]
	set dst [open $infile.bak w]
	while { [gets $src line] >= 0 } {
	    puts $dst $line
	}
	close $src
	close $dst

	if { ! [ file writable $infile ] } {
	    set but [ dialog .saveError "File $infile not writable" \
		    "" 0 OK ]
	    ChangeStatus 0
	    return
	}
    }

    # checkpoint tdata
    set classes [ DEVise get "tdata" ]
    foreach class $classes {
	set instances [ DEVise get "tdata" $class ]
	foreach inst $instances {
	    DEVise tcheckpoint $inst
	}
    }

    set f [open $infile w ]

    puts $f "# Import file types"
    set catFiles [DEVise catFiles]
    foreach file $catFiles {
	puts $f "DEVise importFileType $file"
    }
    puts $f ""

    puts $f "# Layout mode"
    puts $f "DEVise changeMode 0"
    puts $f ""

    puts $f "# Import file (Create TData)"
    puts $f "# format: DEVise create tdata fileType filePath fileAlias"
    set fileDict ""
    set fileNum 1
    set classes [DEVise get tdata]
    set totalTData [llength [TdataSet]]
    foreach class $classes {
	set instances [DEVise get tdata $class]
	foreach inst $instances {
	    set params [DEVise getCreateParam tdata $class $inst]
	    set filePath [lindex $params 0]
	    set fileAlias [lindex $params 1]
	    set fileDict [DictInsert $fileDict $fileAlias tdata_$fileNum]
	    set tdataVar tdata_$fileNum
	    if {$asTemplate} {
		puts $f "set $tdataVar \[ GetTDataTemplate $class $totalTData $fileNum \]"
		puts $f "if \{\$$tdataVar == \"\"\} \{"
		puts $f "\treturn 0"
		puts $f "\}"
	    } else {
		puts $f "if \{ \$template \} \{"
		puts $f "\tset $tdataVar \[ GetTDataTemplate $class $totalTData $fileNum \]"
		puts $f "\tif \{\$$tdataVar == \"\"\} \{"
		puts $f "\t\treturn 0"
		puts $f "\t\}"
		puts $f "\} else \{"
		puts $f "\tset $tdataVar \{$fileAlias\}"
		puts $f "\tDEVise create tdata $class $filePath \$$tdataVar"
		puts $f "\}"
	    }
	    set fileNum [expr $fileNum+1]
	}
    }
    puts $f  ""

    puts $f "# Create interpreted mapping classes "
    set mapClasses [ DEVise interpMapClassInfo ]
    foreach mclass $mapClasses {
	# puts "mclass $mclass"
	set mapTData [DictLookup $fileDict [lindex $mclass 0]]
	puts $f "DEVise createInterp \$$mapTData [lrange $mclass 1 end]"
    }
    puts $f ""

    puts $f "# Create mappings instances (and GData)"
    puts $f "# format: DEVise create mapping mapType fileAlias gdataName"
    set mapClasses [DEVise get mapping]
    set mapDict ""
    set mapNum 1
    foreach mapClass $mapClasses {
	set instances [DEVise get mapping $mapClass]
	foreach inst $instances {
	    set params [DEVise getCreateParam mapping $mapClass $inst]
	    set fileAlias [lindex $params 0]
	    set fileVar [DictLookup $fileDict $fileAlias]
	    set gdataName [lindex $params 1]
	    regsub $fileAlias $gdataName \%s gdataExpr
	    puts $f "set map_$mapNum \[ format \"$gdataExpr\" \$$fileVar \]"
	    puts $f "DEVise create mapping \{$mapClass\} \$$fileVar \$map_$mapNum [lrange $params 2 end]"
	    set mapDict [DictInsert $mapDict $inst map_$mapNum]
	    incr mapNum
	}
    }
    puts $f ""

    puts $f "# Save pixel width for mappings"
    foreach map [GdataSet ] {
	set width [DEVise getPixelWidth $map]
	set gdataVar [DictLookup $mapDict $map]
	puts $f "DEVise setPixelWidth \$$gdataVar $width"
    }
    puts $f  ""

    puts $f "# Create views"
    puts $f "# format: DEVise create view viewType viewName xlow xhigh ylow yhigh"
    set viewDict ""
    set viewNum 1
    set viewClasses [DEVise get view]
    foreach viewClass $viewClasses {
	set instances [DEVise get view $viewClass]
	foreach inst $instances {
	    set params [DEVise getCreateParam view $viewClass $inst]
	    set viewMap [lindex [DEVise getViewMappings $inst] 0]
	    set viewVar view_$viewNum
	    if {$viewMap == ""} { 
		puts $f "set $viewVar $inst"
	    } else {
		set viewTData [DEVise getMappingTData $viewMap]
		set tdataVar [DictLookup $fileDict $viewTData]
		regsub $viewTData $inst \%s viewExpr
		puts $f "set $viewVar \[ format \"$viewExpr\" \$$tdataVar \]"
	    }
	    puts $f "DEVise create view $viewClass \$$viewVar [lrange $params 1 end]"

	    set viewLabelParams [DEVise getLabel $inst]
	    puts $f "DEVise setLabel \$$viewVar $viewLabelParams"
	    set viewStatParams [DEVise getViewStatistics $inst]
	    puts $f "DEVise setViewStatistics \$$viewVar $viewStatParams"

	    set viewDict [DictInsert $viewDict $inst $viewVar]
	    set viewNum [expr $viewNum+1]
	}
    }
    puts $f ""

    puts $f "# Create windows"
    puts $f "# format: DEVise create window winType winName x y width height"
    SaveCategory $f "window" 
    puts $f ""

    puts $f "# Setup window layouts"
    foreach win [WinSet] {
	set layout [DEVise getWindowLayout $win]
	puts $f "DEVise setWindowLayout \{$win\} $layout"
    }
    puts $f ""
    
    puts $f "# Create Links"
    puts $f "# format: DEVise create link Visual_Link name flag"
    SaveCategory $f "link" 
    puts $f ""

    puts $f "# Create Cursors"
    puts $f "# format: DEVise create cursor Cursor name flag"
    SaveCategory $f "cursor"
    puts $f ""

    puts $f "# Create axislabel"
    puts $f "# format: DEVise create axisLabel type name format"
    SaveCategory $f "axisLabel"
    puts $f ""

    puts $f "# Create Actions"
    puts $f "# format: DEVise create action type name"
    SaveCategory $f "action"
    puts $f ""

    puts $f "# Put labels into views"
    SaveAllViewAxisLabel $f $viewDict
    puts $f ""

    puts $f "# Put action into view"
    SaveAllViewAction $f $viewDict
    puts $f ""

    puts $f "# Link views"
    SaveLinkViews $f $viewDict
    puts $f ""

    puts $f "# Put views in cursors"
    SaveCursorViews $f $viewDict
    puts $f ""

    puts $f "# Put axis label into views"
    puts $f ""

    puts $f "# Insert mappings into views"
    puts $f "# format: DEVise insertMapping viewName gdataName"
    SaveAllViewMappings $f $mapDict $viewDict 
    puts $f ""

    puts $f "# Insert views into windows"
    puts $f "# format: DEVise insertWindow viewName winName"
    SaveAllWindowViews $f $viewDict
    puts $f ""

    puts $f "# Init history of view"
    set viewSet [ViewSet]
    foreach view $viewSet {
	set viewVar [DictLookup $viewDict $view]
	puts $f "DEVise clearViewHistory \$$viewVar"
	if ($asTemplate) {
	    continue
	}
	set historyList [DEVise getVisualFilters $view]
	foreach hist $historyList {
	    puts $f "DEVise insertViewHistory \$$viewVar {[lindex $hist 0]} {[lindex $hist 1]} {[lindex $hist 2]} {[lindex $hist 3]} {[lindex $hist 4]}"
	}
    }

    if { $mode == 1 } {
        puts $f ""
	puts $f "# Display mode"
	puts $f "DEVise changeMode 1"
    }

    if {$asTemplate} {
        puts $f ""
	puts $f "return 1"
	ChangeStatus 0
	close $f
	return
    }

    # Save pixmaps 
    set bitmapFile $infile.pixmap
    if { [ file exists $bitmapFile ] } {
	if { ! [ file writable $bitmapFile ] } {
	    set but [ dialog .saveError "File $bitmapFile not writable" \
		    "" 0 OK ]
	    ChangeStatus 0
	    return
	}
    }

    set bitF [DEVise open $bitmapFile wb]
    set date [DEVise date]
    DEVise writeLine $date $bitF
    set savedCurView $curView
    ProcessViewSelected ""

    puts $f ""
    puts $f "# Load pixmaps from views"
    puts $f "set pixmapName $bitmapFile"
    puts $f "if \{ !\$template && \[ file exists \$pixmapName \] \} \{"
    puts $f "	set pixmapFile \[ DEVise open \$pixmapName rb \]"
    puts $f "	set fileDate \[ DEVise readLine \$pixmapFile \]"
    puts $f "	set sessionDate \{$date\}"
    puts $f "	if \{\$fileDate == \$sessionDate\} \{ "
    set viewSet [ViewSet]
    foreach view $viewSet {
	DEVise savePixmap $view $bitF
	puts $f "		DEVise loadPixmap \{$view\} \$pixmapFile"
    }
    puts $f "	\}"
    puts $f "	DEVise close \$pixmapFile"
    puts $f "\}"
    DEVise close $bitF

    ProcessViewSelected $savedCurView

    puts $f ""
    puts $f "return 1"

    ChangeStatus 0
    close $f
}

proc DoSave {} {
    global sessionName

    if {$sessionName == ""} {
	DoSaveAs 0
	return
    }

    DoActualSave $sessionName 0
}

proc DoSaveAs { asTemplate } {
    global sessionName fsBox sessiondir

    # Get file name
    set fsBox(path) $sessiondir
    set fsBox(pattern) *.tk
    set file [ FSBox ]
    
    if {$file == ""} { return }

    set button [ dialog .saveSession "saveSession" \
	    "Save session to file\n$file?"  "" 1  {Cancel} OK ]
    if {$button != 1} { return }

    DoActualSave $file $asTemplate
    if {!$asTemplate} {
	set sessionName $file
    }
}

# read .rc file
# we check the following in sequence:
# 1) if environment variable touuper($argv0)_RC exists, use it.
#	example: if progran name == afsio, check if environment AFSIO_RC
# 2) next, check .$argv0_rc
#	example: .afsio_rc
# 3) next, check $argv0_rc
#  example: afsio.rc

set progName [ file tail $argv0 ]
set envName [ format "%s_RC" [string toupper $progName] ]
set rcFile1 [ format ".%s_rc" $progName ]
set rcFile2 [ format "%s.rc" $progName ]

if { [ info exists env($envName)] && [file exists env$(envName) ] } {
    set rcFile env($envName)
} elseif { [ file exists  $rcFile1 ] } {
    set rcFile $rcFile1
} elseif { [file exists $rcFile2 ] } {
    set rcFile $rcFile2
} else {
    set rcFile ""
}

if {$rcFile != ""} {
    puts "Reading initialization from $rcFile"
    source $rcFile
}

# Refresh all views
proc RefreshAllViews {} {
    set classes [ DEVise get "view" ]
    foreach class $classes {
	set instances [ DEVise get "view" $class ]
	foreach inst $instances {
	    DEVise refreshView $inst
	}
    }
}

# Change mode
proc ChangeMode {} {
    global mode
    if { $mode == 0 } {
	set mode 1
	.status.left.mode configure -text "layout mode"
    } else {
	set mode 0
	.status.left.mode configure -text "display mode"
	# RefreshAllViews
    }
    DEVise changeMode $mode
}

# change status display
proc ChangeStatus { status } {
    global LightBlue red
    if { $status == 0 } {
	# .status.right configure -background LightGray
	.status.right.stat_msg configure -bitmap questhead  \
		-bg LightBlue
    } else {
	.status.right.stat_msg configure -bitmap hourglass \
		-background red
	# .status.right configure -background red
    }
}

#**************************************************************
# View Processing
#**************************************************************

proc ProcessViewCreated { view } {
}

proc ProcessViewDestroyed { view } {
}

# Process view selected 
proc ProcessViewSelected { view } {
    global curView lastView historyWinOpened

    if {$view == $curView} {
	return
    } else {
	set lastView $curView
    }

    if {$curView != ""} {
	# unhighlight old view
	DEVise highlightView $curView 0
    }

    set curView $view
    .viewFrame.viewName configure -text $curView

    ClearHistory

    if {$curView == ""} {
	return
    }

    # highlight new view
    DEVise highlightView $curView 1

    set filters [DEVise getVisualFilters $curView]
    # puts "setting filter $curView $filters"
    foreach filter $filters { 
	ProcessViewFilterChange $curView -1 \
		[lindex $filter 0] [lindex $filter 1] \
		[lindex $filter 2] [lindex $filter 3] [lindex $filter 4]
    }
}

# Process filter changed in a view
proc ProcessViewFilterChange { view flushed xLow yLow xHigh yHigh marked} {
    # puts "ProcessViewFilterChange { $view $flushed $xLow \
    #    $yLow $xHigh $yHigh $marked}" 
    global curView historyWinOpened

    if {$view != $curView} {
	return
    }

    # Change the control panel's entry box
    foreach i { xlow ylow xhigh yhigh} {
	.history.$i delete 0 end
    }
    .history.xlow insert 0 $xLow
    .history.ylow insert 0 $yLow
    .history.xhigh insert 0 $xHigh
    .history.yhigh insert 0 $yHigh

    if {$historyWinOpened} {
	if {$flushed >= 0} {
	    # Remove last in the list 
	    foreach i { listMark listXlow listXhigh listYlow listYhigh } {
		set size [.historyWin.$i size]
		.historyWin.$i delete [expr $size-$flushed-1]
	    }
	}

	# Insert new filter 
	.historyWin.listXlow insert 0 $xLow
	.historyWin.listXhigh insert 0 $xHigh
	.historyWin.listYlow insert 0 $yLow
	.historyWin.listYhigh insert 0 $yHigh
	if {$marked} {
	    .historyWin.listMark insert 0 "*"
	} else {
	    .historyWin.listMark insert 0 " "
	}
    }
}

proc ProcessMarkSelected { sel } {
    global curView
    set mark [.historyWin.listMark get $sel]
    if {$mark == "*"} {
	set newMark " "
	set newVal 0
    } else {
	set newMark "*"
	set newVal 1
    }
    set index [expr [.historyWin.listMark size]-$sel-1]
    DEVise markViewFilter $curView $index $newVal
    .historyWin.listMark delete $sel
    .historyWin.listMark insert $sel $newMark
}

proc ProcessHistorySelected { sel } {
    foreach i { xlow ylow xhigh yhigh } {
	.history.$i delete 0 end
    }

    .history.xlow  insert 0 [.historyWin.listXlow get $sel]
    .history.ylow  insert 0 [.historyWin.listYlow get $sel]
    .history.xhigh insert 0 [.historyWin.listXhigh get $sel]
    .history.yhigh insert 0 [.historyWin.listYhigh get $sel]
}

# Process "use" button pressed
proc ProcessUseButton {} {
    global curView
    set xlow [DEVise parseDateFloat [.history.xlow get ]]
    set ylow [DEVise parseDateFloat [.history.ylow get ]]
    set xhigh [DEVise parseDateFloat [.history.xhigh get ]]
    set yhigh [DEVise parseDateFloat [.history.yhigh get ]]
    if {$curView == ""} {
	return
    }

    if { ($xlow >= $xhigh ) || ($ylow >= $yhigh)} {
	set but [dialog .useError "UseError" \
		"VisualFilter xlow($xlow) >= xhigh($xhigh)\n\
		or ylow($ylow)>=yhigh($yhigh)" \
		"" 0 {Cancel} ]
    } else {
	DEVise setFilter $curView $xlow $ylow $xhigh $yhigh
    }
}

proc ProcessLeftButton {} {
    global curView left_amount
    if {$curView == ""} {
	return
    }
    set filter [DEVise getCurVisualFilter $curView ]

    if { $left_amount <= 0.0 } {
	set but [dialog .leftError "ScrollLeftError" \
		"Can't scroll left $left_amount screen (should be > 0.0)" \
		"" 0 {Cancel}  ]
	return
    }
    set xlow [lindex $filter 0 ]
    set ylow [lindex $filter 1 ]
    set xhigh [lindex $filter 2 ]
    set yhigh [lindex $filter 3 ]

    set width [expr $xhigh-$xlow]
    set scrollAmount [expr $width*$left_amount]
    set xlow [expr $xlow+$scrollAmount]
    set xhigh [expr $xhigh+$scrollAmount]
    
    DEVise setFilter $curView $xlow $ylow $xhigh $yhigh
}

proc ProcessRightButton {} { 
    global curView right_amount
    if {$curView == ""} {
	return
    }
    set filter [DEVise getCurVisualFilter $curView ]

    if { $right_amount <= 0.0 } {
	set but [dialog .rightError "ScrollRightError" \
		"Can't scroll right $right_amount screen (should be > 0.0)" \
		"" 0 {Cancel}  ]
	return
    }
    set xlow [lindex $filter 0 ]
    set ylow [lindex $filter 1 ]
    set xhigh [lindex $filter 2 ]
    set yhigh [lindex $filter 3 ]
    
    set width [expr $xhigh-$xlow]
    set scrollAmount [expr $width*$right_amount]
    set xlow [expr $xlow-$scrollAmount]
    set xhigh [expr $xhigh-$scrollAmount]
    
    DEVise setFilter $curView $xlow $ylow $xhigh $yhigh
}

proc ProcessUpButton {} { 
    global curView up_amount
    if {$curView == ""} {
	return
    }
    set filter [DEVise getCurVisualFilter $curView ]
    
    if { $up_amount <= 0.0 } {
	set but [dialog .upError "ScrollUpError" \
		"Can't scroll up $up_amount screen (should be > 0.0)" \
		"" 0 {Cancel}  ]
	return
    }
    set xlow [lindex $filter 0 ]
    set ylow [lindex $filter 1 ]
    set xhigh [lindex $filter 2 ]
    set yhigh [lindex $filter 3 ]
    
    set height [expr $yhigh-$ylow]
    set scrollAmount [expr $height*$up_amount]
    set ylow [expr $ylow-$scrollAmount]
    set yhigh [expr $yhigh-$scrollAmount]
    
    DEVise setFilter $curView $xlow $ylow $xhigh $yhigh
}

proc ProcessDownButton {} {
    global curView down_amount
    if {$curView == ""} {
	return
    }
    set filter [DEVise getCurVisualFilter $curView ]
    
    if { $down_amount <= 0.0 } {
	set but [dialog .downError "ScrollDownError" \
		"Can't scroll down $up_amount screen (should be > 0.0)" \
		"" 0 {Cancel}  ]
	return
    }
    set xlow [lindex $filter 0 ]
    set ylow [lindex $filter 1 ]
    set xhigh [lindex $filter 2 ]
    set yhigh [lindex $filter 3 ]
    
    set height [expr $yhigh-$ylow]
    set scrollAmount [expr $height*$down_amount]
    set ylow [expr $ylow+$scrollAmount]
    set yhigh [expr $yhigh+$scrollAmount]
    
    DEVise setFilter $curView $xlow $ylow $xhigh $yhigh
}

proc ProcessInButton {} {
    global curView in_amount
    if {$curView == ""} {
	return
    }
    set filter [DEVise getCurVisualFilter $curView ]
    
    if { $in_amount <= 0.0 || $in_amount >= 1.0 } {
	set but [dialog .inError "ZoomInError" \
		"Can't Zoom in $in_amount screen (should be < 1.0 and > 0.0)" \
		"" 0 {Cancel}  ]
	return
    }
    set xlow [lindex $filter 0 ]
    set ylow [lindex $filter 1 ]
    set xhigh [lindex $filter 2 ]
    set yhigh [lindex $filter 3 ]
    
    set width [expr $xhigh-$xlow]
    set scrollAmount [expr $width*$in_amount]
    set mid [ expr ($xhigh+$xlow)/2.0]
    set xlow [expr $mid - ($scrollAmount/2.0) ]
    set xhigh [expr $xlow+$scrollAmount]
    
    DEVise setFilter $curView $xlow $ylow $xhigh $yhigh
}

proc ProcessYInButton {} {
    global curView in_amount
    if {$curView == ""} {
	return
    }
    set filter [DEVise getCurVisualFilter $curView ]
    
    if { $in_amount <= 0.0 || $in_amount >= 1.0 } {
	set but [dialog .inError "ZoomInError" \
		"Can't Zoom in $in_amount screen (should be < 1.0 and > 0.0)" \
		"" 0 {Cancel}  ]
	return
    }
    set xlow [lindex $filter 0 ]
    set ylow [lindex $filter 1 ]
    set xhigh [lindex $filter 2 ]
    set yhigh [lindex $filter 3 ]
    
    set width [expr $yhigh-$ylow]
    set scrollAmount [expr $width*$in_amount]
    set mid [ expr ($yhigh+$ylow)/2.0]
    set ylow [expr $mid - ($scrollAmount/2.0) ]
    set yhigh [expr $ylow+$scrollAmount]
    
    DEVise setFilter $curView $xlow $ylow $xhigh $yhigh
}

proc ProcessOutButton {} { 
    global curView out_amount
    if {$curView == ""} {
	return
    }
    set filter [DEVise getCurVisualFilter $curView ]
    
    if { $out_amount <= 1.0  } {
	set but [dialog .outError "ZoomOutError" \
		"Can't Zoom out $out_amount screen (should be > 1.0)" \
		"" 0 {Cancel}  ]
	return
    }
    set xlow [lindex $filter 0 ]
    set ylow [lindex $filter 1 ]
    set xhigh [lindex $filter 2 ]
    set yhigh [lindex $filter 3 ]
    
    set width [expr $xhigh-$xlow]
    set scrollAmount [expr $width*$out_amount]
    set mid [ expr ($xhigh+$xlow)/2.0]
    set xlow [expr $mid - ($scrollAmount/2.0) ]
    set xhigh [expr $xlow+$scrollAmount]
    
    DEVise setFilter $curView $xlow $ylow $xhigh $yhigh
}
proc ProcessYOutButton {} { 
    global curView out_amount
    if {$curView == ""} {
	return
    }
    set filter [DEVise getCurVisualFilter $curView ]
    
    if { $out_amount <= 1.0  } {
	set but [dialog .outError "ZoomOutError" \
		"Can't Zoom out $out_amount screen (should be > 1.0)" \
		"" 0 {Cancel}  ]
	return
    }
    set xlow [lindex $filter 0 ]
    set ylow [lindex $filter 1 ]
    set xhigh [lindex $filter 2 ]
    set yhigh [lindex $filter 3 ]
    
    set width [expr $yhigh-$ylow]
    set scrollAmount [expr $width*$out_amount]
    set mid [ expr ($yhigh+$ylow)/2.0]
    set ylow [expr $mid - ($scrollAmount/2.0) ]
    set yhigh [expr $ylow+$scrollAmount]
    
    DEVise setFilter $curView $xlow $ylow $xhigh $yhigh
}

# Do editing for mapping
proc DoEditMapping {} {
    global dialogParamVar dialogListVar DEViseColors DEViseShapes curView
    if {$curView == ""} {
	dialog .editMapping "Edit Mapping" \
		"Select a view first by clicking in it." "" 0 { OK } 
	return
    }

    # Get mapping for the view
    set map [lindex [DEVise getViewMappings $curView] 0]
    
    # Find all interpreted mapping
    set maps [InterpretedGData ]
    if {$maps == ""} {
	dialog .editError "EditMappingError" \
		"No Interpreted Mapping" "" 0 OK
	return
    }
    
    # See if map is interpreted
    set found 0
    foreach m $maps {
	if {$m == $map} {
	    set found 1
	    break
	}
    }
    if {!$found} {
	dialog .editError "EditMappingError" \
		"Selected view does not contain interpreted mapping" \
		"" 0 {Continue} 
	return
    }
    
    # Get parameters for the mapping
    set params [DEVise getInstParam $map]
    if {$params == ""} {
	dialog .editError "EditMappingError" \
		"No parameter for this mapping" "" 0 OK
	return
    }

    # puts "got params $params"
    set xParm [lindex [lindex $params 3] 1]
    set yParm [lindex [lindex $params 4] 1]
    set colorParm [lindex [lindex $params 5] 1]
    set orientParm [lindex [lindex $params 6] 1]
    set sizeParm [lindex [lindex $params 7] 1]
    set patternParm [lindex [lindex $params 8] 1]
    set shapeParm [lindex [lindex $params 9] 1]
    set shapeAttr0 [lindex [lindex $params 10] 1]
    set shapeAttr1 [lindex [lindex $params 11] 1]

    set tdata [lindex [lindex $params 0] 1]
    set simpleAttrs [lsort [ElimStringAttr [DEVise getSchema $tdata]]]
    set simpleAttrs [DropAttrTypes $simpleAttrs]

    # set attrs [DEVise getSchema $tdata]
    set parm [dialogMapping .editMapping "Edit Mapping" \
	    "Edit Mapping" ""   \
	    $simpleAttrs \
	    [list \
	    [list X {1 2 3 4 5 6 7 8 9 10} $xParm] \
	    [list Y {1 2 3 4 5 6 7 8 9 10} $yParm] \
	    [list Color $DEViseColors $colorParm] \
	    [list Orientation {0} $orientParm] \
	    [list Size {1 2 3 4} $sizeParm] \
	    [list Pattern {0} $patternParm] \
	    [list Shape $DEViseShapes $shapeParm] \
	    [list "SymbolWidth" {0.1 0.5 1 2} $shapeAttr0] \
	    [list "SymbolHeight" {0.1 0.5 1 2} $shapeAttr1] \
	    ] 0 ]
    
    # puts "dialogMapping returns $parm"
    if {$parm == ""} {
	return
    }

    # extract parameters
    set params [list [lindex [lindex $params 0] 1] \
	    [lindex [lindex $params 1] 1] \
	    [lindex [lindex $params 2] 1] \
	    [lindex $parm 0] \
	    [lindex $parm 1] \
	    [lindex $parm 2] \
	    [lindex $parm 3] \
	    [lindex $parm 4] \
	    [lindex $parm 5] \
	    [lindex $parm 6] \
	    [lindex $parm 7] \
	    [lindex $parm 8] ]

    # Change parameter
    set cmd "DEVise changeParam \{$map\} $params"
    # puts "ChangeParam $map $params"
    set result [eval $cmd]
    
    # Refresh all views that use this mapping
    set views [ViewSet]
    foreach view $views {
	set mappings [DEVise getViewMappings $view]
	set contains 0
	foreach m $mappings {
	    if {$m == $map} {
		set contains 1
		break
	    }
	}
	if {$contains > 0} {
	    # puts "refreshView $view"
	    DEVise invalidatePixmap $view
	    DEVise refreshView $view
	}
    }
}

# Create a Cursor, return its name
proc DoCursorCreate {} {
    global dialogCkButVar 

    set but [dialogCkBut .createCursor "Create Cursor" \
	    "Enter parameters for creating a new cursor" "" \
	    0 {Cancel OK} name {x y} {3}]
    if { $but != 1 } {
	return ""
    }
    set flag $dialogCkButVar(selected)
    set name $dialogCkButVar(entry)
    if {$name == ""} {
	set but [dialog .noName "NoName" \
		"Error: No name for cursor specified" "" 0 {Continue }]
	return 
    }

    if { [DEVise exists $name ] } {
	set but [dialog .linkExists "LinkExists" \
		"Error: Cursor name $name already exists" "" 0 {Continue }]
	return 
    }

    set result [DEVise create cursor Cursor $name $flag]
    if {$result == ""} {
	set but [ dialog .cursorError "CursorError" \
		"Can't create cursor" "" 0 OK ]
	return
    }

    return $name
}

proc DoGetCursor {} {
    global curView dialogListVar

    set cursorSet [CursorSet]
    if { [llength $cursorSet] == 0 } {
	set cursor [DoCursorCreate]
    } else {
	set answer [ dialogList .getCursor "GetCursor" "Select cursor for\
		view\n$curView" "" 0 \
		{ New Cancel OK } $cursorSet ]
	if { $answer == 0 } {
	    set cursor [ DoCursorCreate ]
	} elseif {$answer == 1 || $dialogListVar(selected) == ""} {
	    set cursor ""
	} else {
	    set cursor $dialogListVar(selected)
	}
    }

    return $cursor
}


proc DoSetCursorSrc {} {
    global curView dialogListVar

    if {$curView == ""} {
	set but [dialog .cursorError "No Current View" \
		"Select a view first by clicking in it." "" 0 OK ]
	return
    }

    set cursor [DoGetCursor]
    if {$cursor == ""} {
	return
    }

    set answer [DEVise setCursorSrc $cursor $curView]
}

proc DoSetCursorDst {} {
    global curView dialogListVar

    if {$curView == ""} {
	set but [dialog .cursorError "No Current View " \
		"Select a view first by clicking in it." "" 0 OK ]
	return
    }
    
    set cursor [DoGetCursor]
    if {$cursor == ""} {
	return
    }
    
    set answer [DEVise setCursorDst $cursor $curView]
}

# Create a link, return its name
proc DoLinkCreate {} {
    global dialogCkButVar 

    set but [dialogCkBut .createLink "Create Link" \
	    "Enter parameters for creating a new link" "" \
	    0 {Cancel OK} name {x y color size pattern orientation shape} {3}]
    if { $but != 1 } {
	return ""
    }

    set flag $dialogCkButVar(selected)
    set name $dialogCkButVar(entry)
    if {$name == ""} {
	set but [dialog .noName "NoName" \
		"Error: No name for link specified" "" 0 {Continue }]
	return 
    }
    
    if { [DEVise exists $name ] } {
	set but [dialog .linkExists "LinkExists" \
		"Error: Link name $name already exists" "" 0 {Continue }]
	return 
    }

    set result [DEVise create link Visual_Link $name $flag]
    if {$result == ""} {
	set but [ dialog .linkError "LinkError" \
		"Can't create link" "" 0 OK ]
	return
    }

    return $name
}

# Display the views in a link 
proc DisplayLinkInfo { link } {
    set views [DEVise getLinkViews $link]
    if { [llength $views] == 0 } {
	dialog .linkInfo "LinkInfo" \
		"Link $link currently does not link any view" "" 0 OK ]
	return
    }
    dialogList .linkInfo "LinkInfo" "Views linked by $link" "" 0 OK $views
}

# Link current view
proc DoViewLink {} {
    global curView dialogListVar

    if {$curView == ""} {
	set but [dialog .linkError "No Current View" \
		"Select a view first by clicking in it." "" 0 OK ]
	return
    }

    while { 1 } {
	set linkSet [LinkSet]
	if { [llength $linkSet] == 0 } {
	    set link [DoLinkCreate]
	} else {
	    set answer [ dialogList .getLink "GetLink" "Select a link for\
		    view\n$curView" "" 0 \
		    { Info New Cancel OK } $linkSet ]
	    if { $answer == 0 } {
		if {$dialogListVar(selected) != ""} {
		    DisplayLinkInfo $dialogListVar(selected)
		}
	    } elseif { $answer == 1 } {
		set link [ DoLinkCreate ]
	    } elseif {$answer == 2 || $dialogListVar(selected) == ""} {
		set link ""
		break
	    } else {
		set link $dialogListVar(selected)
		break
	    }
	}
    }

    if {$link == ""} {
	return
    }

    set anwer [DEVise insertLink $link $curView]
    # if {$anwer != 0 } {
	# set but [ dialog .linkError "LinkError" \
		# "Can't insert view $curView into link $link" "" 0 OK ]
    #}
}

# Unlink current view
proc DoViewUnlink {} {
    global curView dialogListVar
    if { [ string compare $curView "" ] ==  0 } {
	set but [dialog .unlinkError "No Current View" \
		"Select a view first by clicking in it." "" 0 OK ]
	return
    }

    set linkSet [LinkSet]
    set viewLinks ""
    foreach link $linkSet {
	if { [DEVise viewInLink $link $curView] } {
	    lappend viewLinks $link
	}
    }

    if { [llength $viewLinks ] == 0 } {
	set but [ dialog .removeLink "RemoveLink" \
		"View $curView has no established link" "" 0 OK ]
    } else {
	set answer [ dialogList .getLink "GetLink" \
		"Select a link to unlink for view $curView" "" 0 \
		{ Cancel OK } $linkSet ]
	if { $answer == 0 } {
	    return
	} elseif { [ string compare $dialogListVar(selected) "" ] == 0 } {
	    return
	} else {
	    DEVise unlinkView $dialogListVar(selected) $curView
	}
    }
}

# Modify parameters of a link
proc DoModifyLink {} {
    global dialogCkButVar dialogListVar
    set linkSet [LinkSet]
    if { [llength $linkSet ] == 0 } {
	set but [dialog .linkModError "LinkModError" \
		"No link has been created yet" "" 0 OK ]
	return
    }
    
    # Select a link
    set answer [ dialogList .getLink "GetLink" \
	    "Select a link to modify param" "" 0 \
	    { Cancel OK } $linkSet ]
    if { $answer == 0 } {
	return
    } elseif { [ string compare $dialogListVar(selected) "" ] == 0 } {
	return
    } else {
	set link $dialogListVar(selected)
    }

    # enter parameters for the link
    set flag [DEVise getLinkFlag $link]
    set but [dialogCkBut .modLink "Modify Link" \
	    "Enter parameters for link $link" "" \
	    0 {Cancel OK} "" {x y color size pattern orientation shape} $flag]
    if { $but != 1 } {
	return ""
    }
    set flag $dialogCkButVar(selected)
    DEVise setLinkFlag $link $flag
}

proc CheckView {} {
    global curView
    if { [ string compare $curView "" ] ==  0 } {
	set but [dialog .viewError "No Current View" \
		"Select a view first by clicking in it." "" 0 OK ]
	return 0
    }
    return 1
}

# Actually create a new axis Label
proc DoActualCreateAxisLabel { type } {
    global dialogParamVar 
    set paramNames [ DEVise getparam axisLabel $type]
    
    set button [ dialogParam .axisParam "AxisParam" \
	    "Enter parameters to create axis $type"\
	    "" 1 { Cancel OK } $paramNames ]
    if { $button == 0} {
	return
    }

    set cmd "DEVise create axisLabel $type $dialogParamVar(params)"
    set result [ eval $cmd ]
    if { $result == "" } {
	set but [ dialog .axisError "AxisError" \
		"Can't create axis" "" 0 OK ]
	return
    }

    return $result
}

# Create a new axis label
proc DoCreateAxisLabel {} {
    global dialogListVar
    set axisTypes [ DEVise get axisLabel]

    if {![llength $axisTypes]} {
	dialog .noAxisTypes "No Axis Types Defined" \
		"No axis types have been defined." "" 0 OK
	return ""
    }

    set answer [ dialogList .createAxis "CreateAxis"  \
	    "Select type of axis label to create" "" "" \
	    { Cancel Ok } $axisTypes ]
    if { $answer == 0 || $dialogListVar(selected) == "" } {
	return ""
    }

    return [ DoActualCreateAxisLabel $dialogListVar(selected) ]
}

# Get an axis label for current view
proc DoGetAxisLabel {} {
    global curView dialogListVar
    set axisSet [AxisSet]
    if { [llength $axisSet] == 0 } {
	set axisLabel [DoCreateAxisLabel]
    } else {
	set answer [ dialogList .getAxisLabel "Select Axis Label" \
		"Select an axis label for current view."\
		"" 0 { New Cancel OK } $axisSet ]
	if { $answer == 0 } {
	    set axisLabel [ DoCreateAxisLabel ]
	} elseif { $answer == 1 || \
		[ string compare $dialogListVar(selected) "" ] == 0 } {
	    set axisLabel ""
	} else {
	    set axisLabel $dialogListVar(selected)
	}
    }

    return $axisLabel
}

proc DoViewAxis { axis } {
    global curView
    if { ! [CheckView] } {
	return
    }
    set axisLabel [DoGetAxisLabel]
    if {$axisLabel == ""} {
	return
    }
    
    DEVise setAxis $curView $axisLabel $axis
}

proc DoActualCreateAction { type } {
    global dialogParamVar 
    set paramNames [ DEVise getparam action $type]
    
    set button [ dialogParam .actionParam "ActionParam" \
	    "Enter parameters to create action $type"\
	    "" 1 { Cancel OK } $paramNames ]
    if { $button == 0} {
	return
    }
    
    set cmd "DEVise create action $type $dialogParamVar(params)"
    set result [eval $cmd ]
    if { [string compare $result "" ] == 0 } {
	set but [ dialog .actionError "ActionError" \
		"Can't create action" "" 0 OK ]
	return
    }
    return $result
}

# Create an action
proc DoCreateAction {} {
    global dialogListVar
    set actionTypes [ DEVise get action]
    set answer [ dialogList .createAction "CreateAction"  \
	    "Select type of action to create" "" "" { Cancel Ok } $actionTypes]
    if { $answer == 0 || \
	    [ string compare $dialogListVar(selected) "" ] == 0 } {
	return
    } else {
	return [ DoActualCreateAction $dialogListVar(selected) ]
    }
}

# Get an action
proc DoGetAction {} {
    global curView dialogListVar
    set actionSet [ActionSet ]
    if { [llength $actionSet] == 0 } {
	set action [ DoCreateAction]
    } else {
	set answer [dialogList .getAction "GetAction" "Select an \
		action for view\n$curView"\
		"" 0 { New Cancel OK } $actionSet]
	if { $answer == 0 } {
	    set action [ DoCreateAction]
	} elseif { $answer == 1 || \
		[ string compare $dialogListVar(selected) "" ] == 0 } {
	    set action ""
	} else {
	    set action $dialogListVar(selected)
	}
    }
    return $action
}

# Add an action for view
proc DoViewAction {} {
    global curView
    if { ! [CheckView] } {
	return
    }
    set action [DoGetAction]
    if {$action == ""} {
	return
    }
    
    DEVise setAction $curView $action
}

# Close current session
proc DoClose {} {
    set but [dialog .open OpenSession "Close Current Session?" \
	    "" 1 Cancel Ok ]
    if { $but == 0 } {
	return 0
    }
    
    ProcessViewSelected ""
	
    foreach tdata [TdataSet] {
	# puts "destroying tdata $tdata"
	DEVise destroy $tdata
    }
    
    foreach gdata [GdataSet] {
	# puts "destroying gdata $gdata"
	DEVise destroy $gdata
    }
    
    foreach cursor [CursorSet] {
	DEVise destroy $cursor
    }
    
    foreach view [ViewSet] {
	# puts "destroying view $view"
	DEVise destroy $view
    }

    foreach link [LinkSet] {
	# puts "destroying link $link"
	DEVise destroy $link
    }
    
    foreach win [WinSet] {
	# puts "destroying window $win"
	DEVise destroy $win
    }
    
    foreach axis [AxisSet] {
	# puts "destroying axis $axis"
	DEVise destroy $axis
    }

    foreach action [ActionSet ] {
	# puts "destroying action $action"
	DEVise destroy $action
    }

    DEVise clearQP
    DEVise clearInterp
    
    return 1
}

# Do open a session file
proc DoOpen { asTemplate } {
    global fsBox sessiondir

    if {[DEVise get tdata] != "" && ![DoClose]} {
	# abort opening a new session
	return
    }
    
    # Get a session file name
    set fsBox(path) $sessiondir
    set fsBox(pattern) *.tk
    set file [ FSBox "Select session file" ]
    
    if {$file == ""} {
	return
    }

    if {$asTemplate} {
	DEVise openTemplate $file
    } else {
	DEVise openSession $file
    }
}

proc DoDemo {} {
    global libdir fsBox
    set fsBox(path) $libdir/demo
    DoOpen 0
}

# Return line width of string. New lines are accounted for.
# For example, "abc\ndefg" has a line width of 4
proc LineWidth { txt } {
    set strLen [string length $txt]
    set width 0
    set curWidth 0
    for { set i 0} { $i < $strLen } {set i [expr $i+1] } {
	if { [string compare [string index $txt $i] \n] == 0 } {
	    if {$curWidth > $width} {
		set width $curWidth
	    }
	    set curWidth 0
	} else {
	    set curWidth [expr $curWidth+1]
	}
    }
    if {$curWidth > $width} {
	set width $curWidth
    }
    return $width
}

# Return # of lines in string 
# For example, "abc\ndefg" has 2 lines
proc LineHeight { txt } {
    set strLen [string length $txt]
    set height 0
    for { set i 0} { $i < $strLen } {set i [expr $i+1] } {
	if { [string compare [string index $txt $i] \n] == 0 } {
	    set height [expr $height+1]
	}
    }
    set height [expr $height+1]
    return $height
}

# Find a view that uses the specified TData, the mapping class, and
# the specified viewClass.
proc GetView { tdata mapClass viewClass } {
    set views [DEVise get view $viewClass]
    foreach view $views {
	if { ![DEVise isMapped $view] } {
	    # view not yet mapped, see if we can use it.
	    set map [lindex [DEVise getViewMappings $view] 0]
	    set viewMapClass [GetClass mapping $map]
	    set mapParam [DEVise getCreateParam mapping $mapClass $map]
	    set viewTData [lindex $mapParam 0]
	    if {[string compare $mapClass $viewMapClass] == 0 && \
		    [string compare $viewTData $tdata] == 0 } {
		# found
		return $view
	    }
	}
    }

    # not found
    return ""
}

# Find a mapping (GData)that uses the specified TData, and the mapping class
proc GetMapping { tdata mapClass} {
    set maps [DEVise get mapping $mapClass]
    foreach map $maps {
	set mapParam [DEVise getCreateParam mapping $mapClass $map]
	set viewTData [lindex $mapParam 0]
	if {[string compare $viewTData $tdata] == 0 } {
	    # found
	    return $map
	}
    }

    # not found
    return ""
}

# Switch to a different TData for current view.
# We implement it by creating a new view and putting it it place
# of the current one
proc DoSwitchTData {} {
    global curView
    if { [string compare $curView ""] == 0 } {
	dialog .switchTData "Switch TData" \
		"Select a view by clicking in it first." "" 0 { OK } 
	return
    }
    
    # select TData
    set tdata [DoSelectTData]
    if { [string compare $tdata "" ] == 0} {
	# no tdata
	return
    }
    
    # Get mapping for the view
    set map [lindex [DEVise getViewMappings $curView] 0]
    
    # Compare the schema of the tdata
    set curMapClass [GetClass mapping $map]
    puts "curMapClass $curMapClass tdata $tdata"
    set curMapParam [DEVise getCreateParam mapping $curMapClass $map]
    set curViewTData [lindex $curMapParam 0]
    
    if { [string compare $curViewTData $tdata] == 0 } {
	dialog .switchTDataErr "Switch TData" \
		"You have selected the same tdata" "" 0 { continue }
	return
    }
    
    set viewTDataClass [GetClass tdata $curViewTData]
    set tdataClass [GetClass tdata $tdata]
    if { [string compare $viewTDataClass $tdataClass ] != 0 } {
	dialog .switchTDataErr "Switch TData" \
		"The selected TData has type $tdataClass,\n\
		incompatible with the tdata in the view" "" 0 { OK } 
	return
    }
    
    # See if the new view is already created.
    set view [GetView $tdata $curMapClass [GetClass view $curView]]
    if { [string compare $view "" ] == 0 } {
	# need to create a new view
	# First, see if we need to create a new GData
	set mapName [GetMapping $tdata $curMapClass]
	if { [string compare $mapName "" ] == 0 } { 
	    # create a new mapping.
	    set mapName [UniqueName [format "%s#%s" $tdata $curMapClass]]
	    set newMapParam [linsert [lrange $curMapParam 2 end] 0 $tdata \
		    $mapName]
	    set cmd "DEVise create mapping $curMapClass $newMapParam"
	    set result [eval $cmd]
	    if { [string compare $result "" ] == 0 } {
		set but [ dialog .CreateError "Can't create mapping" \
			"" 0 OK ]
		return
	    }
	}

	# Create a new view
	set curViewClass [GetClass view $curView]
	set curViewParam [DEVise getCreateParam view $curViewClass $curView]
	set view [UniqueName [format "%s#%s" $mapName $curViewClass]]
	set newViewParam [linsert [lrange $curViewParam 1 end] 0 $view]
	set cmd "DEVise create view $curViewClass $newViewParam"
	set result [eval $cmd ]
	if { [string compare $result "" ] == 0 } {
	    set but [ dialog .CreateError "Can't create view" "" 0 OK ]
	    return
	}
	DEVise insertMapping $view $mapName
    } 

    # select new view
    if { [string compare $view "" ] != 0 } {
	DEVise replaceView $curView $view
	ProcessViewSelected $view
    }
}

proc CloseHistory {} {
    global historyWinOpened
    destroy .historyWin
    set historyWinOpened 0
}

proc DoHistoryToggle {} {
    global historyWinOpened
    if { $historyWinOpened} {
	CloseHistory
    } else {
	OpenHistory
    }
}


# Do history command here.
proc OpenHistory {} {
    global curView historyWinOpened LightBlue
    
    if { $historyWinOpened } {
	return
    }
    
    set w .historyWin
    toplevel $w 
    wm title $w "DEVise history"
    wm geometry $w +100+100
    wm iconname $w "history"

    frame $w.heading -background LightBlue
    label $w.markHeading -text mark
    label $w.xlowHeading -text xlow
    label $w.xhighHeading -text xhigh
    label $w.ylowHeading -text ylow
    label $w.yhighHeading -text yhigh
    
    pack $w.markHeading -side left -in $w.heading 
    pack $w.xlowHeading $w.xhighHeading $w.ylowHeading \
	    $w.yhighHeading -side left -in $w.heading -expand 1 -fill x
    
    frame $w.lists -background LightBlue
    listbox $w.listMark -yscrollcommand "$w.scroll set" \
	    -relief raised -selectmode single -width 4
    
    foreach i { listXlow listYlow listXhigh listYhigh } {
	listbox $w.$i -yscrollcommand "$w.scroll set" \
		-relief raised -selectmode single
    }
    bind $w.listMark <Button-1> {
	set sel [.historyWin.listMark nearest %y]
	if {$sel >= 0} {
	    ProcessMarkSelected $sel
	}
    }
    
    bind $w.listXlow <Button-1> {
	set sel [.historyWin.listXlow nearest %y]
	if {$sel >= 0} {
	    ProcessHistorySelected $sel
	}
    }
    bind $w.listXhigh <Button-1> {
	set sel [.historyWin.listXhigh nearest %y]
	if {$sel >= 0} {
	    ProcessHistorySelected $sel
	}
    }
    bind $w.listYlow <Button-1> {
	set sel [.historyWin.listYlow nearest %y]
	if {$sel >= 0} {
	    ProcessHistorySelected $sel
	}
    }
    bind $w.listYhigh <Button-1> {
	set sel [.historyWin.listYhigh nearest %y]
	if {$sel >= 0} {
	    ProcessHistorySelected $sel
	}
    }
    scrollbar $w.scroll -command "DoScrollBar"
    
    button $w.close -text Close -command CloseHistory -width 10
    
    pack $w.close -side bottom
    
    pack $w.scroll -in $w.lists -side right -fill both
    pack  $w.listYhigh $w.listYlow $w.listXhigh $w.listXlow \
	    -in $w.lists -side right 
    pack $w.listMark -in $w.lists -side left 
    
    pack $w.heading $w.lists -side top -fill x -expand 1
    
    set historyWinOpened 1
    
    if { [string compare $curView "" ] != 0 } {
	# Init history with history of current view
	set filters [DEVise getVisualFilters $curView]
	foreach filter $filters {
	    .historyWin.listXlow insert 0 [lindex $filter 0]
	    .historyWin.listXhigh insert 0 [lindex $filter 2]
	    .historyWin.listYlow insert 0 [lindex $filter 1]
	    .historyWin.listYhigh insert 0 [lindex $filter 3]
	    if { [lindex $filter 4] == 0 } {
		set mark " "
	    } else {
		set mark "*"
	    }
	    .historyWin.listMark insert 0 $mark
	}
    }
}
 
# note: DoScrollBar takes variable number of arguments
proc DoScrollBar args {
    foreach i {listMark listXlow listXhigh listYlow listYhigh} {
	eval .historyWin.$i yview $args
    }
}

proc ClearHistory {} {
    global historyWinOpened
    if {$historyWinOpened} {
	foreach i {listMark listXlow listXhigh listYlow listYhigh} {
	    selection clear .historyWin.$i
	    .historyWin.$i delete 0 end
	}
    }
}

proc DoUndoEdit {} {
    global curView
    
    if { [string compare $curView "" ] == 0 } {
	return
    }
    
    set filters [DEVise getVisualFilters $curView] 
    set filter [lindex $filters [expr [llength $filters]-1]]
    
    foreach i { xlow ylow xhigh yhigh} {
	.history.$i delete 0 end
    }
    .history.xlow insert 0 [lindex $filter 0]
    .history.ylow insert 0 [lindex $filter 1]
    .history.xhigh insert 0 [lindex $filter 2]
    .history.yhigh insert 0 [lindex $filter 3]
}

proc DoGoBackOne {} {
    global curView
    
    if { [string compare $curView "" ] == 0 } {
	return
    }
    
    set filters [DEVise getVisualFilters $curView] 
    set len [llength $filters ]
    if { $len <= 1} {
	return
    }
    set filter [lindex $filters [expr $len-2]]
    
    foreach i { xlow ylow xhigh yhigh} {
	.history.$i delete 0 end
    }
    .history.xlow insert 0 [lindex $filter 0]
    .history.ylow insert 0 [lindex $filter 1]
    .history.xhigh insert 0 [lindex $filter 2]
    .history.yhigh insert 0 [lindex $filter 3]
}

# remove window
proc RemoveWindow {win} {
    global dialogListVar

    if {$win == ""} {
	set winSet [ WinSet ]
	set answer [ dialogList .window "Select Window" \
		"Select window to remove" "" "" \
		{ Cancel Ok } $winSet ]
	if {$answer == 0  || $dialogListVar(selected) == ""} {
	    return 
	}
	set win $dialogListVar(selected)
    }

    set views [DEVise getWinViews $win]
    if {$views != ""} {
	dialog .viewsInWindow "Views Still In Window" \
		"Window contains views. Remove all views first." \
		"" 0 OK
	return
    }
    
    DEVise destroy $win
}

# change layout of window
proc SetWindowLayout {win} {
    global curView layoutWin layoutOption verRequested horRequested

    if {$win == ""} {
	if {$curView == ""} {
	    dialog .changeLayout "No Current Window" \
		    "Select a window first by clicking any view in it." \
		    "" 0 { OK }
	    return
	}
	set win [DEVise getViewWin $curView]
    }

    set layoutWin $win

    # see if .setLayout window already exists; if so, just return
    set err [catch {set exists [wm state .setLayout]}]
    if {!$err} { wm deiconify .setLayout; return }

    toplevel .setLayout
    wm title .setLayout "Set Window Layout"
    wm geometry .setLayout +50+50

    frame .setLayout.top
    frame .setLayout.bot
    pack .setLayout.top -side top -pady 3m -fill both -expand 1
    pack .setLayout.bot -side top -pady 5m -fill x

    frame .setLayout.row1
    frame .setLayout.row2
    frame .setLayout.row3
    pack .setLayout.row1 .setLayout.row2 .setLayout.row3 -in .setLayout.top \
	    -side top -fill x

    frame .setLayout.bot.but
    pack .setLayout.bot.but -side top

    radiobutton .setLayout.row1.b -text Automatic -variable layoutOption \
	    -value auto -width 12 -anchor w -command {
	.setLayout.row2.e configure -state disabled
	.setLayout.row3.e configure -state disabled
    }
    pack .setLayout.row1.b -side left

    radiobutton .setLayout.row2.b -text Vertical \
	    -variable layoutOption -value fixver -width 12 -anchor w \
	    -command {
	.setLayout.row2.e configure -state normal
	.setLayout.row3.e configure -state disabled
    }
    label .setLayout.row2.l -text "Width:" -width 8
    entry .setLayout.row2.e -relief sunken -textvariable horRequested \
	    -width 5
    pack .setLayout.row2.b .setLayout.row2.l .setLayout.row2.e -side left

    radiobutton .setLayout.row3.b -text Horizontal \
	    -variable layoutOption -value fixhor -width 12 -anchor w \
	    -command {
	.setLayout.row3.e configure -state disabled
	.setLayout.row3.e configure -state normal
    }
    label .setLayout.row3.l -text "Height:" -width 8
    entry .setLayout.row3.e -relief sunken -textvariable verRequested \
	    -width 5
    pack .setLayout.row3.b .setLayout.row3.l .setLayout.row3.e -side left

    set verRequested 1
    set horRequested 1
    set layoutOption auto
    .setLayout.row2.e configure -state disabled
    .setLayout.row3.e configure -state disabled

    set layout [DEVise getWindowLayout $layoutWin]
    if {[lindex $layout 0] >= 1} {
	set layoutOption fixhor
	set verRequested [lindex $layout 0]
	.setLayout.row3.e configure -state normal
    } elseif {[lindex $layout 1] >= 1} {
	set layoutOption fixver
	set horRequested [lindex $layout 1]
	.setLayout.row2.e configure -state normal
    }
	
    button .setLayout.bot.but.ok -text OK -width 10 -command {
	if {$layoutOption == "auto"} {
	    DEVise setWindowLayout $layoutWin -1 -1
	} elseif {$layoutOption == "fixver"} {
	    if {$horRequested < 1} { set horRequested 1 }
	    DEVise setWindowLayout $layoutWin -1 $horRequested
	} else {
	    if {$verRequested < 1} { set verRequested 1 }
	    DEVise setWindowLayout $layoutWin $verRequested -1
	}
	destroy .setLayout
    }
    button .setLayout.bot.but.cancel -text Cancel -width 10 -command {
	destroy .setLayout
    }
    pack .setLayout.bot.but.ok .setLayout.bot.but.cancel -side left -padx 3m
}

# duplicate window
proc DupWindow {} {
    global curView
    if {$curView == ""} {
	set but [dialog .dupWinError "DupWindowError" \
		"Select a window by clicking any view in it." "" 0 OK ]
	return
    }
    set win [DEVise getViewWin $curView]
    set views [DEVise getWinViews $win]
    
    # Create mappings for views
    set newViews ""
    foreach view $views {
	# Crete a new view
	set class [GetClass  view $view]
	set params [DEVise getCreateParam view $class $view]
	set viewName [lindex $params 0]
	set newName [UniqueName $viewName]

	# replace name of view by name of new view
	set newParam [linsert [lrange $params 1 end] 0 $newName]
	# puts "DEVise create view $class $newParam"
	eval DEVise create view $class $newParam
	
	lappend newViews $newName
	
	set maps [DEVise getViewMappings $view]
	foreach map $maps {
	    DEVise insertMapping $newName $map
	}
    }

    # Create new window
    set class [GetClass window $win]
    set params [DEVise getCreateParam window $class $win]
    set newWin [UniqueName $win]
    set newParam [linsert [lrange $params 1 end] 0 $newWin]
    eval DEVise create window $class $newParam
    
    foreach view $newViews {
	DEVise insertWindow $view $newWin
    }
}

proc DoSetTitle {} {
    global curView newTitle

    if {$curView == ""} {
	set but [dialog .setTitleWinError "No Current View" \
		"Select a view first by clicking in it." "" 0 OK ]
	return
    }
    
    # see if .setTitle window already exists; if so, just return
    set err [catch {set exists [wm state .setTitle]}]
    if {!$err} { wm deiconify .setTitle; return }

    toplevel .setTitle
    wm title .setTitle "Set View Title"
    wm geometry .setTitle +50+50

    frame .setTitle.top
    frame .setTitle.bot
    pack .setTitle.top -side top -pady 3m -fill both -expand 1
    pack .setTitle.bot -side top -pady 5m -fill x

    frame .setTitle.bot.but
    pack .setTitle.bot.but -side top

    set viewLabelParams [DEVise getLabel $curView]
    set occupyTop [lindex $viewLabelParams 0]
    set newTitle [lindex $viewLabelParams 2]
    if {!$occupyTop && $newTitle == ""} {
	set newTitle $curView
    }

    label .setTitle.top.l1 -text "Title:"
    entry .setTitle.top.e1 -relief sunken -width 30 -textvariable newTitle
    pack .setTitle.top.l1 .setTitle.top.e1 -side left -padx 3m \
	    -fill x -expand 1

    button .setTitle.bot.but.ok -text OK -width 10 -command {
	DEVise setLabel $curView 1 16 $newTitle
	destroy .setTitle
    }
    button .setTitle.bot.but.clear -text Clear -width 10 -command {
	set newTitle ""
    }
    button .setTitle.bot.but.delete -text Delete -width 10 -command {
	DEVise setLabel $curView 0 12 ""
	destroy .setTitle
    }
    button .setTitle.bot.but.cancel -text Cancel -width 10 -command {
	destroy .setTitle
    }
    pack .setTitle.bot.but.ok .setTitle.bot.but.clear \
	    .setTitle.bot.but.delete .setTitle.bot.but.cancel \
	    -side left -padx 3m
}

proc DoToggleAxis { axis } {
    global curView
    if {$curView == ""} {
	set but [dialog .toggleWinError "No Current View" \
		"Select a view first by clicking in it." "" 0 OK ]
	return
    }
    
    set stat [DEVise getAxisDisplay $curView $axis]
    set stat [expr !$stat]
    DEVise setAxisDisplay $curView $axis $stat
}

proc DoToggleAxisAllViews { axis } {
    global curView
    if {$curView == ""} {
	set but [dialog .toggleWinError "No Current View" \
		"Select a view first by clicking in it." "" 0 OK ]
	return
    }
    
    set stat [DEVise getAxisDisplay $curView $axis]
    set stat [expr !$stat]
    
    set viewClasses [ DEVise get view ]
    foreach viewClass $viewClasses {
	set views [ DEVise get view $viewClass ]
	foreach v $views {
	    DEVise setAxisDisplay $v $axis $stat
	}
    }
}

proc DoToggleStatistics {} {
    global curView statmean statmax statmin statcurr statcilevel

    # The status is formed by as a binary string xxx where 1 means that the 
    # corr. stat is to be displayed. Further, since "count" which is the 
    # fourth stat cannot currently be displayed meaningfully on the graph
    # always append a 0.
    set statcount 0
    set stat $statmean$statmax$statmin$statcount$statcilevel

    if {$statcurr == 1} {
	if {$curView == ""} {
	    set but [dialog .toggleWinError "No Current View" \
		    "Select a view first by clicking in it." "" 0 OK ]
	return
	}
	DEVise setViewStatistics $curView $stat
	return
    }

    set viewClasses [ DEVise get view ]
    foreach viewClass $viewClasses {
	set views [ DEVise get view $viewClass ]
	foreach v $views {
	    DEVise setViewStatistics $v $stat
	}
    }
}

proc DoSwapView {} {
    global curView lastView dialogListVar
    if { [ string compare $curView "" ] ==  0  ||
    [string compare $lastView "" ] == 0 ||
    [string compare $curView $lastView] == 0 } {
	set but [dialog .swapViewError "SwapViewError" \
		"Select two views by clicking in them in order.\n\
		The views must be in the same window." "" 0 OK ]
	return
    }

    # Find all views in a window
    set win1 [DEVise getViewWin $curView]
    set win2 [DEVise getViewWin $lastView]
    if { [string  compare $win1 $win2] != 0 } {
	set but [dialog .swapViewError "SwapViewError" \
		"Select two views by clicking in them in order.\n\
		The views must be in the same window." "" 0 OK ]
	return
    }

    DEVise swapView $win1 $curView $lastView
}

proc DoSavePixmap {} {
    global curView
    if {$curView == ""} {
	set but [dialog .pixmapError "No Current View" \
		"Select a view first by clicking in it." "" 0 OK ]
	return
    }
    
    set file [DEVise open pixmap.tmp wb]
    DEVise savePixmap $curView $file
    DEVise close $file
}

proc DoLoadPixmap {} {
    global curView
    if {$curView == ""} {
	set but [dialog .pixmapError "No Current View" \
		"Select a view first by clicking in it." "" 0 OK ]
	return
    }
    
    set file [DEVise open pixmap.tmp rb]
    DEVise loadPixmap $curView $file
    DEVise close $file
}

# Get a new TData for a template
# Return name of new TData.
# input:
#	type: file type
#	total: total number of Tdata to import
#	num: number for the tdata, [1..total].
# This procedure asks user for file name, and imports it as 
# the new TData

proc GetTDataTemplate { type total num} {
    global fsBox dialogParamVar datadir

    set fsBox(path) $datadir
    set fsBox(pattern) *

    while { 1 } {
	set file [ FSBox "Select file $num of $total, type $type" ]
	if {$file == ""} {
	    return ""
	}

	if  {![FileExist $file]} {
	    break
	}
	set but [dialog .fileExist "File Exists" \
		"File $file already loaded\n\
		Please select another file" "" 0 Continue]
    }

    while { 1 } {
	set fileAlias [ file tail $file ]
	set tempParam [list [ list  FileAlias $fileAlias ] ]
	set button [ dialogParam .fileParam "FileParam" \
		"Enter Alias for file\n$file" "" 0 { OK Cancel } $tempParam]
	if {$button == 1} {
	    return ""
	}
	set fileAlias [ lindex $dialogParamVar(params) 0 ]
	
	if {![DEVise exists $fileAlias]} {
	    break
	}
	set but [dialog .fileExist "FileExist" \
		"Alias $fileAlias exists already" "" 1 {continue}]
    }

    statusWindow .info "Status" \
	    "Creating an index on $fileAlias.\n\n\
	    This may take a while."
    DEVise create tdata $type $file $fileAlias
    catch {destroy .info}

    return $fileAlias
}

############################################################

proc NotImplemented {} {
    dialog .notImplemented "Not Implemented" \
	    "This feature not implemented yet." \
	    "" 0 OK
}

############################################################

proc GetTkControlMargins {type} {
    # a view has left and bottom margin controls
    if {$type == "View"} {
	return "5 5 5 20"
    }

    # a window has bottom margin controls
    return "0 0 0 20"
}

############################################################

proc CreateTkControlWindows {name w h margins} {
    set lm [lindex $margins 0]
    set rm [lindex $margins 1]
    set tm [lindex $margins 2]
    set bm [lindex $margins 3]

    set controls ""
    if {$lm > 0} { lappend controls "left" }
    if {$rm > 0} { lappend controls "right" }
    if {$tm > 0} { lappend controls "top" }
    if {$bm > 0} { lappend controls "bottom" }

    foreach side $controls {
	toplevel "$name-$side"
	wm title "$name-$side" "$name-$side"
	pack propagate "$name-$side" 0
    }

    # force new window to screen so that ViewWin.c can reparent
    # a data display subwindow to this window

    update
}

############################################################

proc CreateTkMarginControls {name type w h} {
    set margins [GetTkControlMargins $type]
    CreateTkControlWindows $name $w $h $margins
    UpdateTkControlMargins $name $type $w $h

    if {$type == "View"} {
	frame "$name-bottom.frame" -relief groove -borderwidth 1
	pack "$name-bottom.frame" -side left -fill both -expand 1
	pack propagate "$name-bottom.frame" 0
	button "$name-bottom.frame.zoominx" -text "X-" \
		-command ProcessInButton
	button "$name-bottom.frame.zoomoutx" -text "X+" \
		-command ProcessOutButton
	button "$name-bottom.frame.zoominy" -text "Y-" \
		-command ProcessYInButton
	button "$name-bottom.frame.zoomouty" -text "Y+" \
		-command ProcessYOutButton  
	pack "$name-bottom.frame.zoominx" "$name-bottom.frame.zoomoutx" \
		"$name-bottom.frame.zoominy" "$name-bottom.frame.zoomouty" \
		-side left -padx 0m
    } else {
	button "$name-bottom.print" -text print -command PrintView
	button "$name-bottom.remove" -text remove -command {RemoveWindow ""}
	pack "$name-bottom.print" "$name-bottom.remove" -side left
    }

    return $margins
}

############################################################

proc UpdateTkControlMargins {name type w h} {
    set margins [GetTkControlMargins $type]
    set lm [lindex $margins 0]
    set rm [lindex $margins 1]
    set tm [lindex $margins 2]
    set bm [lindex $margins 3]

    set controls [list \
	    [list left 0 $tm $lm [expr $h - $tm - $bm]] \
	    [list right [expr $w - $rm] $tm $rm [expr $h - $tm - $bm]] \
	    [list top 0 0 $w $tm] \
	    [list bottom 0 [expr $h - $bm] $w $bm]]

    foreach control $controls {
	set side [lindex $control 0]
	set x [lindex $control 1]
	set y [lindex $control 2]
	set width [lindex $control 3]
	set height [lindex $control 4]
	# see if window exists
	set err [catch {set exists [wm state "$name-$side"]}]
	if {!$err} {
	    wm geometry "$name-$side" [format "=%dx%d+%d+%d" \
		    $width $height $x $y]
	}
    }
}

proc ShowKGraph {} {
    global curView kval kcurr knew

    if {$kcurr == 0} {
	# Find out the views on which to build the KGraph
	dialog .showKGraph "Error " "Selecting specific views to \
		display is not yet implemented" "" 0 { OK }
	return
    } else {
	if {$curView == ""} {
	    dialog .showKGraph "Show KGraph" \
		    "Select a view by clicking in it first." "" 0 { OK }
	    return
	}

	# Form graph out of all the views in the current window
	set win [ DEVise getViewWin $curView]
	set vlist [DEVise getWinViews $win]
    }

    # Pass list of view names and also stat number
    set cmd "DEVise showkgraph $knew $kval {$win} $vlist"

    eval $cmd
}
