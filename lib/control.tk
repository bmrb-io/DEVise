#	$Id$	

#	$Log$
#	Revision 1.9  1995/09/11 22:27:07  jussi
#	Further integration of the new user interface and DEVise.
#	User can now select 1 to n attributes in the automatic
#	map generator.
#
#	Revision 1.8  1995/09/08 22:17:57  jussi
#	Integrated creation of TData source, windows, and links in DEVise.
#
#	Revision 1.7  1995/09/08 20:35:25  jussi
#	Added definition of data source and size of new windows.
#
#	Revision 1.6  1995/09/07 22:59:41  jussi
#	Implemented saving and loading sessions (new type) and automatic
#	view creation.
#
#	Revision 1.5  1995/09/07 20:34:21  jussi
#	Finished an intermediate stage in designing an integrated
#	tdata/window/map/view/link definition.
#
#	Revision 1.4  1995/09/05 22:47:55  jussi
#	Added/updated CVS header.
#
#	Revision 1.3  1995/09/05 22:45:33  jussi
#	Updated CVS header.

# The following are linked to global C variables: fileName, fileAlias,
# gdataName, windowName, sessionName, argv0,  template

# Keep the following for monochrome model
#set green white
#set blue black
#tk colormodel . monochrome

set green green
set blue blue

. configure -bg LightBlue
# set colors and shapes
set DEViseColors {{0 black} {1 white} {2 red} {3 blue} {4 orange} \
	{5 tan} {6 green} {7 purple} {8 aquamarine} {9 peru} {10 chocolate} \
	{11 tomato} {12 pink} {13 plum} {14 azure1} {15 cyan1} {16 SeaGreen1} \
	{17 khaki1} {18 goldenrod1} {19 yellow} {20 sienna1} {21 green} \
	{22 blue} {23 orange} {24 LightGray} {25 red1} {26 red2} \
	{27 green1} {28 green2} {29 blue1} {30 blue2} {31 gold1} {32 gold2} \
	{33 blue1} {34 blue2} {35 blue3} {36 blue4}}
set DEViseShapes {{0 Rect} {1 RectX} {2 Bar}}

# global to control.tk: curView: current view selected.
# lastView: last view selected.
# historyOpen: true if history window has been opened.
set curView ""
set lastView ""
set historyWinOpened false
# not reading files as template

set libdir "."
if { [info exists env(DEVISE_LIB)] } {
    set libdir $env(DEVISE_LIB)
}
set datadir "."
if { [info exists env(DEVISE_DAT)] } {
    set datadir $env(DEVISE_DAT)
}

set mode 0
DEVise changeMode $mode

source $libdir/dialog.tk
source $libdir/FSBox.tk
source $libdir/dialogList.tk
source $libdir/dialogParam.tk
source $libdir/dialogCkBut.tk
source $libdir/dialogMapping.tk
source $libdir/help.tk
source $libdir/issm.tk

# abstract data type for dictionary
# Insert name and val into dictionary. Return new dictionary.
proc DictInsert { dict name val }  {
    set element [list $name $val]
    return [lappend dict $element]
}

# lookup val based on name
proc DictLookup { dict name } {
    foreach element $dict {
	if {$name == [lindex $element 0]} {
	    return [lindex $element 1]
	}
    }
    return ""
}

# Create a new unique name based on old name
proc UniqueName { name} {
    #  puts "UniqueName incoming $name"
    while { [DEVise exists $name] } {
	set len [string length $name]
	set lastChar [string index $name [expr $len-1]]
	if { [scan $lastChar "%d" temp] == 1 } {
	    # numeric for the last character
	    set name [format "%s%d" [string range $name 0 [expr $len-2]] \
		    [expr $lastChar+1]]
	} else {
	    set name [format "%s%d" $name 1]
	}
    }
    return $name
}

set helpWindowCreated 0
# Create menu
wm geometry . +0+0

# Get all instances for a category
proc CategoryInstances {category } {
    set inst { }
    set classes [ DEVise get $category ]
    foreach c $classes {
	set inst [ concat $inst [ DEVise get $category $c ] ]
    }
    return $inst
}

# Get the class of an instance belonging to category
proc GetClass { category instance } {
    set classes [DEVise get $category ]
    foreach c $classes {
	set insts [DEVise get $category $c]
	foreach inst $insts {
	    # puts "comparing $category $c $inst"
	    if {$inst $instance} {
		return $c
	    }
	}
    }
}

# All instances of tdata that we have
# Form: {tdatafilebasename1 tdatafilebasename2 ...}
proc TdataSet { } {
    return [CategoryInstances "tdata" ]
}

# All instances of GData
# Form: {gdataname1 gdataname2 ...}
proc GdataSet { } {
    return [ CategoryInstances "mapping" ]
}

# All interpreted GData
proc InterpretedGData { } {
    set gSet [ GdataSet ]
    set result ""
    foreach gdata  $gSet {
	if { [DEVise isInterpretedGData $gdata ] } {
	    lappend result $gdata
	}
    }
    return $result
}

# list of all views
proc ViewSet { } {
    return [ CategoryInstances "view" ]
}

#list of all cursors
proc CursorSet { } {
    return [ CategoryInstances "cursor" ]
}

# list of all links
proc LinkSet { } { 
    return [ CategoryInstances "link" ]
}

# list of all windows
proc WinSet {} {
    return [ CategoryInstances "window" ]
}

# list of all axis 
proc AxisSet { } {
    return [ CategoryInstances "axisLabel" ]
}

# list of all actions
proc ActionSet { } {
    return [ CategoryInstances "action" ]
}

# build top level menu
frame .mbar -relief raised -bd 2 -background LightBlue 
menubutton .mbar.session -text Session -underline 0 \
	-menu .mbar.session.menu -bg LightBlue
menubutton .mbar.import -text Import -underline 0 \
	-menu .mbar.import.menu -bg LightBlue
menubutton .mbar.file -text Visualize -underline 7 \
	-menu .mbar.file.menu -bg LightBlue
menubutton .mbar.view -text View -underline 0 \
	-menu .mbar.view.menu -bg LightBlue
# menubutton .mbar.link -text Link -underline 0 \
#	-menu .mbar.link.menu -bg LightBlue
menubutton .mbar.cursor -text Cursor -underline 0 \
	-menu .mbar.cursor.menu -bg LightBlue
# menubutton .mbar.window -text Window -underline 0 -menu .mbar.window.menu
# menubutton .mbar.edit -text Edit -underline 0 -menu .mbar.edit.menu
menubutton .mbar.window -text Window -underline 0 \
	-menu .mbar.window.menu -bg LightBlue

menu .mbar.session.menu
.mbar.session.menu add command -label "Open" -command {DoOpen 0}
.mbar.session.menu add command -label "Open as Template" -command {DoOpen 1}
.mbar.session.menu add command -label "Close" -command DoClose
.mbar.session.menu add command -label "Save" -command DoSave
.mbar.session.menu add command -label "Save as" -command DoSaveAs
.mbar.session.menu add command -label "Demo" -command DoDemo
.mbar.session.menu add command -label "Quit" -command DoExit

menu .mbar.import.menu
.mbar.import.menu add command -label "Stock Data" -command issmMain
.mbar.import.menu add command -label "SEQ Data" -command NotImplemented
.mbar.import.menu add command -label "SQL Query" -command NotImplemented

menu .mbar.file.menu
.mbar.file.menu add command -label "File" -command DoVisualizeFile
.mbar.file.menu add command -label "TData" -command DoVisualizeTData
.mbar.file.menu add command -label "GData" -command DoVisualizeGData
.mbar.file.menu add separator
.mbar.file.menu add command -label "Definitions" -command MacroDefStart

menu .mbar.view.menu
.mbar.view.menu add command -label "Remove From Window" -command DoViewRemove
.mbar.view.menu add command -label "Move To Window" -command DoViewMove
.mbar.view.menu add command -label "Link" -command DoViewLink
.mbar.view.menu add command -label "Unlink" -command DoViewUnlink
.mbar.view.menu add command -label "XAxis" -command {DoViewAxis x}
.mbar.view.menu add command -label "YAxis" -command {DoViewAxis y}
.mbar.view.menu add command -label "Action" -command DoViewAction
.mbar.view.menu add command -label "Edit Mapping" -command DoEditMapping
.mbar.view.menu add command -label "Switch TData" -command DoSwitchTData
# .mbar.view.menu add command -label "Dup TData" -command {}
.mbar.view.menu add command -label "Toggle X Axes" \
	-command {DoToggleAxisAllViews X}
.mbar.view.menu add command -label "Toggle Y Axes" \
	-command {DoToggleAxisAllViews Y}
.mbar.view.menu add command -label "Swap Position" -command DoSwapView
# .mbar.view.menu add command -label "Save Pixmap" -command DoSavePixmap
# .mbar.view.menu add command -label "Load Pixmap" -command DoLoadPixmap

# menu .mbar.link.menu
# .mbar.link.menu add command -label "Create" -command DoLinkCreate
# .mbar.link.menu add command -label "Modify" -command DoModifyLink
# .mbar.link.menu add command -label "Link View" -command DoViewLink

menu .mbar.cursor.menu
.mbar.cursor.menu add command -label "Create" -command DoCursorCreate
.mbar.cursor.menu add command -label "Set src" -command DoSetCursorSrc
.mbar.cursor.menu add command -label "Set Dst" -command DoSetCursorDst

# menu .mbar.edit.menu
# .mbar.edit.menu add command -label "GData Mapping" -command DoEditMapping

# menu .mbar.window.menu
# .mbar.window.menu add command -label "Create" -command {}
# .mbar.window.menu add command -label "Destroy" -command {}
# .mbar.window.menu add command -label "Modify" -command {}

menu .mbar.window.menu
.mbar.window.menu add command -label "Help" -command DoHelp
.mbar.window.menu add command -label "History" -command OpenHistory
.mbar.window.menu add command -label "Duplicate" -command DupWindow

pack .mbar.session .mbar.import .mbar.file .mbar.view .mbar.cursor \
	.mbar.window -side left -fill x
#	.mbar.edit .mbar.window .mbar.link .


# status widgets
frame .status  -background LightBlue 
frame .status.left -background LightBlue 
frame .status.right -relief sunken  -background LightBlue -background LightBlue
# .status.right configure -background LightBlue
if { $mode == 0 } {
    set modeText "display mode"
} else {
    setmodeText "layout mode"
}
button .status.left.mode -text $modeText -command {ChangeMode} \
	-background turquoise
pack .status.left.mode -side left -fill x -expand 1

label .status.right.stat -text "status:" -bg LightBlue
label .status.right.stat_msg -bitmap questhead -background LightBlue
pack .status.right.stat_msg .status.right.stat -side right

pack .status.left  -side left 
pack .status.right -side right

# build current view widgets
frame .viewFrame -relief sunken -background LightBlue

label .viewFrame.label -text "Current View:" -bg lavender
label .viewFrame.viewName -text "" -width 50  -bg lavender -fg red
pack .viewFrame.label .viewFrame.viewName  -side left 

# build control widgets
frame .topFrame -background LightBlue

frame .control -relief sunken -background LightBlue
frame .control.level1 -background LightBlue
frame .control.level2 -background LightBlue
frame .control.level3 -background LightBlue
# Do the buttons
button .control.left -bitmap @$libdir/left.bit \
	-command { ProcessLeftButton} -bg cyan1
set left_amount 0.5

button .control.right -bitmap @$libdir/right.bit \
	-command {ProcessRightButton} -bg cyan1
set right_amount 0.5

button .control.up -bitmap @$libdir/up.bit \
	-command { ProcessUpButton } -bg cyan1
set up_amount 0.5

button .control.down -bitmap @$libdir/down.bit \
	-command { ProcessDownButton } -bg cyan1
set down_amount 0.5

button .control.in -bitmap @$libdir/zoominx.bit \
	-command { ProcessInButton } -bg orange
set in_amount 0.5

button .control.out -bitmap @$libdir/zoomoutx.bit \
	-command {ProcessOutButton} -bg orange
set out_amount 1.5

button .control.yin -bitmap @$libdir/zoominy.bit \
	-command {ProcessYInButton} -bg orange
button .control.yout -bitmap @$libdir/zoomouty.bit \
	-command {ProcessYOutButton} -bg orange

pack .control.in .control.left .control.yin -in .control.level1 -side top
pack .control.up -side top -in .control.level2 
pack .control.down -side bottom -in .control.level2 -fill y 
pack .control.out .control.right .control.yout -in .control.level3 -side top
pack .control.level1 .control.level2 .control.level3 -in .control  -side left

# build history widgets
frame .history -relief sunken -bd 2 -background LightBlue

frame .history.heading1 -background LightBlue
frame .history.heading2 -background LightBlue
label .history.xlowHeading -text xlow -bg LightBlue
label .history.xhighHeading -text xhigh -bg LightBlue
label .history.ylowHeading -text ylow -bg LightBlue
label .history.yhighHeading -text yhigh  -bg LightBlue
pack .history.xlowHeading .history.ylowHeading -in .history.heading1 \
	-side top
pack .history.xhighHeading .history.yhighHeading -in .history.heading2 \
	-side top

frame .history.entry1 -bg LightBlue
frame .history.entry2 -bg LightBlue
entry .history.xlow -text "" -relief sunken -width 20 -bg yellow -fg $blue
entry .history.xhigh -text "" -relief sunken -width 20 -bg yellow -fg $blue
entry .history.ylow -text "" -relief sunken -width 20 -bg LightGray 
entry .history.yhigh -text "" -relief sunken -width 20 -bg LightGray
pack .history.xlow .history.ylow  -in .history.entry1 -side top \
	-expand 1 -fill x
pack .history.xhigh .history.yhigh -in .history.entry2 -side top  \
	-expand 1 -fill x

frame .history.buttonFrame  -background LightBlue
button .history.button -text "use" -relief raised -bg $green \
	-command { ProcessUseButton }
button .history.undo -text "undo-edit" -bg $green -relief raised \
	-command {DoUndoEdit}
button .history.back -text "back one" -bg $green -relief raised \
	-command {DoGoBackOne}
button .history.history -text "history" -bg $green -relief raised \
	-command {DoHistoryToggle}
pack .history.button .history.undo .history.back .history.history \
	-in .history.buttonFrame -side left -expand 1 -fill x

pack .history.buttonFrame -side bottom -expand 1 -fill x
pack .history.heading1 .history.entry1 .history.heading2 \
	.history.entry2 -side left -expand 1 -fill x

pack .mbar .status .viewFrame .topFrame -side top -fill x -expand 1
pack .control .history -side left -fill x -expand 1

tk_menuBar .mbar .mbar.session .mbar.import .mbar.file .mbar.view \
	.mbar.link .mbar.window .mbar.help
focus .mbar

# Trim the path name from a file name
proc TrimPath { name } {
	set index [ string first "/" $name ] 
	if { $index < 0 } {
		return $name
	} else {
		set lastIndex [string length $name]
		set lastInsex [expr $lastIndex-1]
		set trim [string range $name [expr $index+1] $lastIndex]
		return [ TrimPath $trim]
	}
}

# Create a new instance of file of the given type.
proc DoCreateTData { file type } {
    global dialogParamVar fileName fileAlias
    set fileName $file
    set fileAlias [ TrimPath $file ]
    set paramNames [ DEVise getparam tdata $type ]
    set tempParams [ lrange $paramNames 1 [expr [llength $paramNames]-1]]

    set button [ dialogParam .fileParam "FileParam" \
	    "Enter Alias for file\n\
	    $file\n\
	    (Note: it may take a while for the program\n\
	    to come back after clicking <OK>)"  "" 1  \
	    { Cancel OK } $tempParams]
    if { $button == 0} {
	return
    }

    set fileAlias [ lindex $dialogParamVar(params) 0 ]
    if { [DEVise exists $fileAlias] } {
	# This file alias already exists in memory.
	set but [dialog .fileExist "FileExist" \
		"Warning: TData $fileAlias	exists" "" \
		1 {cancel} {Use Existing}]
	if { $but == 0 } {
	    return
	} else {
	    return $fileAlias
	}
    }

    set params $dialogParamVar(params)
    set params [linsert $params 0 $file ]
    set cmd "DEVise create tdata $type $params"
 
    set result [ eval $cmd]
    if {$result == ""} {
	set but [ dialog .createError "CreateError" \
		"Can't import file $file of type $type" \
		"" 0 {OK} ]
	return
    }

    return $result
}

#import a new file type
#Return name of file type, or ""
proc ImportFileType { } {
    global fsBox datadir
    set fsBox(path) $datadir
    set fsBox(pattern) *.schema
    set ftypeFile [FSBox "Select schema file"]
    if {$ftypeFile == ""} {
	return
    }
    
    set result [DEVise importFileType $ftypeFile]
    if {$result == ""} {
	dialog .fileTypeError "FileTypeError" \
		"Can't import file type from file\n$ftypeFile" "" 0 {ok} 
	return
    }
    return $result
}

# Check to see if file already exists 
proc FileExist { file } {
    foreach tdata [ TdataSet] {
	if {$file == [DEVise tdataFileName $tdata]} {
	    return 1
	}
    }
    return 0
}

# Select a file and make it into a TData
proc DoSelectFile { } {
    global dialogListVar fsBox datadir
    # Get file name
    set fsBox(path) $datadir
    set fsBox(pattern) *
   set file [ FSBox ]

    # Map file into TData classes
    if {$file == ""} {
	return
    }

    if  { [FileExist $file ] } {
	set but [dialog .fileExist "File Exists" \
		"File $file already loaded\n\
		Please use Visualize/TData menu" "" 0 Continue]
	return
    }

    # find file type (TData class name )
    while { 1 } {
	set tclass [ DEVise get tdata]

	if { [ llength $tclass ] == 0 } {
	    set but [dialog .noTdata "No File Type" \
		    "No existing file type.\n\
		    Import schema for file\n$file?" "" 1 \
		    Cancel OK ]
	    if { $but == 0} {
		return
	    }
	    set result [ImportFileType]
	    if {$result == ""} {
		return
	    }
	    set ftype $result
	    break
	} 
	set button [ dialogList .fileType "fileType" \
		"Select file type for file \n$file"\
		"" 2  { Cancel new OK } $tclass ]
	set ftype $dialogListVar(selected)
	if { $button  == 0 } {
	    return
	} elseif { $button == 1 } {
	    set result [ImportFileType]
	    if {$result == ""} {
		return
	    }
	    set ftype $result
	    break
	} elseif {$dialogListVar(selected) == ""} {
	    return
	} else {
	    break
	}
    }

    set alias [ DoCreateTData $file $ftype ]
    if {$alias == ""} {
	return
    }

    return $alias
}

proc DoSelectTData { } {
    global dialogListVar
    set tdataSet [ TdataSet ]
    if { [ llength $tdataSet  ] == 0 } {
	return [ DoSelectFile ]
    } else {
	set answer [ dialogList .selectTData "SelectTData"  \
		"Select a TData" \
		"" 2 { New Cancel Ok } $tdataSet ]
	if { $answer == 0 } {
	    # Select a new file
	    return [ DoSelectFile ]
	} elseif { $answer == 1 || \
		[string compare $dialogListVar(selected) "" ] == 0 } {
	    # Cancel selected or no file selected.
	    return 
	} else {
	    # Get the selection
	    return $dialogListVar(selected)
	}
    }
}

# eliminate string attributes from schema
proc ElimStringAttr { attrs } {
    set newAttrs ""
    foreach attr $attrs {
	set attrType [lindex $attr 1]
	if {$attrType != "string"} {
	    lappend newAttrs $attr
	}
    }
    return $newAttrs
}

# drop attribute types and sorted flags
proc DropAttrTypes { attrs } {
    set newAttrs ""
    foreach attr $attrs {
	lappend newAttrs [list [lindex $attr 0]]
    }
    return $newAttrs
}

# Find default X attribute name.
# The default is the sorted X attribute other than recId, if one exists.
# Otherwise, it's the recId.
# otherwise, it's the 0th attribute.
proc FindDefaultXAttr { attrs } {
    set numAttrs 0
    foreach attr $attrs {
	# puts "attr= $attr"
	if { [lindex $attr 2] > 0 } {
	    set temp($numAttrs) [lindex $attr 0]
	    incr numAttrs
	    if {$numAttrs >= 2 } {
		break
	    }
	}
    }
    if { $numAttrs == 0 } {
	# puts "numAttrs == 0"
	return [lindex [lindex $attrs 0] 0]
    } elseif { $numAttrs == 1 } {
	# puts "numAttrs == 1"
	return $temp(0)
    } else {
	# puts "numAttrs >= 2"
	if { [string compare $temp(0) "recId"] == 0} {
	    return $temp(1)
	} else {
	    return $temp(0)
	}
    }
}

# Create an interpreted mapping 
proc CreateInterpretedMapping { tdata } {
    global dialogParamVar DEViseColors DEViseShapes

    set attrs [lsort [ElimStringAttr [DEVise getSchema $tdata]]]
    set simpleAttrs [DropAttrTypes $attrs]
    set defX [FindDefaultXAttr $attrs]
    set defY [lindex $simpleAttrs 0]
    if {$defX != "recId"} {
	set defY [lindex $simpleAttrs 1]
    }
    set defColor 2
    set defShape 2
    
    set parm [dialogMapping .enterMapping "enterMapping" \
	    "Enter Mapping" ""  \
	    [list  \
	    [list x $simpleAttrs $defX] \
	    [list y $simpleAttrs $defY]\
	    [list color $DEViseColors $defColor]\
	    [list shape $DEViseShapes $defShape]\
	    ] 1 ] 
    if { [string compare $parm ""] ==  0 } {
	return
    }
    
    # extract parameters
    set mapName [lindex $parm 0]
    set parm [lindex $parm 1]
    
    # extract parameters
    set params [list $tdata $mapName {} \
	    \$[lindex $parm 0] \$[lindex $parm 1]  [lindex $parm 2] \
	    {} {} {} [lindex $parm 3] {} {} ]
    
    set cmd "DEVise createInterp $params"
    set result [eval $cmd]
    if { [string compare $result "" ] == 0 } {
	set but [dialog .CreateError \
		"Can't create mapping for tdata $tdata" \
		"" 0 {OK} ]
	return 
    }
    
    return $result
}

# Actually create gdata and return its name
proc DoActualCreateGData { tdata mapping } {
    global dialogParamVar gdataName fileAlias
    set fileAlias $tdata
    set gdataName [UniqueName [ format "%s#%s" $tdata $mapping ]]

    # if { [DEVise exists $gdataName ] } {
	# set but [dialog .gdataExist "gdataExist" \
		# "Error: gdata $gdataName already exists" \
		# "" 0 {Cancel} ]
	# return
    # }

    set paramNames [ DEVise getparam mapping $mapping ]

    # puts "checking if interpreted $mapping"
    if {! [DEVise isInterpreted $mapping] } {
	# not interpreted mapping 
	set button [ dialogParam .mappingParam "MappingParam" \
		"Enter parameters to create gdata from file $tdata\n\
		and mapping $mapping"\
		"" 1 { Cancel OK } $paramNames ]
	if { $button == 0} {
	    return
	}

	set cmd "DEVise create mapping $mapping $dialogParamVar(params)"
	set result [ eval $cmd]
	if { [string compare $result "" ] == 0 } {
	    set but [ dialog .CreateError \
		    "Can't create mapping using $mapping" \
		    "" 0 {OK} ]
	    return
	}
	return $result
    } else {
	# interpreted mapping
	set parm1 "gdata $tdata#$mapping"
	set parms [list $parm1 ]
	set button [ dialogParam .mappingName GDataName \
		"Enter GData Name " "" 1 { Cancel OK } \
		$parms ]
	if { $button == 0 } {
	    return
	}
	set initParm $dialogParamVar(params)
	
	set gdataName [lindex $initParm 0]
	if { [DEVise exists $gdataName ] } {
	    set but [dialog .gdataExist "gdataExist" \
		    "Error: gdata $gdataName already exists" \
		    "" 0 {Cancel} ]
	    return
	}
	
	# extract parameters
	# puts "paramNames are: $paramNames"
	set params [list $tdata [lindex $initParm 0] \
		[ lindex [lindex $paramNames 2] 1] \
		[ lindex [lindex $paramNames 3] 1] \
		[ lindex [lindex $paramNames 4] 1] \
		[ lindex [lindex $paramNames 5] 1] \
		[ lindex [lindex $paramNames 6] 1] \
		[ lindex [lindex $paramNames 7] 1] \
		[ lindex [lindex $paramNames 8] 1] \
		[ lindex [lindex $paramNames 9] 1] \
		[ lindex [lindex $paramNames 10] 1] \
		[ lindex [lindex $paramNames 11] 1]] 
	
	set cmd "DEVise create mapping $mapping $params"
	set result [ eval $cmd]
	if { [string compare $result "" ] == 0 } {
	    set but [ dialog .CreateError \
		    "Can't create mapping using $mapping" \
		    "" 0 {OK} ]
	    return
	}
	return $result
    }
}

# Create a new GData from TData
proc DoCreateGData { tdata } {
    global dialogListVar
    set schema [DEVise getSchema $tdata ]

    while { 1 } {
	set tmappings [ DEVise get mapping ]
	if { [string compare $tmappings "" ] == 0 } {
	    set but [dialog .noMap "No Mapping" \
		    "No existing mapping.\n\
		    Create mapping for tdata\n$tdata?" "" 1 \
		    Cancel OK ]
	    if { $but == 0} {
		return
	    }
	    set mapping [CreateInterpretedMapping $tdata]
	    if { [string compare $mapping "" ] == 0 } {
		return
	    }
	    break
	}
	set answer [ dialogList .mapGData "MapFile"  \
		"Select mapping to map tdata\n $tdata\ninto gdata" \
		"" 0 { Cancel New OK } $tmappings ]
	if { $answer == 1} {
	    set mapping [CreateInterpretedMapping $tdata]
	    if { [string compare $mapping "" ] == 0} {
		return
	    }
	    break
	} elseif { $answer == 0  || \
		[string compare $dialogListVar(selected) "" ] == 0 } {
	    # no answer 
	    return 
	} else {
	    set mapping $dialogListVar(selected)
	    break
	}
    }
    # Create the actual gdata
    return [ DoActualCreateGData $tdata $mapping ]
}

# Get a GData for display
proc DoGetGData { } {
    global dialogListVar
    set gdataSet [ GdataSet ]
    if { [ llength $gdataSet ] == 0 } {
	set answer [ dialog .getDataError "Visualize GData Error" \
		"There is currently no GData.\n\
		Please use menu File/Visualize to\n\
		create GData for visualization"  "" 0 { Ok } ]
	return
    } else {
	set answer [ dialogList .getGData "GetGData" "Please select GData for \
		display" "" 0 { New Cancel OK } \
		$gdataSet ]
	if { $answer == 0 } {
	    # Create a new one
	    set tdata [ DoSelectTData ]
	    if { [ string compare $tdata "" ] == 0 } {
		return
	    }
	    return [ DoCreateGData $tdata ]
	} elseif { $answer == 1 || \
		[string compare $dialogListVar(selected) "" ] == 0 } {
	    return
	} else {
	    return $dialogListVar(selected)
	}
    }
}

proc DoActualCreateView { viewType name } {
    global dialogParamVar viewName
    set viewName $name
    # if { [DEVise exists $name ] } {
	# set but [dialog .viewExists "ViewExists" \
		# "Error: View $name exists" "" 0 {Cancel}]
	# return
    # }

    set paramNames [ DEVise getparam view $viewType ]
    puts "paramNames $paramNames"

    set button [ dialogParam .viewParam "ViewParam" \
	    "Enter parameters to create view\n$viewName"\
	    "" 1 { Cancel OK } $paramNames ]
    if { $button == 0} {
	return
    }
    set name [lindex $dialogParamVar(params) 0]
    if { [DEVise exists $name ] } {
	set but [dialog .viewExists "ViewExists" \
		"Error: View\n$name exists" "" 0  {Cancel}]
	return
    }

    set cmd "DEVise create view $viewType $dialogParamVar(params)"
    set result [ eval $cmd]
    if { [string compare $result "" ] == 0 } {
	set but [ dialog .viewError "ViewError" \
		"Can't create view using $viewType" "" 0 {OK} ]
	return
    }
    return $result
}

# Do create a new view
proc DoCreateView { message gdata} {
    global dialogListVar

    set viewClasses [ DEVise get view ]
    set answer [ dialogList .createView "CreateView" $message \
	    "" 0 { Cancel OK } $viewClasses 0]
    if { $answer == 0 || [string compare dialogListVar(selected) "" ] == 0 } {
	return
    } else {
	return [ DoActualCreateView $dialogListVar(selected) \
		$gdata#$dialogListVar(selected) ]
    }
}

proc DoGetView { gdata } {
    global dialogListVar
    set viewSet [ ViewSet ]

    # Use this to always create a new view
    return [ DoCreateView "Select type of view to display\n$gdata" \
	    $gdata ]

    #	use this when we have overlapping views
    if { [ llength $viewSet ] == 0 } {
	return [ DoCreateView "Select type of view to display $gdata" \
		$gdata ]
    } else {
	set answer [ dialogList .getView "GetView" "Select a view to \
		display $gdata, or press <New> to create a new one" "" 2 \
		{ Cancel New OK } $viewSet ]
	if { $answer == 1 } {
	    return [ DoCreateView  \
		    "Select type of view to display $gdata" $gdata ]
	} elseif { $answer == 0 || \
		[ string compare $dialogListVar(selected) "" ] == 0 } {
	    return
	} else {
	    return $dialogListVar(selected)
	}
    }
}

proc DoActualCreateWindow { winType } {
    global dialogParamVar windowName
    set windowName [UniqueName DEViseWn0]
    set paramNames [ DEVise getparam window $winType ]

    set button [ dialogParam .windowParam "WindowParam" \
	    "Enter parameters to create window $winType"\
	    "" 1 { Cancel OK } $paramNames ]
    if { $button == 0} {
	return
    }
    set cmd "DEVise create window $winType $dialogParamVar(params)"
    set result [ eval $cmd ]
    if { [string compare $result "" ] == 0 } {
	set but [ dialog .winError "winError" \
		"Can't create window using $winType" "" 0 {OK} ]
	return
    }
    return $result
}

# Create a new window
proc DoCreateWindow { message } {
    global dialogListVar
    set winTypes [ DEVise get window ]
    if { [llength $winTypes] == 1 } {
	return [ DoActualCreateWindow [lindex $winTypes 0] ]
    }
    set answer [ dialogList .createWin "CreateWindow"  \
	    $message "" "" { Cancel Ok } $winTypes ]
    if { $answer == 0 || \
	    [ string compare $dialogListVar(selected) "" ] == 0 } {
	return
    } else {
	return [ DoActualCreateWindow $dialogListVar(selected) ]
    }
}

# Get a window 
proc DoGetWindow { } {
    global dialogListVar
    set winSet [ WinSet ]
    if { [ llength $winSet ] == 0 } {
	return [ DoCreateWindow "Select window type" ]
    } else {
	set answer [ dialogList .window "window" "Select a window \
		to display view" "" "" \
		{ Cancel New Ok } $winSet ]
	if { $answer == 1 } {
	    return [ DoCreateWindow "Select window type" ]
	} elseif { $answer == 0  || \
		[ string compare $dialogListVar(selected) "" ] == 0 } {
	    return 
	} else {
	    return $dialogListVar(selected)
	}
    }
}

proc DoVisualizeTData { } {
    set tdata [ DoSelectTData ]
    DoActualVisualizeTData $tdata
}

proc DoVisualizeFile { } {
    set tdata [ DoSelectFile ]
    DoActualVisualizeTData $tdata
}

# Do File/TData command. Return 1 if OK, else return nothing
proc DoActualVisualizeTData { tdata } {
    if { [ string compare $tdata "" ] == 0 } {
	# no tdata selected.
	return
    }
    
    # Do mapping for tdata
    set gdata [ DoCreateGData $tdata ]
    if { [ string compare $gdata "" ] == 0 } {
	# no tdata selected.
	return
    }
    
    # put gdata into view 
    set view [ DoGetView $gdata ]
    if { [string compare $view "" ] == 0 } {
	return
    }
    set res [DEVise insertMapping $view $gdata ]

    # Find a window for view
    set window [ DoGetWindow ]
    if { [string compare $window "" ] == 0 }  { 
	return
    }
    set res [ DEVise insertWindow $view $window ]
    
    ProcessViewSelected $view
}

proc DoVisualizeGData { } {
    set gdata [ DoGetGData ]
    if { [ string compare $gdata "" ] == 0 } {
	return
    }

    # gdata into view 
    set view [ DoGetView $gdata ]
    if { [string compare $view "" ] == 0 } {
	return
    }
    set res [DEVise insertMapping $view $gdata ]
    
    # Find a window for view
    set window [ DoGetWindow ]
    if { [string compare $window "" ] == 0 }  { 
	return
    }
    set res [ DEVise insertWindow $view $window ]
    
    ProcessViewSelected $view
}

proc DoExit { } {
    set answer [ dialog .quit "Quit" \
	    "Are you sure you want to quit?" "" 1 \
	    { Cancel} { Ok } ]
    if { $answer == 1 } {
	DEVise exit
    }
}


# Process View/Create menu
proc DoViewCreate { } {
    set ans [ DoCreateView "Select a view type" ]
}

# Destroy a view
proc DoViewDestroy { } {
    set answer [ dialogList .destroyView "DestroyView" \
	    "Select a view to destroy" "" 0 { Cancel OK } [ViewSet] ]
    if { $answer == 0 } {
	return
    } else {
	# Delete view here
	return
    }
}

# remove view from window
proc DoViewRemove { } {
    global curView
    if { [string compare $curView ""] == 0 } {
	dialog .removeView "Remove View" \
		"Please select a view by clicking in it first." "" 0 { OK }
	return
    }
    set answer [ dialog .removeView "Remove View" \
	    "Remove view $curView from its window?" "" 1 Cancel Ok]
    if { $answer == 0 } {
	return
    } else {
	# Remove view
	set ans [DEVise removeView $curView ]
	if { [string compare $ans "" ] != 0 } {
	    dialogList .removeError "RemoveError" $ans "" 0 {OK}
	    return
	}
	# Unselect current view
	ProcessViewSelected ""
    }
}

# Move view to window
proc DoViewMove { } {
    global dialogListVar 
    set answer [ dialogList .removeView "Move View" \
	    "Select view to move to a window" "" 0 { Cancel OK } [ViewSet] ]
    if { $answer == 0 } {
	return
    }
    set viewName $dialogListVar(selected)
    
    set winName [ DoGetWindow ]
    if { [string compare $winName "" ] == 0 } {
	return
    }
    
    DEVise insertWindow $viewName $winName
    ProcessViewSelected $viewName
}

# Save a info about creating a class instance into file f
proc SaveInstance { f category class instance } {
    set params [ DEVise getCreateParam $category $class $instance ]
    puts $f "DEVise create $category $class $params"
    flush $f
}

# Save all instances of a given class into file f
proc SaveClass { f category class } {
    set instances [ DEVise get $category $class]
    foreach i $instances {
	SaveInstance $f $category $class $i 
    }
}

# Save all instances of a given category into file f
proc SaveCategory { f category } {
    set classes [ DEVise get $category ]
    foreach i $classes {
	SaveClass $f $category $i 
    }
}

# Print the name of all instances in category
proc PrintCategory { category } {
    set classes [ DEVise get $category ]
    puts "classes $classes"
    foreach c  $classes {
	set instances [ DEVise get $category $c]
	foreach i $instances {
	    puts -nonewline "$i "
	}
    }
    puts ""
}

# Save info about mappings to all views into file f
proc SaveAllViewMappings { f mappingDict viewDict } {
    # Get all mapping classes
    set viewClasses [ DEVise get "view" ]
    foreach vClass $viewClasses {
	# Get all views for this class
	set views [ DEVise get "view" $vClass ]
	foreach v $views {
	    set viewVar [DictLookup $viewDict $v]
	    # Get all mappings for this view
	    set mappings [ DEVise getViewMappings $v ]
	    foreach map $mappings {
		set mapVar [DictLookup $mappingDict $map]
		puts $f "DEVise insertMapping \$$viewVar \$$mapVar"
	    }
	}
    }
}

# Save info about axis labels to all views 
proc SaveAllViewAxisLabel { f viewDict } {
    set viewClasses [ DEVise get "view" ]
    foreach vClass $viewClasses {
	# Get all views for this class
	set views [ DEVise get "view" $vClass ]
	foreach v $views {
	    set viewVar [DictLookup $viewDict $v]
	    set xAxisLabel [ DEVise getAxis $v x]
	    if { [string compare $xAxisLabel "" ] != 0 } {
		puts $f "DEVise setAxis \$$viewVar $xAxisLabel x"
	    }
	    
	    set yAxisLabel [ DEVise getAxis $v y]
	    if { [string compare $yAxisLabel "" ] != 0 } {
		puts $f "DEVise setAxis \$$viewVar $yAxisLabel y"
	    }
	    
	    # Set axis display on/off.
	    set stat [DEVise getAxisDisplay $v X]
	    puts $f "DEVise setAxisDisplay \$$viewVar X $stat"
	    
	    set stat [DEVise getAxisDisplay $v Y]
	    puts $f "DEVise setAxisDisplay \$$viewVar Y $stat"
	}
    }
}


# Save info about action
proc SaveAllViewAction { f dict} {
    set viewClasses [ DEVise get "view" ]
    foreach vClass $viewClasses {
	# Get all views for this class
	set views [ DEVise get "view" $vClass ]
	foreach v $views {
	    set viewVar [DictLookup $dict $v]
	    set action [DEVise getAction $v]
	    if { [string compare $action "" ] != 0 } {
		puts $f "DEVise setAction \$$viewVar $action"
	    }
	}
    }
}

# Save info about views inserted into windows into file f
proc SaveAllWindowViews { f viewDict} {
    # Get all window classes
    set windowClasses [ DEVise get "window" ]
    foreach winClass $windowClasses {
	# Get all windows for this class
	set windows [ DEVise get "window" $winClass ]
	foreach win $windows {
	    # Get all views inserted into this window
	    set views [DEVise getWinViews $win ]
	    foreach v $views {
		set viewVar [DictLookup $viewDict $v]
		puts $f "DEVise insertWindow \$$viewVar \{$win\}"
	    }
	}
    }
}

# Save name of views in links
proc SaveLinkViews { file dict} {
    set linkSet [LinkSet]
    foreach link $linkSet {
	set views [DEVise getLinkViews $link]
	foreach view $views {
	    set viewVar [DictLookup $dict $view]
	    puts $file "DEVise insertLink \{$link\} \$$viewVar"
	}
    }
}

# Save name of views in cursors
proc SaveCursorViews { file dict} {
    set cursorSet [CursorSet]
    foreach cursor $cursorSet {
	set views [DEVise getCursorViews $cursor]
	set src [DictLookup $dict [lindex $views 0]]
	set dst [DictLookup $dict [lindex $views 1]]
	if { [string compare $src "" ] != 0 } {
	    puts $file "DEVise setCursorSrc $cursor \$$src"
	}
	if { [string compare $dst "" ] != 0 } {
	    puts $file "DEVise setCursorDst $cursor \$$dst"
	}
    }
}

# Save session
proc DoActualSave { infile } {
    global mode curView

    ChangeStatus 1
    # copy existing file to a backup file
    if { [ file exists $infile ] } {
	set src [open $infile]
	set dst [open $infile.bak w]
	while { [gets $src line] >= 0 } {
	    puts $dst $line
	}
	close $src
	close $dst

	if { ! [ file writable $infile ] } {
	    set but [ dialog .saveError "File $infile not writable" \
		    "" 0 {OK} ]
	    ChangeStatus 0
	    return
	}
    }

    # checkpoint tdata
    set classes [ DEVise get "tdata" ]
    foreach class $classes {
	set instances [ DEVise get "tdata" $class ]
	foreach inst $instances {
	    DEVise tcheckpoint $inst
	}
    }

    set f [open $infile w ]

    puts $f "# import file types"
    set catFiles [DEVise catFiles]
    foreach file $catFiles {
	puts $f "DEVise importFileType $file"
    }
    puts $f ""

    puts $f "# layout mode"
    puts $f "DEVise changeMode 0"
    puts $f ""

    puts $f "# Import file (Create TData)"
    puts $f "# format: DEVise create tdata fileType filePath fileAlias"
    set fileDict ""
    set fileNum 1
    set classes [DEVise get tdata]
    set totalTData [llength [TdataSet]]
    foreach class $classes {
	set instances [DEVise get tdata $class]
	foreach inst $instances {
	    set params [DEVise getCreateParam tdata $class $inst]
	    set filePath [lindex $params 0]
	    set fileAlias [lindex $params 1]
	    set fileDict [DictInsert $fileDict $fileAlias tdata_$fileNum]
	    set tdataVar tdata_$fileNum
	    puts $f "if \{ \$template \} \{"
	    puts $f "\tset $tdataVar \[ GetTDataTemplate $class $totalTData $fileNum \]"
	    puts $f "\tif \{ \[string compare \$$tdataVar \"\" \] == 0 \} \{"
	    puts $f "\t\treturn 0"
	    puts $f "\t\}"
	    puts $f "\} else \{"
	    puts $f "\tset $tdataVar \{$fileAlias\}"
	    puts $f "\tDEVise create tdata $class $filePath \$$tdataVar"
	    puts $f "\}"
	    set fileNum [expr $fileNum+1]
	}
    }
    puts $f  ""

    puts $f "# Create interpreted mapping classes "
    set mapClasses [ DEVise interpMapClassInfo ]
    foreach mclass $mapClasses {
	# puts "mclass $mclass"
	set mapTData [DictLookup $fileDict [lindex $mclass 0]]
	puts $f "DEVise createInterp \$$mapTData [lrange $mclass 1 end]"
    }
    puts $f ""

    puts $f "# Create mappings instances (and GData)"
    puts $f "# format: DEVise create mapping mapType fileAlias gdataName"
    set mapClasses [DEVise get mapping]
    set mapDict ""
    set mapNum 1
    foreach mapClass $mapClasses {
	set instances [DEVise get mapping $mapClass]
	foreach inst $instances {
	    set params [DEVise getCreateParam mapping $mapClass $inst]
	    set fileAlias [lindex $params 0]
	    set fileVar [DictLookup $fileDict $fileAlias]
	    set gdataName [lindex $params 1]
	    regsub $fileAlias $gdataName \%s gdataExpr
	    puts $f "set map_$mapNum \[ format \"$gdataExpr\" \$$fileVar \]"
	    puts $f "DEVise create mapping \{$mapClass\} \$$fileVar \$map_$mapNum [lrange $params 2 end]"
	    set mapDict [DictInsert $mapDict $inst map_$mapNum]
	    incr mapNum
	}
    }
    puts $f ""

    puts $f "# Save pixel width for mappings"
    foreach map [GdataSet ] {
	set width [DEVise getPixelWidth $map]
	set gdataVar [DictLookup $mapDict $map]
	puts $f "DEVise setPixelWidth \$$gdataVar $width"
    }
    puts $f  ""

    puts $f "# Create views"
    puts $f "# format: DEVise create view viewType viewName xlow xhigh ylow yhigh"
    set viewDict ""
    set viewNum 1
    set viewClasses [DEVise get view]
    foreach viewClass $viewClasses {
	set instances [DEVise get view $viewClass]
	foreach inst $instances {
	    set params [DEVise getCreateParam view $viewClass $inst]
	    set viewMap [lindex [DEVise getViewMappings $inst] 0]
	    set viewVar view_$viewNum
	    if { [string compare $viewMap "" ] == 0 } { 
		puts $f "set $viewVar $inst"
	    } else {
		set viewTData [DEVise getMappingTData $viewMap]
		set tdataVar [DictLookup $fileDict $viewTData]
		regsub $viewTData $inst \%s viewExpr
		puts $f "set $viewVar \[ format \"$viewExpr\" \$$tdataVar \]"
	    }
	    puts $f "DEVise create view $viewClass \$$viewVar [lrange $params 1 end]"
	    set viewDict [DictInsert $viewDict $inst $viewVar]
	    set viewNum [expr $viewNum+1]
	}
    }
    #	SaveCategory $f "view" 
    puts $f ""

    puts $f "# Create windows"
    puts $f "# format: DEVise create window winType winName x y width height"
    SaveCategory $f "window" 
    puts $f ""

    puts $f "# Create Links"
    puts $f "# format: DEVise create link Visual_Link name flag"
    SaveCategory $f "link" 
    puts $f ""

    puts $f "# Create Cursors"
    puts $f "# format: DEVise create cursor Cursor name flag"
    SaveCategory $f "cursor"
    puts $f ""

    puts $f "#Create axislabel"
    puts $f "# format: DEVise create axisLabel type name format"
    SaveCategory $f "axisLabel"
    puts $f ""

    puts $f "# Create Actions"
    puts $f "# format: DEVise create action type name"
    SaveCategory $f "action"
    puts $f ""

    puts $f "# Put labels into views"
    SaveAllViewAxisLabel $f $viewDict

    puts $f "# put action into view"
    SaveAllViewAction $f $viewDict

    puts $f "# Link views"
    SaveLinkViews $f $viewDict

    puts $f "# Put views in cursors"
    SaveCursorViews $f $viewDict

    puts $f "# Put axis label into views"

    puts $f "# Insert mappings into views"
    puts $f "# format: DEVise insertMapping viewName gdataName"
    SaveAllViewMappings $f $mapDict $viewDict 
    puts $f ""

    puts $f "# Insert views into windows"
    puts $f "# format: DEVise insertWindow viewName winName"
    SaveAllWindowViews $f $viewDict
    puts $f ""

    puts $f "# Init history of view"
    set viewSet [ViewSet]
    foreach view $viewSet {
	set viewVar [DictLookup $viewDict $view]
	puts $f "DEVise clearViewHistory \$$viewVar"
	set historyList [DEVise getVisualFilters $view]
	foreach hist $historyList {
	    puts $f "DEVise insertViewHistory \$$viewVar {[lindex $hist 0]} {[lindex $hist 1]} {[lindex $hist 2]} {[lindex $hist 3]} {[lindex $hist 4]}"
	}
    }

    if { $mode == 1 } {
	puts $f "# display mode"
	puts $f "DEVise changeMode 1"
    }


    # Save pixmaps 
    set bitmapFile $infile.pixmap
    if { [ file exists $bitmapFile ] } {
	if { ! [ file writable $bitmapFile ] } {
	    set but [ dialog .saveError "File $bitmapFile not writable" \
		    "" 0 {OK} ]
	    ChangeStatus 0
	    return
	}
    }

    set bitF [DEVise open $bitmapFile wb]
    set date [DEVise date]
    DEVise writeLine $date $bitF
    set savedCurView $curView
    ProcessViewSelected ""

    puts $f "#load pixmaps from views"
    puts $f "set pixmapName $bitmapFile"
    puts $f " if \{ !\$template && \[ file exists \$pixmapName \] \} \{"
    puts $f "set pixmapFile \[ DEVise open \$pixmapName rb \]"
    puts $f "set fileDate \[ DEVise readLine \$pixmapFile \]"
    puts $f "set sessionDate \{$date\}"
    puts $f "if \{ \[string compare \$fileDate \$sessionDate \] == 0 \} \{ "
    set viewSet [ViewSet]
    foreach view $viewSet {
	DEVise savePixmap $view $bitF
	puts $f "DEVise loadPixmap $view \$pixmapFile"
    }
    puts $f "\}"
    puts $f "DEVise close \$pixmapFile"
    puts $f "\}"
    DEVise close $bitF

    ProcessViewSelected $savedCurView

    puts $f "return 1"

    ChangeStatus 0
    close $f
}

proc DoSave { } {
    global sessionName
    set button [ dialog .saveSession "SaveSession" \
	    "Save session to file\n$sessionName?"  "" 1  {Cancel} {Ok}  ]
    if { $button == 1 } {
	DoActualSave $sessionName
    }
}

proc DoSaveAs { } {
    global sessionName fsBox datadir

    # Get file name
    set fsBox(path) $datadir
    set fsBox(pattern) *.tk
    set file [ FSBox ]
    
    set button [ dialog .saveSession "saveSession" \
	    "Save session to file\n$file?"  "" 1  {Cancel} {Ok} ]
    if { $button == 1 } {
	DoActualSave $file
	set sessionName $file
    }
}

# read .rc file
# we check the following in sequence:
# 1) if environment variable touuper($argv0)_RC exists, use it.
#	example: if progran name == afsio, check if environment AFSIO_RC
# 2) next, check .$argv0_rc
#	example: .afsio_rc
# 3) next, check $argv0_rc
#  example: afsio.rc
set progName [ TrimPath $argv0 ]
set envName [ format "%s_RC" [string toupper $progName] ]
set rcFile1 [ format ".%s_rc" $progName ]
set rcFile2 [ format "%s.rc" $progName ]

if { [ info exists env($envName)] && [file exists env$(envName) ] } {
    set rcFile env($envName)
} elseif { [ file exists  $rcFile1 ] } {
    set rcFile $rcFile1
} elseif { [file exists $rcFile2 ] } {
    set rcFile $rcFile2
} else {
    set rcFile ""
}

if {$rcFile != ""} {
    puts "reading from $rcFile"
    source $rcFile
}

# Refresh all views
proc RefreshAllViews { } {
    set classes [ DEVise get "view" ]
    foreach class $classes {
	set instances [ DEVise get "view" $class ]
	foreach inst $instances {
	    DEVise refreshView $inst
	}
    }
}

# Change mode
proc ChangeMode { } {
    global mode
    if { $mode == 0 } {
	set mode 1
	.status.left.mode configure -text "layout mode"
    } else {
	set mode 0
	.status.left.mode configure -text "display mode"
	# RefreshAllViews
    }
    DEVise changeMode $mode
}

# change status display
proc ChangeStatus { status } {
    global LightBlue red
    if { $status == 0 } {
	# .status.right configure -background LightGray
	.status.right.stat_msg configure -bitmap questhead  \
		-bg LightBlue
    } else {
	.status.right.stat_msg configure -bitmap hourglass \
		-background red
	# .status.right configure -background red
    }
}

#**************************************************************
# View Processing
#**************************************************************

proc ProcessViewCreated { view } {
}

proc ProcessViewDestroyed { view } {
}

# Process view selected 
proc ProcessViewSelected { view } {
    global curView lastView historyWinOpened

    if {$view == $curView} {
	return
    } else {
	set lastView $curView
    }

    if {$curView != ""} {
	# unhighlight old view
	DEVise highlightView $curView 0
    }

    set curView $view
    .viewFrame.viewName configure -text $curView

    ClearHistory

    if {$curView == ""} {
	return
    }

    # highlight new view
    DEVise highlightView $curView 1

    set filters [DEVise getVisualFilters $curView]
    # puts "setting filter $curView $filters"
    foreach filter $filters { 
	ProcessViewFilterChange $curView -1 \
		[lindex $filter 0] [lindex $filter 1] \
		[lindex $filter 2]  [lindex $filter 3] [lindex $filter 4]
    }
}

# Process filter changed in a view
proc ProcessViewFilterChange { view flushed xLow yLow xHigh yHigh marked} {
    # puts "ProcessViewFilterChange { $view $flushed $xLow \
	    $yLow $xHigh $yHigh $marked}" 
    global curView historyWinOpened
    if {$view != $curView} {
	return
    }

    # Change the control panel's entry box
    foreach i { xlow ylow xhigh yhigh} {
	.history.$i delete 0 end
    }
    .history.xlow insert 0 $xLow
    .history.ylow insert 0 $yLow
    .history.xhigh insert 0 $xHigh
    .history.yhigh insert 0 $yHigh

    if { $historyWinOpened } {
	if {$flushed >= 0} {
	    # Remove last in the list 
	    foreach i { listMark listXlow listXhigh listYlow listYhigh } {
		set size [.historyWin.$i size]
		.historyWin.$i delete [expr $size-$flushed-1]
	    }
	}

	# Insert new filter 
	.historyWin.listXlow insert 0 $xLow
	.historyWin.listXhigh insert 0 $xHigh
	.historyWin.listYlow insert 0 $yLow
	.historyWin.listYhigh insert 0 $yHigh
	if { $marked } {
	    .historyWin.listMark insert 0 "*"
	} else {
	    .historyWin.listMark insert 0 " "
	}
    }
}

proc ProcessMarkSelected { sel } {
    global curView
    set mark [.historyWin.listMark get $sel]
    if { [string compare $mark "*" ] == 0 } {
	set newMark " "
	set newVal 0
    } else {
	set newMark "*"
	set newVal 1
    }
    set index [expr [.historyWin.listMark size]-$sel-1]
    DEVise markViewFilter $curView $index $newVal
    .historyWin.listMark delete $sel
    .historyWin.listMark insert $sel $newMark
}

proc ProcessHistorySelected { sel } {
    # foreach i { listXlow listXhigh listYlow listYhigh } {
	# .history.$i select from $sel
	# .history.$i select to $sel
    # }

    foreach i { xlow ylow xhigh yhigh } {
	.history.$i delete 0 end
    }

    .history.xlow  insert 0 [.historyWin.listXlow get $sel]
    .history.ylow  insert 0 [.historyWin.listYlow get $sel]
    .history.xhigh insert 0 [.historyWin.listXhigh get $sel]
    .history.yhigh insert 0 [.historyWin.listYhigh get $sel]
}

# Process "use" button pressed
proc ProcessUseButton { } {
    global curView
    set xlow [DEVise parseDateFloat [.history.xlow get ]]
    set ylow [DEVise parseDateFloat [.history.ylow get ]]
    set xhigh [DEVise parseDateFloat [.history.xhigh get ]]
    set yhigh [DEVise parseDateFloat [.history.yhigh get ]]
    if { [string compare $curView "" ] == 0 } {
	return
    }

    if { ($xlow >= $xhigh ) || ($ylow >= $yhigh)} {
	set but [dialog .useError "UseError" \
		"VisualFilter xlow($xlow) >= xhigh($xhigh)\n\
		or ylow($ylow)>=yhigh($yhigh)" \
		"" 0 {Cancel} ]
    } else {
	DEVise setFilter $curView $xlow $ylow $xhigh $yhigh
    }
}

proc ProcessLeftButton { } {
    global curView left_amount
    if { [string compare $curView "" ] == 0 } {
	return
    }
    set filter [DEVise getCurVisualFilter $curView ]

    if { $left_amount <= 0.0 } {
	set but [dialog .leftError "ScrollLeftError" \
		"Can't scroll left $left_amount screen (should be > 0.0)" \
		"" 0 {Cancel}  ]
	return
    }
    set xlow [lindex $filter 0 ]
    set ylow [lindex $filter 1 ]
    set xhigh [lindex $filter 2 ]
    set yhigh [lindex $filter 3 ]

    set width [expr $xhigh-$xlow]
    set scrollAmount [expr $width*$left_amount]
    set xlow [expr $xlow+$scrollAmount]
    set xhigh [expr $xhigh+$scrollAmount]
    
    DEVise setFilter $curView $xlow $ylow $xhigh $yhigh
}

proc ProcessRightButton { } { 
    global curView right_amount
    if { [string compare $curView "" ] == 0 } {
	return
    }
    set filter [DEVise getCurVisualFilter $curView ]

    if { $right_amount <= 0.0 } {
	set but [dialog .rightError "ScrollRightError" \
		"Can't scroll right $right_amount screen (should be > 0.0)" \
		"" 0 {Cancel}  ]
	return
    }
    set xlow [lindex $filter 0 ]
    set ylow [lindex $filter 1 ]
    set xhigh [lindex $filter 2 ]
    set yhigh [lindex $filter 3 ]
    
    set width [expr $xhigh-$xlow]
    set scrollAmount [expr $width*$right_amount]
    set xlow [expr $xlow-$scrollAmount]
    set xhigh [expr $xhigh-$scrollAmount]
    
    DEVise setFilter $curView $xlow $ylow $xhigh $yhigh
}

proc ProcessUpButton { } { 
    global curView up_amount
    if { [string compare $curView "" ] == 0 } {
	return
    }
    set filter [DEVise getCurVisualFilter $curView ]
    
    if { $up_amount <= 0.0 } {
	set but [dialog .upError "ScrollUpError" \
		"Can't scroll up $up_amount screen (should be > 0.0)" \
		"" 0 {Cancel}  ]
	return
    }
    set xlow [lindex $filter 0 ]
    set ylow [lindex $filter 1 ]
    set xhigh [lindex $filter 2 ]
    set yhigh [lindex $filter 3 ]
    
    set height [expr $yhigh-$ylow]
    set scrollAmount [expr $height*$up_amount]
    set ylow [expr $ylow-$scrollAmount]
    set yhigh [expr $yhigh-$scrollAmount]
    
    DEVise setFilter $curView $xlow $ylow $xhigh $yhigh
}

proc ProcessDownButton { } {
    global curView down_amount
    if { [string compare $curView "" ] == 0 } {
	return
    }
    set filter [DEVise getCurVisualFilter $curView ]
    
    if { $down_amount <= 0.0 } {
	set but [dialog .downError "ScrollDownError" \
		"Can't scroll down $up_amount screen (should be > 0.0)" \
		"" 0 {Cancel}  ]
	return
    }
    set xlow [lindex $filter 0 ]
    set ylow [lindex $filter 1 ]
    set xhigh [lindex $filter 2 ]
    set yhigh [lindex $filter 3 ]
    
    set height [expr $yhigh-$ylow]
    set scrollAmount [expr $height*$down_amount]
    set ylow [expr $ylow+$scrollAmount]
    set yhigh [expr $yhigh+$scrollAmount]
    
    DEVise setFilter $curView $xlow $ylow $xhigh $yhigh
}

proc ProcessInButton { } {
    global curView in_amount
    if { [string compare $curView "" ] == 0 } {
	return
    }
    set filter [DEVise getCurVisualFilter $curView ]
    
    if { $in_amount <= 0.0 || $in_amount >= 1.0 } {
	set but [dialog .inError "ZoomInError" \
		"Can't Zoom in $in_amount screen (should be < 1.0 and > 0.0)" \
		"" 0 {Cancel}  ]
	return
    }
    set xlow [lindex $filter 0 ]
    set ylow [lindex $filter 1 ]
    set xhigh [lindex $filter 2 ]
    set yhigh [lindex $filter 3 ]
    
    set width [expr $xhigh-$xlow]
    set scrollAmount [expr $width*$in_amount]
    set mid [ expr ($xhigh+$xlow)/2.0]
    set xlow [expr $mid - ($scrollAmount/2.0) ]
    set xhigh [expr $xlow+$scrollAmount]
    
    DEVise setFilter $curView $xlow $ylow $xhigh $yhigh
}

proc ProcessYInButton { } {
    global curView in_amount
    if { [string compare $curView "" ] == 0 } {
	return
    }
    set filter [DEVise getCurVisualFilter $curView ]
    
    if { $in_amount <= 0.0 || $in_amount >= 1.0 } {
	set but [dialog .inError "ZoomInError" \
		"Can't Zoom in $in_amount screen (should be < 1.0 and > 0.0)" \
		"" 0 {Cancel}  ]
	return
    }
    set xlow [lindex $filter 0 ]
    set ylow [lindex $filter 1 ]
    set xhigh [lindex $filter 2 ]
    set yhigh [lindex $filter 3 ]
    
    set width [expr $yhigh-$ylow]
    set scrollAmount [expr $width*$in_amount]
    set mid [ expr ($yhigh+$ylow)/2.0]
    set ylow [expr $mid - ($scrollAmount/2.0) ]
    set yhigh [expr $ylow+$scrollAmount]
    
    DEVise setFilter $curView $xlow $ylow $xhigh $yhigh
}

proc ProcessOutButton { } { 
    global curView out_amount
    if { [string compare $curView "" ] == 0 } {
	return
    }
    set filter [DEVise getCurVisualFilter $curView ]
    
    if { $out_amount <= 1.0  } {
	set but [dialog .outError "ZoomOutError" \
		"Can't Zoom out $out_amount screen (should be > 1.0)" \
		"" 0 {Cancel}  ]
	return
    }
    set xlow [lindex $filter 0 ]
    set ylow [lindex $filter 1 ]
    set xhigh [lindex $filter 2 ]
    set yhigh [lindex $filter 3 ]
    
    set width [expr $xhigh-$xlow]
    set scrollAmount [expr $width*$out_amount]
    set mid [ expr ($xhigh+$xlow)/2.0]
    set xlow [expr $mid - ($scrollAmount/2.0) ]
    set xhigh [expr $xlow+$scrollAmount]
    
    DEVise setFilter $curView $xlow $ylow $xhigh $yhigh
}
proc ProcessYOutButton { } { 
    global curView out_amount
    if { [string compare $curView "" ] == 0 } {
	return
    }
    set filter [DEVise getCurVisualFilter $curView ]
    
    if { $out_amount <= 1.0  } {
	set but [dialog .outError "ZoomOutError" \
		"Can't Zoom out $out_amount screen (should be > 1.0)" \
		"" 0 {Cancel}  ]
	return
    }
    set xlow [lindex $filter 0 ]
    set ylow [lindex $filter 1 ]
    set xhigh [lindex $filter 2 ]
    set yhigh [lindex $filter 3 ]
    
    set width [expr $yhigh-$ylow]
    set scrollAmount [expr $width*$out_amount]
    set mid [ expr ($yhigh+$ylow)/2.0]
    set ylow [expr $mid - ($scrollAmount/2.0) ]
    set yhigh [expr $ylow+$scrollAmount]
    
    DEVise setFilter $curView $xlow $ylow $xhigh $yhigh
}

# Do editing for mapping
proc DoEditMapping { } {
    global dialogParamVar dialogListVar DEViseColors DEViseShapes curView
    if {$curView == ""} {
	dialog .editMapping "Edit Mapping" \
		"Please select a view by clicking in it first." "" 0 { OK } 
	return
    }

    # Get mapping for the view
    set map [lindex [DEVise getViewMappings $curView] 0]
    
    # Find all interpreted mapping
    set maps [InterpretedGData ]
    if {$maps == ""} {
	dialog .editError "EditMappingError" \
		"No Interpreted Mapping" "" 0 {ok} 
	return
    }
    
    # See if map is interpreted
    set found 0
    foreach m $maps {
	if {$m == $map} {
	    set found 1
	    break
	}
    }
    if {!$found} {
	dialog .editError "EditMappingError" \
		"Selected view does not contain interpreted mapping" \
		"" 0 {Continue} 
	return
    }
    
    # Get parameters for the mapping
    set params [DEVise getInstParam $map]
    if { [string compare $params "" ] == 0 } {
	dialog .editError "EditMappingError" \
		"No parameter for this mapping" "" 0 {ok} 
	return
    }

    # puts "got params $params"
    set xParm [string trim [lindex [lindex $params 3] 1] "$ "]
    set yParm [string trim [lindex [lindex $params 4] 1] "$ "]
    set colorParm [lindex [lindex $params 5] 1]
    set shapeParm [lindex [lindex $params 9] 1]
    set tdata [lindex [lindex $params 0] 1]
    # set attrs [DEVise getSchema $tdata]
    set parm [dialogMapping .editMapping "EditMapping" \
	    "Edit Mapping" ""   \
	    [list \
	    [list color $DEViseColors $colorParm] \
	    [list shape $DEViseShapes $shapeParm] \
	    ] 0 ]
    
    # puts "dialogMapping returns $parm"
    if {$parm == ""} {
	return
    }

    # extract parameters
    set params [list [lindex [lindex $params 0] 1] \
	    [lindex [lindex $params 1] 1] \
	    [lindex [lindex $params 2] 1] \
	    \$$xParm \$$yParm [lindex $parm 0 ] \
	    [lindex [lindex $params 6] 1] \
	    [lindex [lindex $params 7] 1] \
	    [lindex [lindex $params 8] 1] \
	    [lindex $parm 1] \
	    [lindex [lindex $params 10] 1] \
	    [lindex [lindex $params 11] 1] ]

    # Change parameter
    set cmd "DEVise changeParam \{$map\} $params"
    # puts "ChangeParam $map $params"
    set result [eval $cmd]
    
    # Refresh all views that use this mapping
    set views [ViewSet]
    foreach view $views {
	set mappings [DEVise getViewMappings $view]
	set contains 0
	foreach m $mappings {
	    if {$m == $map} {
		set contains 1
		break
	    }
	}
	if {$contains > 0} {
	    # puts "refreshView $view"
	    DEVise invalidatePixmap $view
	    DEVise refreshView $view
	}
    }
}

# Create a Cursor, return its name
proc DoCursorCreate { } {
    global dialogCkButVar 

    set but [dialogCkBut .createCursor "Create Cursor" \
	    "Enter parameters for creating a new cursor" "" \
	    0 {Cancel OK} name {x y} {3}]
    if { $but != 1 } {
	return ""
    }
    set flag $dialogCkButVar(selected)
    set name $dialogCkButVar(entry)
    if { [string compare $name ""] == 0 } {
	set but [dialog .noName "NoName" \
		"Error: No name for cursor specified" "" 0 {Continue }]
	return 
    }

    if { [DEVise exists $name ] } {
	set but [dialog .linkExists "LinkExists" \
		"Error: Cursor name $name already exists" "" 0 {Continue }]
	return 
    }

    set result [DEVise create cursor Cursor $name $flag]
    if { [string compare $result "" ] == 0 } {
	set but [ dialog .cursorError "CursorError" \
		"Can't create cursor" "" 0 {OK} ]
	return
    }

    return $name
}

proc DoGetCursor { } {
    global curView dialogListVar

    set cursorSet [CursorSet]
    if { [llength $cursorSet] == 0 } {
	set cursor [DoCursorCreate]
    } else {
	set answer [ dialogList .getCursor "GetCursor" "Select cursor for\
		view\n$curView" "" 0 \
		{ New Cancel OK } $cursorSet ]
	if { $answer == 0 } {
	    set cursor [ DoCursorCreate ]
	} elseif { $answer == 1 || \
		[ string compare $dialogListVar(selected) "" ] == 0 } {
	    set cursor ""
	} else {
	    set cursor $dialogListVar(selected)
	}
    }

    return $cursor
}


proc DoSetCursorSrc { } {
    global curView dialogListVar

    if { [ string compare $curView "" ] ==  0 } {
	set but [dialog .cursorError "CursorError " \
		"Please select a view first by clicking in it" "" 0 {OK} ]
	return
    }

    set cursor [DoGetCursor]
    if { [string compare $cursor "" ] == 0 } {
	return
    }

    set answer [DEVise setCursorSrc $cursor $curView]
}

proc DoSetCursorDst { } {
    global curView dialogListVar

    if { [ string compare $curView "" ] ==  0 } {
	set but [dialog .cursorError "CursorError " \
		"Please select a view first by clicking in it" "" 0 {OK} ]
	return
    }
    
    set cursor [DoGetCursor]
    if { [string compare $cursor "" ] == 0 } {
	return
    }
    
    set answer [DEVise setCursorDst $cursor $curView]
}

# Create a link, return its name
proc DoLinkCreate { } {
    global dialogCkButVar 

    set but [dialogCkBut .createLink "Create Link" \
	    "Enter parameters for creating a new link" "" \
	    0 {Cancel OK} name {x y color size pattern orientation shape} {3}]
    if { $but != 1 } {
	return ""
    }

    set flag $dialogCkButVar(selected)
    set name $dialogCkButVar(entry)
    if { [string compare $name ""] == 0 } {
	set but [dialog .noName "NoName" \
		"Error: No name for link specified" "" 0 {Continue }]
	return 
    }
    
    if { [DEVise exists $name ] } {
	set but [dialog .linkExists "LinkExists" \
		"Error: Link name $name already exists" "" 0 {Continue }]
	return 
    }

    set result [DEVise create link Visual_Link $name $flag]
    if { [string compare $result "" ] == 0 } {
	set but [ dialog .linkError "LinkError" \
		"Can't create link" "" 0 {OK} ]
	return
    }

    return $name
}

# Display the views in a link 
proc DisplayLinkInfo { link } {
    set views [DEVise getLinkViews $link]
    if { [llength $views] == 0 } {
	dialog .linkInfo "LinkInfo" \
		"Link $link currently does not link any view" "" 0 {OK} ]
	return
    }
    dialogList .linkInfo "LinkInfo" "Views linked by $link" "" 0 {OK} $views
}

# Link current view
proc DoViewLink { } {
    global curView dialogListVar

    if { [ string compare $curView "" ] ==  0 } {
	set but [dialog .linkError "LinkViewError" \
		"Please select a view first by clicking in it" "" 0 {OK} ]
	return
    }

    while { 1 } {
	set linkSet [LinkSet]
	if { [llength $linkSet] == 0 } {
	    set link [DoLinkCreate]
	} else {
	    set answer [ dialogList .getLink "GetLink" "Select a link for\
		    view\n$curView" "" 0 \
		    { Info New Cancel OK } $linkSet ]
	    if { $answer == 0 } {
		if { [string compare $dialogListVar(selected) "" ] != 0 } {
		    DisplayLinkInfo $dialogListVar(selected)
		}
	    } elseif { $answer == 1 } {
		set link [ DoLinkCreate ]
	    } elseif { $answer == 2 || \
		    [ string compare $dialogListVar(selected) "" ] == 0 } {
		set link ""
		break
	    } else {
		set link $dialogListVar(selected)
		break
	    }
	}
    }

    if { [ string compare $link "" ] == 0 } {
	return
    }

    set anwer [DEVise insertLink $link $curView]
    # if {$anwer != 0 } {
	# set but [ dialog .linkError "LinkError" \
		# "Can't insert view $curView into link $link" "" 0 {OK} ]
    #}
}

# Unlink current view
proc DoViewUnlink { } {
    global curView dialogListVar
    if { [ string compare $curView "" ] ==  0 } {
	set but [dialog .unlinkError "UnlinkViewError" \
		"Please select a view first by clicking in it" "" 0 {OK} ]
	return
    }

    set linkSet [LinkSet]
    set viewLinks ""
    foreach link $linkSet {
	if { [DEVise viewInLink $link $curView] } {
	    lappend viewLinks $link
	}
    }

    if { [llength $viewLinks ] == 0 } {
	set but [ dialog .removeLink "RemoveLink" \
		"View $curView has no established link" "" 0 {OK} ]
    } else {
	set answer [ dialogList .getLink "GetLink" \
		"Select a link to unlink for view $curView" "" 0 \
		{ Cancel OK } $linkSet ]
	if { $answer == 0 } {
	    return
	} elseif { [ string compare $dialogListVar(selected) "" ] == 0 } {
	    return
	} else {
	    DEVise unlinkView $dialogListVar(selected) $curView
	}
    }
}

# Modify parameters of a link
proc DoModifyLink { } {
    global dialogCkButVar dialogListVar
    set linkSet [LinkSet]
    if { [llength $linkSet ] == 0 } {
	set but [dialog .linkModError "LinkModError" \
		"No link has been created yet" "" 0 {OK} ]
	return
    }
    
    # Select a link
    set answer [ dialogList .getLink "GetLink" \
	    "Select a link to modify param" "" 0 \
	    { Cancel OK } $linkSet ]
    if { $answer == 0 } {
	return
    } elseif { [ string compare $dialogListVar(selected) "" ] == 0 } {
	return
    } else {
	set link $dialogListVar(selected)
    }

    # enter parameters for the link
    set flag [DEVise getLinkFlag $link]
    set but [dialogCkBut .modLink "Modify Link" \
	    "Enter parameters for link $link" "" \
	    0 {Cancel OK} "" {x y color size pattern orientation shape} $flag]
    if { $but != 1 } {
	return ""
    }
    set flag $dialogCkButVar(selected)
    DEVise setLinkFlag $link $flag
}

proc CheckView { } {
    global curView
    if { [ string compare $curView "" ] ==  0 } {
	set but [dialog .viewError "ViewError" \
		"Please select a view first by clicking in it" "" 0 {OK} ]
	return 0
    }
    return 1
}

# Actually create a new axis Label
proc DoActualCreateAxisLabel { type } {
    global dialogParamVar 
    set paramNames [ DEVise getparam axisLabel $type]
    
    set button [ dialogParam .axisParam "AxisParam" \
	    "Enter parameters to create axis $type"\
	    "" 1 { Cancel OK } $paramNames ]
    if { $button == 0} {
	return
    }

    set cmd "DEVise create axisLabel $type $dialogParamVar(params)"
    set result [ eval $cmd ]
    if { [string compare $result "" ] == 0 } {
	set but [ dialog .axisError "AxisError" \
		"Can't create axis" "" 0 {OK} ]
	return
    }

    return $result
}

# Create a new axis label
proc DoCreateAxisLabel { } {
    global dialogListVar
    set axisTypes [ DEVise get axisLabel]
    set answer [ dialogList .createAxis "CreateAxis"  \
	    "Select type of axis label to create" "" "" \
	    { Cancel Ok } $axisTypes ]
    if { $answer == 0 || \
	    [ string compare $dialogListVar(selected) "" ] == 0 } {
	return
    } else {
	return [ DoActualCreateAxisLabel $dialogListVar(selected) ]
    }
}

# Get an axis label for current view
proc DoGetAxisLabel { } {
    global curView dialogListVar
    set axisSet [AxisSet]
    if { [llength $axisSet] == 0 } {
	set axisLabel [ DoCreateAxisLabel]
    } else {
	set answer [ dialogList .getAxisLabel "GetAxisLabel" "Select a \
		axis label for view $curView,\n\
		or press <New> to create a new one"\
		"" 0 { New Cancel OK } $axisSet ]
	if { $answer == 0 } {
	    set axisLabel [ DoCreateAxisLabel ]
	} elseif { $answer == 1 || \
		[ string compare $dialogListVar(selected) "" ] == 0 } {
	    set axisLabel ""
	} else {
	    set axisLabel $dialogListVar(selected)
	}
    }

    return $axisLabel
}

proc DoViewAxis { axis } {
    global curView
    if { ! [CheckView] } {
	return
    }
    set axisLabel [DoGetAxisLabel]
    if { [string compare $axisLabel "" ] == 0 } {
	return
    }
    
    DEVise setAxis $curView $axisLabel $axis
}

proc DoActualCreateAction { type } {
    global dialogParamVar 
    set paramNames [ DEVise getparam action $type]
    
    set button [ dialogParam .actionParam "ActionParam" \
	    "Enter parameters to create action $type"\
	    "" 1 { Cancel OK } $paramNames ]
    if { $button == 0} {
	return
    }
    
    set cmd "DEVise create action $type $dialogParamVar(params)"
    set result [ eval $cmd ]
    if { [string compare $result "" ] == 0 } {
	set but [ dialog .actionError "ActionError" \
		"Can't create action" "" 0 {OK} ]
	return
    }
    return $result
}

# Create an action
proc DoCreateAction { } {
    global dialogListVar
    set actionTypes [ DEVise get action]
    set answer [ dialogList .createAction "CreateAction"  \
	    "Select type of action to create" "" "" { Cancel Ok } $actionTypes]
    if { $answer == 0 || \
	    [ string compare $dialogListVar(selected) "" ] == 0 } {
	return
    } else {
	return [ DoActualCreateAction $dialogListVar(selected) ]
    }
}

# Get an action
proc DoGetAction { } {
    global curView dialogListVar
    set actionSet [ActionSet ]
    if { [llength $actionSet] == 0 } {
	set action [ DoCreateAction]
    } else {
	set answer [dialogList .getAction "GetAction" "Select an \
		action for view\n$curView"\
		"" 0 { New Cancel OK } $actionSet]
	if { $answer == 0 } {
	    set action [ DoCreateAction]
	} elseif { $answer == 1 || \
		[ string compare $dialogListVar(selected) "" ] == 0 } {
	    set action ""
	} else {
	    set action $dialogListVar(selected)
	}
    }
    return $action
}

# Add an action for view
proc DoViewAction { } {
    global curView
    if { ! [CheckView] } {
	return
    }
    set action [DoGetAction]
    if { [string compare $action "" ] == 0 } {
	return
    }
    
    DEVise setAction $curView $action
}

# Close current session
proc DoClose { } {
    set but [dialog .open OpenSession "Close Current Session?" \
	    "" 1 Cancel Ok ]
    if { $but == 0 } {
	return 0
    }
    
    ProcessViewSelected ""
	
    foreach tdata [TdataSet] {
	# puts "destroying tdata $tdata"
	DEVise destroy $tdata
    }
    
    foreach gdata [GdataSet] {
	# puts "destroying gdata $gdata"
	DEVise destroy $gdata
    }
    
    foreach cursor [CursorSet] {
	DEVise destroy $cursor
    }
    
    foreach view [ViewSet] {
	# puts "destroying view $view"
	DEVise destroy $view
    }

    foreach link [LinkSet] {
	# puts "destroying link $link"
	DEVise destroy $link
    }
    
    foreach win [WinSet] {
	# puts "destroying window $win"
	DEVise destroy $win
    }
    
    foreach axis [AxisSet] {
	# puts "destroying axis $axis"
	DEVise destroy $axis
    }

    foreach action [ActionSet ] {
	# puts "destroying action $action"
	DEVise destroy $action
    }

    DEVise clearQP
    DEVise clearInterp
    
    return 1
}

# Do open a session file
proc DoOpen { asTemplate} {
    global fsBox datadir

    # DEVise printDispatcher

    if {! [DoClose] } {
	# abort opening a new session
	return
    }
    
    # Get a session file name
    set fsBox(path) $datadir
    set fsBox(pattern) *.tk
    set file [ FSBox "Select session file" ]
    
    if { [ string compare $file "" ] == 0 } {
	return
    }

    # open the session 
    if { $asTemplate} {
	DEVise openTemplate $file
    } else {
	DEVise openSession $file
    }
}

proc DoDemo { } {
    global libdir fsBox
    set fsBox(path) $libdir/demo
    DoOpen 0
}

# Return line width of string. New lines are accounted for.
# For example, "abc\ndefg" has a line width of 4
proc LineWidth { txt } {
    set strLen [string length $txt]
    set width 0
    set curWidth 0
    for { set i 0} { $i < $strLen } {set i [expr $i+1] } {
	if { [string compare [string index $txt $i] \n] == 0 } {
	    if {$curWidth > $width} {
		set width $curWidth
	    }
	    set curWidth 0
	} else {
	    set curWidth [expr $curWidth+1]
	}
    }
    if {$curWidth > $width} {
	set width $curWidth
    }
    return $width
}

# Return # of lines in string 
# For example, "abc\ndefg" has 2 lines
proc LineHeight { txt } {
    set strLen [string length $txt]
    set height 0
    for { set i 0} { $i < $strLen } {set i [expr $i+1] } {
	if { [string compare [string index $txt $i] \n] == 0 } {
	    set height [expr $height+1]
	}
    }
    set height [expr $height+1]
    return $height
}

# Find a view that uses the specified TData, the mapping class, and
# the specified viewClass.
proc GetView { tdata mapClass viewClass } {
    set views [DEVise get view $viewClass]
    foreach view $views {
	if { ![DEVise isMapped $view] } {
	    # view not yet mapped, see if we can use it.
	    set map [lindex [DEVise getViewMappings $view] 0]
	    set viewMapClass [GetClass mapping $map]
	    set mapParam [DEVise getCreateParam mapping $mapClass $map]
	    set viewTData [lindex $mapParam 0]
	    if {[string compare $mapClass $viewMapClass] == 0 && \
		    [string compare $viewTData $tdata] == 0 } {
		# found
		return $view
	    }
	}
    }

    # not found
    return ""
}

# Find a mapping (GData)that uses the specified TData, and the mapping class
proc GetMapping { tdata mapClass} {
    set maps [DEVise get mapping $mapClass]
    foreach map $maps {
	set mapParam [DEVise getCreateParam mapping $mapClass $map]
	set viewTData [lindex $mapParam 0]
	if {[string compare $viewTData $tdata] == 0 } {
	    # found
	    return $map
	}
    }

    # not found
    return ""
}

# Switch to a different TData for current view.
# We implement it by creating a new view and putting it it place
# of the current one
proc DoSwitchTData { } {
    global curView
    if { [string compare $curView ""] == 0 } {
	dialog .switchTData "Switch TData" \
		"Please select a view by clicking in it first." "" 0 { OK } 
	return
    }
    
    # select TData
    set tdata [DoSelectTData]
    if { [string compare $tdata "" ] == 0} {
	# no tdata
	return
    }
    
    # Get mapping for the view
    set map [lindex [DEVise getViewMappings $curView] 0]
    
    # Compare the schema of the tdata
    set curMapClass [GetClass mapping $map]
    puts "curMapClass $curMapClass tdata $tdata"
    set curMapParam [DEVise getCreateParam mapping $curMapClass $map]
    set curViewTData [lindex $curMapParam 0]
    
    if { [string compare $curViewTData $tdata] == 0 } {
	dialog .switchTDataErr "Switch TData" \
		"You have selected the same tdata" "" 0 { continue }
	return
    }
    
    set viewTDataClass [GetClass tdata $curViewTData]
    set tdataClass [GetClass tdata $tdata]
    if { [string compare $viewTDataClass $tdataClass ] != 0 } {
	dialog .switchTDataErr "Switch TData" \
		"The selected TData has type $tdataClass,\n\
		incompatible with the tdata in the view" "" 0 { OK } 
	return
    }
    
    # See if the new view is already created.
    set view [GetView $tdata $curMapClass [GetClass view $curView]]
    if { [string compare $view "" ] == 0 } {
	# need to create a new view
	# First, see if we need to create a new GData
	set mapName [GetMapping $tdata $curMapClass]
	if { [string compare $mapName "" ] == 0 } { 
	    # create a new mapping.
	    set mapName [UniqueName [format "%s#%s" $tdata $curMapClass]]
	    set newMapParam [linsert [lrange $curMapParam 2 end] 0 $tdata \
		    $mapName]
	    set cmd "DEVise create mapping $curMapClass $newMapParam"
	    set result [ eval $cmd]
	    if { [string compare $result "" ] == 0 } {
		set but [ dialog .CreateError "Can't create mapping" \
			"" 0 {OK} ]
		return
	    }
	}

	# Create a new view
	set curViewClass [GetClass view $curView]
	set curViewParam [DEVise getCreateParam view $curViewClass $curView]
	set view [UniqueName [format "%s#%s" $mapName $curViewClass]]
	set newViewParam [linsert [lrange $curViewParam 1 end] 0 $view]
	set cmd "DEVise create view $curViewClass $newViewParam"
	set result [ eval $cmd ]
	if { [string compare $result "" ] == 0 } {
	    set but [ dialog .CreateError "Can't create view" "" 0 {OK} ]
	    return
	}
	DEVise insertMapping $view $mapName
    } 

    # select new view
    if { [string compare $view "" ] != 0 } {
	DEVise replaceView $curView $view
	ProcessViewSelected $view
    }
}

proc CloseHistory { } {
    global historyWinOpened
    destroy .historyWin
    set historyWinOpened 0
}

proc DoHistoryToggle { } {
    global historyWinOpened
    if { $historyWinOpened} {
	CloseHistory
    } else {
	OpenHistory
    }
}


# Do history command here.
proc OpenHistory { } {
    global curView historyWinOpened LightBlue
    
    if { $historyWinOpened } {
	return
    }
    
    set w .historyWin
    toplevel $w 
    wm title $w "DEVise history"
    wm geometry $w +100+100
    wm iconname $w "history"

    frame $w.heading -background LightBlue
    label $w.markHeading -text mark
    label $w.xlowHeading -text xlow
    label $w.xhighHeading -text xhigh
    label $w.ylowHeading -text ylow
    label $w.yhighHeading -text yhigh
    
    pack $w.markHeading -side left -in $w.heading 
    pack $w.xlowHeading $w.xhighHeading $w.ylowHeading \
	    $w.yhighHeading -side left -in $w.heading -expand 1 -fill x
    
    frame $w.lists -background LightBlue
    listbox $w.listMark -yscrollcommand "$w.scroll set" \
	    -relief raised -geometry 2x10
    tk_listboxSingleSelect $w.listMark
    
    foreach i { listXlow listYlow listXhigh listYhigh } {
	listbox $w.$i -yscrollcommand "$w.scroll set" \
		-relief raised -geometry 21x10
	tk_listboxSingleSelect $w.$i
    }
    bind $w.listMark <Button-1> {
	set sel [.historyWin.listMark nearest %y]
	if { $sel >= 0 } {
	    ProcessMarkSelected $sel
	}
    }
    
    bind $w.listXlow <Button-1> {
	set sel [.historyWin.listXlow nearest %y]
	if { $sel >= 0 } {
	    ProcessHistorySelected $sel
	}
    }
    bind $w.listYlow <Button-1> {
	set sel [.historyWin.listYlow nearest %y]
	if { $sel >= 0 } {
	    ProcessHistorySelected $sel
	}
    }
    
    bind $w.listXhigh <Button-1> {
	set sel [.historyWin.listXhigh nearest %y]
	if { $sel >= 0 } {
	    ProcessHistorySelected $sel
	}
    }
    
    bind $w.listYhigh <Button-1> {
	set sel [.historyWin.listYhigh nearest %y]
	if { $sel >= 0 } {
	    ProcessHistorySelected $sel
	}
    }
    scrollbar $w.scroll -command "DoScrollBar"
    
    button $w.close -text "Close" -command {CloseHistory}
    
    pack $w.close -side bottom
    
    pack $w.scroll -in $w.lists -side right -fill both
    pack  $w.listYhigh $w.listYlow $w.listXhigh $w.listXlow\
	    -in $w.lists -side right 
    pack $w.listMark -in $w.lists -side left 
    
    pack $w.heading $w.lists -side top -fill x -expand 1
    
    set historyWinOpened 1
    
    if { [string compare $curView "" ] != 0 } {
	# Init history with history of current view
	set filters [DEVise getVisualFilters $curView]
	foreach filter $filters {
	    .historyWin.listXlow insert 0 [lindex $filter 0]
	    .historyWin.listXhigh insert 0 [lindex $filter 2]
	    .historyWin.listYlow insert 0 [lindex $filter 1]
	    .historyWin.listYhigh insert 0 [lindex $filter 3]
	    if { [lindex $filter 4] == 0 } {
		set mark " "
	    } else {
		set mark "*"
	    }
	    .historyWin.listMark insert 0 $mark
	}
    }
}
 

proc DoScrollBar { arg } {
    foreach i { listMark listXlow listXhigh listYlow listYhigh } {
	.historyWin.$i yview $arg
    }
}

proc ClearHistory { } {
    global historyWinOpened
    if {$historyWinOpened} {
	foreach i { listMark listXlow listXhigh listYlow listYhigh } {
	    .historyWin.$i select clear
	    .historyWin.$i delete 0 end
	}
    }
}

proc DoUndoEdit { } {
    global curView
    
    if { [string compare $curView "" ] == 0 } {
	return
    }
    
    set filters [DEVise getVisualFilters $curView] 
    set filter [lindex $filters [expr [llength $filters]-1]]
    
    foreach i { xlow ylow xhigh yhigh} {
	.history.$i delete 0 end
    }
    .history.xlow insert 0 [lindex $filter 0]
    .history.ylow insert 0 [lindex $filter 1]
    .history.xhigh insert 0 [lindex $filter 2]
    .history.yhigh insert 0 [lindex $filter 3]
}

proc DoGoBackOne { } {
    global curView
    
    if { [string compare $curView "" ] == 0 } {
	return
    }
    
    set filters [DEVise getVisualFilters $curView] 
    set len [llength $filters ]
    if { $len <= 1} {
	return
    }
    set filter [lindex $filters [expr $len-2]]
    
    foreach i { xlow ylow xhigh yhigh} {
	.history.$i delete 0 end
    }
    .history.xlow insert 0 [lindex $filter 0]
    .history.ylow insert 0 [lindex $filter 1]
    .history.xhigh insert 0 [lindex $filter 2]
    .history.yhigh insert 0 [lindex $filter 3]
}


# duplicate window
proc DupWindow { } {
    global curView
    if { [ string compare $curView "" ] ==  0 } {
	set but [dialog .dupWinError "DupWindowError" \
		"Please select a window by clicking any view in it" "" 0 {OK} ]
	return
    }
    set win [DEVise getViewWin $curView]
    set views [DEVise getWinViews $win]
    
    # Create mappings for views
    set newViews ""
    foreach view $views {
	# Crete a new view
	set class [GetClass  view $view]
	set params [ DEVise getCreateParam view $class $view]
	set viewName [lindex $params 0]
	set newName [UniqueName $viewName]

	# replace name of view by name of new view
	set newParam [linsert [lrange $params 1 end] 0 $newName]
	# puts "DEVise create view $class $newParam"
	eval DEVise create view $class $newParam
	
	lappend newViews $newName
	
	set maps [DEVise getViewMappings $view]
	foreach map $maps {
	    DEVise insertMapping $newName $map
	}
    }

    # Create new window
    set class [GetClass window $win]
    set params [ DEVise getCreateParam window $class $win]
    set newWin [UniqueName $win]
    set newParam [linsert [lrange $params 1 end] 0 $newWin]
    eval DEVise create window $class $newParam
    
    foreach view $newViews {
	DEVise insertWindow $view $newWin
    }
}

proc DoToggleAxis { axis } {
    global curView
    if { [ string compare $curView "" ] ==  0 } {
	set but [dialog .toggleWinError "ToggleAxisError" \
		"Please select a view by clicking in it" "" 0 {OK} ]
	return
    }
    
    set stat [ DEVise getAxisDisplay $curView $axis]
    set stat [expr !$stat]
    DEVise setAxisDisplay $curView $axis $stat
}

proc DoToggleAxisAllViews { axis } {
    global curView
    if { [ string compare $curView "" ] ==  0 } {
	set but [dialog .toggleWinError "ToggleAxisError" \
		"Please select a view by clicking in it" "" 0 {OK} ]
	return
    }
    
    set stat [ DEVise getAxisDisplay $curView $axis]
    set stat [expr !$stat]
    
    set viewClasses [ DEVise get view ]
    foreach viewClass $viewClasses {
	set views [ DEVise get view $viewClass ]
	foreach v $views {
	    DEVise setAxisDisplay $v $axis $stat
	}
    }
}

proc DoSwapView { } {
    global curView lastView dialogListVar
    if { [ string compare $curView "" ] ==  0  ||
    [string compare $lastView "" ] == 0 ||
    [string compare $curView $lastView] == 0 } {
	set but [dialog .swapViewError "SwapViewError" \
		"Please select two views by clicking in them in order\n\
		The views must be in the same window." "" 0 {OK} ]
	return
    }

    # Find all views in a window
    set win1 [DEVise getViewWin $curView]
    set win2 [DEVise getViewWin $lastView]
    if { [string  compare $win1 $win2] != 0 } {
	set but [dialog .swapViewError "SwapViewError" \
		"Please select two views by clicking in them in order\n\
		The views must be in the same window." "" 0 {OK} ]
	return
    }

    DEVise swapView $win1 $curView $lastView
}

proc DoSavePixmap { } {
    global curView lastView dialogListVar
    if { [ string compare $curView "" ] ==  0 } {
	set but [dialog .swapViewError "SwapViewError" \
		"Please select two views by clicking in them in order\n\
		The views must be in the same window." "" 0 {OK} ]
	return
    }
    
    set file [DEVise open pixmap.tmp wb]
    DEVise savePixmap $curView $file
    DEVise close $file
}

proc DoLoadPixmap { } {
    global curView lastView
    if { [ string compare $curView "" ] ==  0 } {
	set but [dialog .swapViewError "LoadPixmapError" \
		"Please select two views by clicking in them in order\n\
		The views must be in the same window." "" 0 {OK} ]
	return
    }
    
    set file [DEVise open pixmap.tmp rb]
    DEVise loadPixmap $curView $file
    DEVise close $file
}

# Get a new TData for a template
# Return name of new TData.
# input:
#	type: file type
#	total: total number of Tdata to import
#	num: number for the tdata, [1..total].
# This procedure asks user for file name, and imports it as 
# the new TData
proc GetTDataTemplate { type total num} {
    global fsBox dialogParamVar datadir

    # Get file name
    set fsBox(path) $datadir
    set fsBox(pattern) *

    while { 1 } {
	set file [ FSBox "Select file $num of $total, type $type" ]
	if { [ string compare $file "" ] == 0 } {
	    return ""
	}

	if  { [FileExist $file ] } {
	    set but [dialog .fileExist "File Exists" \
		    "File $file already loaded\n\
		    Please select another file" "" 0 Continue]
	} else {
	    break
	}
    }

    while { 1 } {
	set fileAlias [ TrimPath $file ]
	set tempParam [list [ list  FileAlias $fileAlias ] ]
	set button [ dialogParam .fileParam "FileParam" \
		"Enter Alias for file\n\
		$file\n\
		(Note: it may take a while for the program\n\
		to come back after clicking <OK>)"  "" 1  \
		{ Cancel OK } $tempParam]
	if { $button == 0} {
	    return ""
	}
	set fileAlias [ lindex $dialogParamVar(params) 0 ]
	
	if { [DEVise exists $fileAlias] } {
	    # This file alias already exists in memory.
	    set but [dialog .fileExist "FileExist" \
		    "error: TData $fileAlias exists" "" 1 {continue}]
	} else {
	    break
	}
    }

    DEVise create tdata $type $file $fileAlias
    return $fileAlias
}

proc NotImplemented {} {
    dialog .notImplemented "Not Implemented" \
	    "This feature not implemented yet." \
	    "" 0 OK
}

proc MacroDefInit {} {
    MacroDefClear
}

proc MacroDefStart {} {
    global tdatas schemas maps mappings views links windows session modified

    # see if .map window already exists; if so, just return
    set err [catch {set exists [wm state .map]}]
    if {!$err} { return }

    # clear tdatas, schemas, windows, and links because they can be
    # reconstructed from DEVise data structures; maps, mappings,
    # and views cannot be safely reconstructed
    
    set tdatas ""
    catch {unset schemas}
    catch {unset links}
    catch {unset windows}

    # the following are required for the old Tcl to work properly;
    # these define arrays with zero elements

    set schemas(a) a
    unset schemas(a)
    set links(a) a
    unset links(a)
    set windows(a) a
    unset windows(a)

    foreach schema [DEVise get tdata] {
	set err [catch {set exists $maps($schema)}]
	if {$err > 0} { set maps($schema) "" }
	foreach tdata [DEVise get tdata $schema] {
	    set params [DEVise getCreateParam tdata $schema $tdata]
	    set filePath [lindex $params 0]
	    set fileAlias [lindex $params 1]
	    lappend tdatas [list $fileAlias $filePath]
	    set sdef [DEVise getSchema $tdata]
	    set schemas($tdata) [list $schema $sdef]
	}
    }

    foreach class [lsort [DEVise get "mapping"]] {
	foreach mapping [lsort [DEVise get "mapping" $class]] {
	    set params [DEVise getCreateParam "mapping" $class $mapping]
	    set tdata [lindex $params 0]
	    set schema [lindex $schemas($tdata) 0]
	    set mapname [lindex $params 1]
	    set firsthash [string first \# $mapname]
	    if {$firsthash >= 0} {
		incr firsthash
		set mapname [string range $mapname $firsthash end]
	    }
	    set x [string range [lindex $params 3] 1 end]
	    set y [string range [lindex $params 4] 1 end]
	    set color [lindex $params 5]
	    set shape [lindex $params 9]
	    set size 1
	    set pattern ""
	    set orient ""
	    set defn [list $x $y $color $shape $size $pattern $orient]
	    
	    set mappings($mapname) $defn
	    if {[string first $mapname $maps($schema)] < 0} {
		lappend maps($schema) $mapname
	    }
	}
    }

    foreach class [lsort [DEVise get "window"]] {
	foreach window [lsort [DEVise get "window" $class]] {
	    set params [DEVise getCreateParam "window" $class $window]
	    set name [lindex $params 0]
	    set windows($name) [lrange $params 1 end]
	}
    }

    foreach class [lsort [DEVise get "link"]] {
	foreach link [lsort [DEVise get "link" $class]] {
	    set params [DEVise getCreateParam "link" $class $link]
	    set name [lindex $params 0]
	    set links($name) [lrange $params 1 end]
	}
    }

    foreach class [lsort [DEVise get "view"]] {
	foreach view [lsort [DEVise get "view" $class]] {
	    set params [DEVise getCreateParam "view" $class $view]
	    set name [lindex $params 0]
	    set firsthash [string first \# $name]
	    if {$firsthash < 0} { continue }
	    incr firsthash
	    set name [string range $name $firsthash end]
	    set secondhash [string first \# $name]
	    if {$secondhash >= 0} {
		incr secondhash -1
		set name [string range $name 0 $secondhash]
	    }
	    set views($name) [lrange $params 1 end]
	}
    }

    set modified 0
    MacroDef
}

proc MacroDef {} {
    global tdatas schemas maps mappings views links windows session
    global tdata window gdata view link none

    # see if .map window already exists; if so, just return
    set err [catch {set exists [wm state .map]}]
    if {!$err} { return }

    set none "-- None --"

    toplevel .map
    MacroDefTitle .map
    wm geometry .map =600x350+50+50
    selection clear .map

    frame .map.top
    frame .map.but
    pack .map.top -side top -pady 3m -fill both -expand 1
    pack .map.but -side top -pady 3m -fill x

    frame .map.but.row1
    frame .map.but.row2
    pack .map.but.row1 .map.but.row2 -side top -pady 3m -padx 10m \
	    -fill both -expand 1

    button .map.but.save -text Save -width 12 -command {
	if {$session == ""} {
	    .map.but.saveas invoke
	} else {
	    MacroDefSave $session.tk
	}
    }
    button .map.but.saveas -text "Save as..." -width 12 -command {
	if {[MacroDefSession "Save Session"] > 0} {
	    MacroDefTitle .map
	    MacroDefSave $session.tk
	}
    }
    button .map.but.load -text "Load..." -width 12 -command MacroDefLoad
    button .map.but.auto -text "Auto..." -width 12 -command {
	MacroDefAuto $tdata
    }
    pack .map.but.save .map.but.saveas .map.but.load .map.but.auto \
	    -in .map.but.row1 -side left -padx 5m

    button .map.but.ok -text OK -width 12 -command {
	MacroDefNewMapping
	destroy .map
    }
    button .map.but.apply -text Apply -width 12 -command {
	MacroDefNewMapping
    }
    button .map.but.cancel -text Cancel -width 12 -command "destroy .map"
    button .map.but.help -text Help -width 12 -command MacroDefHelp
    pack .map.but.ok .map.but.apply .map.but.cancel .map.but.help \
	    -in .map.but.row2 -side left -padx 5m

    frame .map.left -relief groove -borderwidth 2
    frame .map.right -relief groove -borderwidth 2
    pack .map.left .map.right -in .map.top -side left \
	    -fill both -expand 1

    frame .map.tdata
    frame .map.window
    frame .map.gdata
    frame .map.view
    frame .map.link
    pack .map.tdata .map.window -in .map.left -side top -pady 3m \
	    -fill both -expand 1
    pack .map.gdata .map.view .map.link -in .map.right -side top -pady 3m \
	    -fill both -expand 1

    MacroDefTdata .map.tdata "$none"
    MacroDefWindows .map.window "$none"
    MacroDefMaps .map.gdata "$none"
    MacroDefViews .map.view "$none"
    MacroDefLinks .map.link "$none"

    tkwait visibility .map
#    grab set .map
#    tkwait window .map
}

proc MacroDefTitle {m} {
    global session

    if {$session == ""} {
	wm title $m "Define Visualization"
    } else {
	wm title $m "Define Visualization - $session"
    }
}

proc MacroDefNewMapping {} {
    global tdatas schemas maps mappings views links windows
    global tdata window gdata view link none

    if {$tdata == $none || $window == $none} { return }
    if {$gdata == $none || $view == $none} { return }

    set x [lindex $mappings($gdata) 0]
    set y [lindex $mappings($gdata) 1]
    set color [lindex $mappings($gdata) 2]
    set shape [lindex $mappings($gdata) 3]

    # ask DEVise to create view instance
    set sorted SortedX
    set viewname $tdata#$view#$x#$y
    if {[lsearch [ViewSet] $viewname] >= 0} {
	dialog .viewError "View Error" \
		"View $viewname exists already." "" 0 OK
	return
    }
    set cmd [concat DEVise create view $sorted \{$viewname\} $views($view)]
    # puts "cmd = $cmd"
    set result [eval $cmd]
    if {$result == ""} {
	dialog .viewError "View Error" \
		"Error creating view $viewname" "" 0 OK
	return
    }

    if {[lsearch [DEVise get mapping] $gdata] < 0} {
	# ask DEVise to create interpreted mapping
	# parameter format: x y color size pattern orientation shape
	set result [DEVise createInterp $tdata $gdata "" \$$x \$$y \
		$color "" "" "" $shape "" ""]
    }

    set mapinstance "$tdata#$gdata" 
    if {[lsearch [GdataSet] $mapinstance] < 0} {
	# ask DEVise to create an instance of mapping
	set result [DEVise create mapping $gdata $tdata $mapinstance \
		"" \$$x \$$y $color "" "" "" $shape "" ""]
	DEVise setPixelWidth $mapinstance 1
    }

    # ask DEVise to insert $viewname into $mapinstance
    set result [DEVise insertMapping $viewname $mapinstance]
    # seems that there's no error code returned

    # ask DEVise to insert $viewname into $window
    set result [DEVise insertWindow $viewname $window]
    # seems that there's no error code returned

    if {$link != $none} {
	# ask DEVise to link $viewname to $link
	set result [DEVise insertLink $link $viewname]
	# seems that there's no error code returned
    }

    ProcessViewSelected $viewname

    # DoToggleAxis X
    DoToggleAxis Y
}

proc MacroDefSession {title} {
    global session newsession

    # see if .session window already exists; if so, just return
    set err [catch {set exists [wm state .session]}]
    if {!$err} { return 0 }

    toplevel .session
    wm title .session $title
    wm geometry .session +100+100
    selection clear .session

    frame .session.entry
    frame .session.but
    pack .session.entry .session.but -side top -pady 3m -padx 3m \
	    -fill both -expand 1

    set newsession $session
    label .session.label -text "Enter session name:"
    entry .session.name -relief sunken -width 15 -textvariable newsession
    pack .session.label .session.name -in .session.entry \
	    -side left -fill x -expand 1

    button .session.ok -text OK -width 10 -command { destroy .session }
    button .session.cancel -text Cancel -width 10 -command {
	set newsession ""
	destroy .session
    }
    pack .session.ok .session.cancel -in .session.but -side left -padx 5m \
	    -fill x -expand 1

    tkwait visibility .session
    grab set .session
    tkwait window .session

    if {$newsession == ""} {
	return 0
    }
    set session $newsession
    return 1
}

proc MacroDefSave {fname} {
    global tdatas schemas maps mappings views links windows session modified

    if {[file readable $fname]} {
	set but [dialog .fileExists "File Exists" \
		"Warning: File $fname exists already." \
		"" 0 Overwrite Cancel]
	if {$but == 1} { return }
    }

    set err [catch {set f [open $fname w]} ]
    if {$err > 0} {
	dialog .cannotWrite "Cannot Open File" \
		"Cannot open file $fname for writing." \
		"" 0 OK
	return
    }

    puts $f "set session \"$session\""
    puts $f "set tdatas \"$tdatas\""
    foreach tdata [array names schemas] {
	puts $f "set tdata \"$tdata\""
	puts $f "set schemas(\$tdata) \"$schemas($tdata)\""
    }
    foreach m [array names maps] {
	puts $f "set m \"$m\""
	puts $f "set maps(\$m) \"$maps($m)\""
    }
    foreach m [array names mappings] {
	puts $f "set m \"$m\""
	puts $f "set mappings(\$m) \"$mappings($m)\""
    }
    foreach v [array names views] {
	puts $f "set v \"$v\""
	puts $f "set views(\$v) \"$views($v)\""
    }
    foreach l [array names links] {
	puts $f "set l \"$l\""
	puts $f "set links(\$l) \"$links($l)\""
    }
    foreach win [array names windows] {
	puts $f "set win \"$win\""
	puts $f "set windows(\$win) \"$windows($win)\""
    }

    close $f

    set modified 0
}

proc MacroDefLoad {} {
    global tdatas schemas maps mappings views links windows session modified
    global none

    if {$modified > 0} {
	set but [dialog .modified "Session Modified" \
		"Warning: Current session modified." \
		"" 0 Save Discard Cancel]
	if {$but == 0} {
	    .map.but.save invoke
	} elseif {$but == 2} {
	    return
	}
    }

    if {[MacroDefSession "Load Session"] == 0} { return }

    set fname $session.tk
    MacroDefClear
    if {![file readable $fname]} {
	dialog .noFile "No File" \
		"File $fname does not exist." \
		"" 0 OK
    } else {
	source $fname
    }
    MacroDefTitle .map
    MacroDefTdata .map.tdata $none
    MacroDefWindows .map.window $none
    MacroDefMaps .map.gdata $none
    MacroDefViews .map.view $none
    MacroDefLinks .map.link $none

    set modified 0
}

proc MacroDefClear {} {
    global tdatas schemas maps mappings views links windows session

    set session ""
    set tdatas ""

    catch {unset schemas}
    catch {unset maps}
    catch {unset mappings}
    catch {unset views}
    catch {unset links}
    catch {unset windows}

    # the following are required for the old Tcl to work properly;
    # these define arrays with zero elements

    set schemas(a) a
    unset schemas(a)
    set maps(a) a
    unset maps(a)
    set mappings(a) a
    unset mappings(a)
    set views(a) a
    unset views(a)
    set links(a) a
    unset links(a)
    set windows(a) a
    unset windows(a)
}

proc MacroDefHelp {} {
    # see if .help window already exists; if so, just return
    set err [catch {set exists [wm state .help]}]
    if {!$err} { return }

    toplevel .help
    wm title .help "Help"
    wm geometry .help +100+300
    message .help.msg -justify center -width 10c \
	    -text "This is the help window."
    button .help.ok -text OK -width 10 -command "destroy .help"
    pack .help.msg .help.ok -side top -padx 5m -pady 3m

    tkwait visibility .help
    grab set .help
    tkwait window .help
}

proc MacroDefAuto {tdata} {
    global schemas modified x xtype sortedx yvar completed

    # see if .auto window already exists; if so, just return
    set err [catch {set exists [wm state .auto]}]
    if {!$err} { return }

    toplevel .auto
    wm title .auto "Automatic Views"
    wm geometry .auto +100+100
    selection clear .auto

    label .auto.label -text "Select Auto Parameters"
    frame .auto.xsel -relief groove -borderwidth 2
    frame .auto.ysel -relief groove -borderwidth 2
    frame .auto.but
    pack .auto.label -side top -pady 3m -fill x -expand 1
    pack .auto.xsel -side top -pady 3m -ipady 5m -ipadx 5m
    pack .auto.ysel -side top -pady 3m
    pack .auto.but -side top -pady 3m -fill x -expand 1

    label .auto.xsel.label -text "Select X" -width 15
    menubutton .auto.xsel.attr -relief raised \
	    -textvariable x -menu .auto.xsel.attr.menu -width 15
    pack .auto.xsel.label -side left
    pack .auto.xsel.attr -side left

    label .auto.ysel.label -text "Select Y" -width 15
    pack .auto.ysel.label -side top -fill x -expand 1 -pady 3m

    menu .auto.xsel.attr.menu
    set sname [lindex $schemas($tdata) 0]
    set schema [ElimStringAttr [lindex $schemas($tdata) 1]]
    set x ""
    set xtype ""
    set sortedx 0

    set row -1
    set col -1
    set maxcol 4
    set varcnt 0

    foreach attr $schema {
	set name [lindex $attr 0]
	set type [lindex $attr 1]
	set sorted [lindex $attr 2]
	.auto.xsel.attr.menu add radiobutton -label $name \
		-variable x -value $name
	if {$sorted > 0 && $name != "recId" && $x == ""} {
	    set x $name
	    set xtype $type
	    set sortedx $sorted
	}
	if {$col < 0} {
	    incr row
	    set col 0
	    frame .auto.ysel.row$row -relief groove -borderwidth 1
	    pack .auto.ysel.row$row -side top -fill x -expand 1
	}
	checkbutton .auto.ysel.row$row.col$col -text $name \
		-variable yvar($name) -width 15 -anchor w
	set yvar($name) 0
	pack .auto.ysel.row$row.col$col -side left
	incr col
	if {$col >= $maxcol} {
	    set col -1
	}
    }
    if {$x == ""} {
	set x [lindex [lindex $schema 0] 0]
	set xtype [lindex [lindex $schema 0] 1]
	set sortedx [lindex [lindex $schema 0] 2]
    }

    tk_menuBar .auto.xsel .auto.xsel.attr

    button .auto.but.ok -text OK -width 20 -command {
	set ylist ""
	foreach yname [array names yvar] {
	    if {$yvar($yname) > 0} {
		lappend ylist $yname
	    }
	}
	if {$ylist == ""} {
	    dialog .autoError "Note" \
		    "Please select one or more\n\
		    Y attributes for automatic\n\
		    mapping." "" 0 OK
	} else {
	    MacroDefAutoActual $tdata $x $xtype $sortedx $ylist
	    set completed 1
	    destroy .auto
	}
    }
    button .auto.but.cancel -text Cancel -width 20 -command {
	set completed 0
	destroy .auto
    }
    pack .auto.but.ok .auto.but.cancel -side left -expand 1

    tkwait visibility .auto
    grab set .auto
    tkwait window .auto

    return $completed
}

proc MacroDefAutoActual {tdata x xtype sortedx ylist} {
    global schemas maps mappings views links windows modified none
    global viewDefault

    set window [format "%s (Auto)" $tdata]
    set err [catch {set exists $windows($window)}]
    if {$err > 0} {
	# ask DEVise to create window
	set winType WinVertical
	set result [DEVise create window $winType $window 0.3 0.0 0.5 0.95]
	if {$result == ""} {
	    dialog .windowError "Window Error" \
		    "Error creating window $window" "" 0 OK
	    return
	}
	set windows($window) {0.3 0.0 0.5 0.95}
    }
    
    if {$sortedx > 0} {
	set sortedx SortedX
    } else {
	set sortedx Scatter
    }

    # should scan x in file and compute xlo and xhi

    set xlo 0.0
    set xhi 1000.0
    set bgColor white

    set viewParams ""
    catch { set viewParams $viewDefault($xtype) }
    foreach param $viewParams {
	set pname [lindex $param 0]
	set value [lindex $param 1]
	if {$pname == "xlow"} {
	    set xlo $value
	}
	if {$pname == "xhigh"} {
	    set xhi $value
	}
    }
    # puts "Auto mappings will have xlo $xlo and xhi $xhi"

    set linkname [format "%s Link" $x]
    set err [catch {set exists $links($linkname)}]
    if {$err > 0} {
	# ask DEVise to create link
	set result [DEVise create link Visual_Link $linkname 1]
	if {$result == ""} {
	    dialog .linkError "Link Error" \
		    "Error creating link $linkname" "" 0 OK
	    return
	}
	set flag 1
	set links($linkname) $flag
    }

    set sname [lindex $schemas($tdata) 0]
    set schema [ElimStringAttr [lindex $schemas($tdata) 1]]
    set color 2
    set shape 2
    set size 1
    set pattern 0
    set orient 0

    foreach attr $schema {
	set name [lindex $attr 0]
	set type [lindex $attr 1]
	set sorted [lindex $attr 2]
	if {[lsearch $ylist $name] < 0} { continue }

	set mapname [format "%s_vs_%s" $name $x]
	set err [catch {set exists $mappings($mapname)}]
	if {$err > 0} {
	    set defn [list $x $name $color $shape $size $pattern $orient]
	    set mappings($mapname) $defn
	    lappend maps($sname) $mapname
	}

	# should scan y in file and compute ylo and yhi for each view

	set ylo 0.0
	set yhi 100.0

	set viewParams ""
	catch {	set viewParams $viewDefault($type) }
	foreach param $viewParams {
	    set pname [lindex $param 0]
	    set value [lindex $param 1]
	    if {$pname == "ylow"} {
		set ylo $value
	    }
	    if {$pname == "yhigh"} {
		set yhi $value
	    }
	}

	set viewname [format "%s View" $name]
	set err [catch {set exists $views($viewname)}]
	if {$err > 0} {
	    set defn [list $xlo $xhi $ylo $yhi $bgColor]
	    set views($viewname) $defn
	}

	# ask DEVise to create view instance
	set sorted $sortedx
	set viewinstance "$tdata#$viewname#$x#$name"
	if {[lsearch [ViewSet] $viewinstance] >= 0} {
	    dialog .viewError "View Error" \
		    "View $viewinstance exists already." "" 0 OK
	    return
	}
	set result [DEVise create view $sorted $viewinstance \
		$xlo $xhi $ylo $yhi $bgColor]
	if {$result == ""} {
	    dialog .viewError "View Error" \
		    "Error creating view $viewinstance" "" 0 OK
	    return
	}
	
	if {[lsearch [DEVise get mapping] $mapname] < 0} {
	    # ask DEVise to create interpreted mapping
	    # parameter format: x y color size pattern orientation shape
	    set result [DEVise createInterp $tdata $mapname "" \$$x \$$name \
		    $color "" "" "" $shape "" ""]
	}

	set mapinstance "$tdata#$mapname"
	if {[lsearch [GdataSet] $mapinstance] < 0} {
	    # ask DEVise to create an instance of mapping
	    set result [DEVise create mapping $mapname $tdata $mapinstance \
		    "" \$$x \$$name $color "" "" "" $shape "" ""]
	    DEVise setPixelWidth $mapinstance 1
	} else {
	    puts "$mapinstance exists already -- not creating"
	}

	# ask DEVise to insert $viewinstance into $mapinstance
	set result [DEVise insertMapping $viewinstance $mapinstance]
	# seems that there's no error code returned

	# ask DEVise to insert $viewinstance into $window
	set result [DEVise insertWindow $viewinstance $window]
	# seems that there's no error code returned

	# ask DEVise to link $viewinstance to $linkname
	set result [DEVise insertLink $linkname $viewinstance]
	# seems that there's no error code returned

	DEVise clearViewHistory $viewinstance
	DEVise insertViewHistory $viewinstance $xlo $ylo $xhi $yhi 0

	ProcessViewSelected $viewinstance
	# DoToggleAxis X
	DoToggleAxis Y

	incr color
    }

    MacroDefWindows .map.window $none
    MacroDefMaps .map.gdata $none
    MacroDefViews .map.view $none
    MacroDefLinks .map.link $none

    set modified 1
}

proc MacroDefTdata {m default} {
    global tdatas tdata modified none

    catch {destroy $m.mbar}
    catch {destroy $m.label}

    set tdata $none
    set defExists 0

    menubutton $m.mbar -relief raised -textvariable tdata \
	    -menu $m.mbar.menu -width 20
    label $m.label -text "Source:" -width 8
    pack $m.label $m.mbar -side left -padx 2m
    menu $m.mbar.menu
    foreach t $tdatas {
	set name [lindex $t 0]
	$m.mbar.menu add command -label $name \
		-command "set tdata \"$name\"; \
		          MacroDefMaps .map.gdata \"$none\""
	if {$tdata == $none} {
	    set tdata $name
	}
	if {$default == $name} {
	    set defExists 1
	}
    }

    if {$default != $none && $defExists > 0} {
	set tdata $default
    }

    if {$tdata != $none} {
	# fix: .map.but.auto s.b. a parameter
	.map.but.auto configure -state normal
    } else {
	.map.but.auto configure -state disabled
    }

    $m.mbar.menu add command -label "Open..." \
	    -command {
	set sname [DefSource]
	if {$sname != ""} {
	    # fix this: .map.tdata s.b. $m
	    MacroDefTdata .map.tdata $sname
	    MacroDefMaps .map.gdata $none
	    set modified 1
	}
    }
    tk_menuBar $m $m.mbar
}

proc MacroDefWindows {m default} {
    global windows window modified none

    catch {destroy $m.mbar}
    catch {destroy $m.label}

    set window $none
    set defExists 0

    menubutton .map.window.mbar -relief raised -textvariable window \
	    -menu .map.window.mbar.menu -width 20
    label .map.window.label -text "Window:" -width 8
    pack .map.window.label .map.window.mbar -side left -padx 2m
    menu .map.window.mbar.menu
    foreach win [lsort [array names windows]] {
	.map.window.mbar.menu add command -label $win \
		-command "set window \"$win\""
	if {$window == $none} {
	    set window $win
	}
	if {$default == $win} {
	    set defExists 1
	}
    }

    if {$default != $none && $defExists > 0} {
	set window $default
    }

    .map.window.mbar.menu add command -label "New..." \
	    -command {
	set winname [DefWindow]
	if {$winname != ""} {
	    # fix this: .map.window s.b. $m
	    MacroDefWindows .map.window $winname
	    set modified 1
	}
    }
    tk_menuBar .map.window .map.window.mbar
}

proc MacroDefMaps {m default} {
    global schemas maps tdata gdata modified none

    catch {destroy $m.mbar}
    catch {destroy $m.label}

    set gdata $none
    set defExists 0

    menubutton $m.mbar -relief raised -textvariable gdata \
	    -menu $m.mbar.menu -width 20
    if {$tdata != $none} {
	$m.mbar configure -state normal
    } else {
	$m.mbar configure -state disabled
    }
    label $m.label -text "Mapping:" -width 8
    pack $m.label $m.mbar -side left -padx 2m
    menu $m.mbar.menu
    if {$tdata != $none} {
	set schema [lindex $schemas($tdata) 0]
	foreach map [lsort $maps($schema)] {
	    $m.mbar.menu add command -label $map \
		    -command "set gdata \"$map\""
	    if {$gdata == $none} {
		set gdata $map
	    }
	    if {$default == $map} {
		set defExists 1
	    }
	}
    }

    if {$default != $none && $defExists > 0} {
	set gdata $default
    }

    if {$tdata != $none} {
	$m.mbar.menu add command -label "New..." \
		-command {
	    set sname [lindex $schemas($tdata) 0]
	    set schema [lindex $schemas($tdata) 1]
	    set mapname [DefMapping $tdata $schema]
	    if {$mapname != ""} {
		lappend maps($sname) $mapname
		# fix this: .map.gdata s.b. $m
		MacroDefMaps .map.gdata $mapname
		set modified 1
	    }
	}
    }
    tk_menuBar $m $m.mbar
}

proc MacroDefViews {m default} {
    global views view modified none

    catch {destroy $m.mbar}
    catch {destroy $m.label}

    set view $none
    set defExists 0

    menubutton $m.mbar -relief raised -textvariable view \
	    -menu $m.mbar.menu -width 20
    label $m.label -text "View:" -width 8
    pack $m.label $m.mbar -side left -padx 2m
    menu $m.mbar.menu
    foreach v [lsort [array names views]] {
	$m.mbar.menu add command -label $v \
		    -command "set view \"$v\""
	if {$view == $none} {
	    set view $v
	}
	if {$default == $v} {
	    set defExists 1
	}
    }

    if {$default != $none && $defExists > 0} {
	set view $default
    }

    $m.mbar.menu add command -label "New..." \
	    -command {
	set viewname [DefView]
	if {$viewname != ""} {
	    # fix this: .map.view s.b. $m
	    MacroDefViews .map.view $viewname
	    set modified 1
	}
    }
    tk_menuBar $m $m.mbar
}

proc MacroDefLinks {m default} {
    global links link modified none

    catch {destroy $m.mbar}
    catch {destroy $m.label}

    set link $none
    set defExists 0

    menubutton $m.mbar -relief raised -textvariable link \
	    -menu $m.mbar.menu -width 20
    label $m.label -text "Link:" -width 8
    pack $m.label $m.mbar -side left -padx 2m
    menu $m.mbar.menu
    foreach l [lsort [array names links]] {
	$m.mbar.menu add command -label $l \
		    -command "set link \"$l\""
	if {$link == $none} {
	    set link $l
	}
	if {$default == $l} {
	    set defExists 1
	}
    }

    if {$default != $none && $defExists > 0} {
	set link $default
    }

    $m.mbar.menu add command -label $none \
	    -command "set link \"$none\""
    $m.mbar.menu add command -label "New..." \
	    -command {
	set linkname [DefLink]
	if {$linkname != ""} {
	    # fix this: .map.link s.b. $m
	    MacroDefLinks .map.link $linkname
	    set modified 1
	}
    }
    tk_menuBar $m $m.mbar
}

proc DefSource {} {
    global tdatas schemas maps fsBox sname datadir dialogListVar

    # see if .source window already exists; if so, just return
    set err [catch {set exists [wm state .source]}]
    if {!$err} { return }

    set fsBox(path) $datadir
    set fsBox(pattern) *
    set source [FSBox]

    if {$source == ""} { return }
    if {![file isfile $source]} { return }

    foreach tdata $tdatas {
	set name [lindex $tdata 0]
	set file [lindex $tdata 1]
	if {$source == $file} {
	    set fname [file tail $source]
	    dialog .sourceExists "Source Exists" \
		    "Source file $fname is already open\n\
		    under source name $name." \
		    "" 0 {OK}
	    return
	}
    }

    set schemaTypes [DEVise get tdata]
    set schema ""
    if {![llength $schemaTypes]} {
	set schema [ImportFileType]
    } else {
	set fname [file tail $source]
	set but [dialogList .schemaType "Schema" \
		"Select schema type for file $fname." \
		"" 2 {OK New Cancel} $schemaTypes]
	if {!$but} {
	    set schema $dialogListVar(selected)
	} elseif {$but == 1} {
	    set schema [ImportFileType]
	}
    }
    if {$schema == ""} { return }

    set err [catch {set sdef $maps($schema)}]
    if {$err > 0} {
	set maps($schema) ""
    }

    toplevel .source
    wm title .source "Define Source"
    wm geometry .source +100+100
    selection clear .source

    label .source.label -text "Enter name of data source"
    frame .source.mid -relief groove -borderwidth 2
    frame .source.but
    pack .source.label .source.mid .source.but -side top -pady 3m \
	    -padx 3m -fill both -expand 1

    frame .source.left
    frame .source.right
    pack .source.left -in .source.mid -side left
    pack .source.right -in .source.mid -side left -padx 3m -fill x -expand 1

    label .source.left.sname -text "Source name" -width 15
    label .source.left.source -text "Source file" -width 15
    label .source.left.schema -text "Schema" -width 15
    pack .source.left.sname -side top -fill x -pady 3m
    pack .source.left.source .source.left.schema -side top -fill x

    set sname [file tail $source]
    entry .source.right.sname -relief sunken -textvariable sname
    label .source.right.source -text [file tail $source] -anchor w
    label .source.right.schema -text $schema -anchor w
    pack .source.right.sname -side top -fill x -pady 3m
    pack .source.right.source .source.right.schema -side top -fill x

    button .source.but.ok -text OK -width 10 \
	    -command {
	if {$sname == ""} {
	    dialog .needSource "No Source Name" \
		    "Please enter name of source data." \
		    "" 0 {OK}
	} else {
	    set err [catch {set exists $schemas($sname)}]
	    if {!$err} {
		dialog .sourceExists "Source Name Exists" \
			"Source name $sname exists already." \
			"" 0 {OK}
	    } else {
		destroy .source
	    }
	}
    }
    button .source.but.clear -text Clear -width 10 \
	    -command { set sname "" }
    button .source.but.cancel -text Cancel -width 10 \
	    -command {
	set sname ""
	destroy .source
    }
    pack .source.but.ok .source.but.clear .source.but.cancel -side left \
	    -padx 3m -expand 1

    tkwait visibility .source
    grab set .source
    tkwait window .source

    if {$sname != ""} {
	set fname [file tail $source]
	statusWindow .info "Status" \
		"Creating an index on $fname.\n\n\
		This may take a while."
	# ask DEVise to create tdata
	set result [DEVise create tdata $schema $source $sname]
	catch {destroy .info}
	if {$result == ""} {
	    dialog .fileError "File Error" \
		    "Error reading file $fname" "" 0 OK
	    return ""
	}
	set sdef [DEVise getSchema $sname]
	lappend tdatas [list $sname $source]
	set schemas($sname) [list $schema $sdef]
    }

    return $sname
}

proc statusWindow {w title msg} {
    toplevel $w
    wm title $w $title
    wm geometry $w +200+200
    message $w.msg -justify center -width 8c -text $msg
    pack $w.msg -side top -padx 8m -pady 4m
    update
}

proc DefWindow {} {
    global windows x y w h winname

    # see if .def window already exists; if so, just return
    set err [catch {set exists [wm state .def]}]
    if {!$err} { return }

    toplevel .def
    wm title .def "Define Window"
    wm geometry .def +100+100
    selection clear .def

    set winname "Default"
    set x "0.1"
    set y "0.3"
    set w "0.5"
    set h "0.5"

    label .def.label -text "Enter window parameters"
    frame .def.win
    frame .def.but
    pack .def.label -side top -pady 3m
    pack .def.win -side top -padx 3m -fill both -expand 1
    pack .def.but -side top -pady 3m -padx 3m -fill x -expand 1

    frame .def.win.left
    frame .def.win.right
    pack .def.win.left .def.win.right -side left -fill both \
	    -expand 1

    label .def.win.left.x -text X -width 8
    label .def.win.left.y -text Y -width 8
    label .def.win.left.w -text Width -width 8
    label .def.win.left.h -text Height -width 8
    label .def.win.left.name -text Name -width 8
    pack .def.win.left.x .def.win.left.y \
	    .def.win.left.w .def.win.left.h -side top
    pack .def.win.left.name -side top -pady 3m

    entry .def.win.right.x -relief sunken -width 15 -textvariable x
    entry .def.win.right.y -relief sunken -width 15 -textvariable y
    entry .def.win.right.w -relief sunken -width 15 -textvariable w
    entry .def.win.right.h -relief sunken -width 15 -textvariable h
    entry .def.win.right.name -relief sunken -width 15 -textvariable winname
    pack .def.win.right.x .def.win.right.y \
	    .def.win.right.w .def.win.right.h -side top -pady 0.5m
    pack .def.win.right.name -side top -pady 3m

    button .def.but.ok -text OK -width 10 \
	    -command {
	if {$winname == ""} {
	    dialog .needInfo "Missing Information" \
		    "Please enter all requested information." \
		    "" 0 {OK}
	} else {
	    set err [catch {set exists $windows($winname)}]
	    if {!$err} {
		dialog .winExists "Win Exists" \
			"Window $winname exists already." \
			"" 0 {OK}
	    } else {
		destroy .def
	    }
	}
    }
    button .def.but.cancel -text Cancel -width 10 \
	    -command {
	set winname ""
	destroy .def
    }
    pack .def.but.ok .def.but.cancel -padx 3m -side left -expand 1

    tkwait visibility .def
    grab set .def
    tkwait window .def

    if {$winname != ""} {
	# ask DEVise to create window
	set winType WinVertical
	set result [DEVise create window $winType $winname $x $y $w $h]
	if {$result == ""} {
	    dialog .windowError "Window Error" \
		    "Error creating window $winname" "" 0 OK
	    return ""
	}
	set defn [list $x $y $w $h]
	set windows($winname) $defn
    }

    return $winname
}

proc DefMapping {tdata schema} {
    global DEViseColors DEViseShapes
    global mappings devcolors devshapes
    global mapname x y color shape size pattern orient

    # see if .def window already exists; if so, just return
    set err [catch {set exists [wm state .def]}]
    if {!$err} { return }

    toplevel .def
    wm title .def "Define Mapping"
    wm geometry .def +100+100
    selection clear .def

    set mapname "Default"

    label .def.label -text "Enter mapping parameters"
    frame .def.map
    frame .def.but
    pack .def.label -side top -pady 3m
    pack .def.map -side top -padx 3m -fill both -expand 1
    pack .def.but -side top -pady 3m -padx 3m -fill x -expand 1

    frame .def.map.left
    frame .def.map.right
    pack .def.map.left .def.map.right -side left -fill both \
	    -expand 1

    label .def.map.left.x -text X -width 8
    label .def.map.left.y -text Y -width 8
    label .def.map.left.color -text Color -width 12
    label .def.map.left.shape -text Shape -width 12
    label .def.map.left.size -text Size -width 12
    label .def.map.left.pattern -text Pattern -width 12
    label .def.map.left.orient -text Orientation -width 12
    label .def.map.left.name -text Name -width 12
    pack .def.map.left.x .def.map.left.y \
	    .def.map.left.color .def.map.left.shape \
	    .def.map.left.size .def.map.left.pattern \
	    .def.map.left.orient -side top
    pack .def.map.left.name -side top -pady 3m

    menubutton .def.map.right.x -relief raised \
	    -textvariable x -menu .def.map.right.x.menu -width 15
    menubutton .def.map.right.y -relief raised \
	    -textvariable y -menu .def.map.right.y.menu -width 15
    menubutton .def.map.right.color -relief raised \
	    -textvariable color -menu .def.map.right.color.menu -width 15
    menubutton .def.map.right.shape -relief raised \
	    -textvariable shape -menu .def.map.right.shape.menu -width 15
    menubutton .def.map.right.size -relief raised \
	    -textvariable size -menu .def.map.right.size.menu -width 15
    menubutton .def.map.right.pattern -relief raised \
	    -textvariable pattern -menu .def.map.right.pattern.menu -width 15
    menubutton .def.map.right.orient -relief raised \
	    -textvariable orient -menu .def.map.right.orient.menu -width 15
    entry .def.map.right.name -relief sunken -width 15 -textvariable mapname
    pack .def.map.right.x .def.map.right.y \
	    .def.map.right.color .def.map.right.shape \
	    .def.map.right.size .def.map.right.pattern \
	    .def.map.right.orient -side top
    pack .def.map.right.name -side top -pady 3m

    menu .def.map.right.x.menu
    menu .def.map.right.y.menu
    set x ""
    set y ""
    foreach attr $schema {
	set name [lindex $attr 0]
	set type [lindex $attr 1]
	set sorted [lindex $attr 2]
	.def.map.right.x.menu add radiobutton -label $name \
		-variable x -value $name
	.def.map.right.y.menu add radiobutton -label $name \
		-variable y -value $name
	if {$sorted > 0 && $name != "recId" && $x == ""} {
	    set x $name
	}
    }
    tk_menuBar .def.map.right .def.map.right.x
    tk_menuBar .def.map.right .def.map.right.y
    if {$x == ""} {
	set x [lindex [lindex $schema 0] 0]
    }
    set y [lindex [lindex $schema 1] 0]

    menu .def.map.right.color.menu
    foreach color $DEViseColors {
	set idx [lindex $color 0]
	set name [lindex $color 1]
	set devcolors($name) $idx
	.def.map.right.color.menu add radiobutton -label $name \
		-variable color -value $name
    }
    tk_menuBar .def.map.right .def.map.right.color
    set color red

    menu .def.map.right.shape.menu
    foreach shape $DEViseShapes {
	set idx [lindex $shape 0]
	set name [lindex $shape 1]
	set devshapes($name) $idx
	.def.map.right.shape.menu add radiobutton -label $name \
		-variable shape -value $name
    }
    tk_menuBar .def.map.right .def.map.right.shape
    set shape Bar

    menu .def.map.right.size.menu
    .def.map.right.size.menu add radiobutton -label 1 \
	    -variable size -value 1
    tk_menuBar .def.map.right .def.map.right.size
    set size 1

    menu .def.map.right.pattern.menu
    .def.map.right.pattern.menu add radiobutton -label Normal \
	    -variable pattern -value Normal
    tk_menuBar .def.map.right .def.map.right.pattern
    set pattern Normal

    menu .def.map.right.orient.menu
    .def.map.right.orient.menu add radiobutton -label Normal \
	    -variable orient -value Normal
    tk_menuBar .def.map.right .def.map.right.orient
    set orient Normal

    button .def.but.ok -text OK -width 10 \
	    -command {
	if {$mapname == ""} {
	    dialog .needInfo "Missing Information" \
		    "Please enter all requested information." \
		    "" 0 {OK}
	} else {
	    set err [catch {set exists $mappings($mapname)}]
	    if {!$err} {
		dialog .mapExists "Mapping Exists" \
			"Mapping $mapname exists already." \
			"" 0 {OK}
	    } else {
		destroy .def
	    }
	}
    }
    button .def.but.cancel -text Cancel -width 10 \
	    -command {
	set mapname ""
	destroy .def
    }
    pack .def.but.ok .def.but.cancel -side left -padx 3m -expand 1

    tkwait visibility .def
    grab set .def
    tkwait window .def

    if {$mapname != ""} {
	set cidx $devcolors($color)
	set sidx $devshapes($shape)
	set pidx 0
	set oidx 0
	set defn [list $x $y $cidx $sidx $size $pidx $oidx]
	set mappings($mapname) $defn
    }

    return $mapname
}

proc DefView {} {
    global views
    global viewname xlo xhi ylo yhi

    # see if .def window already exists; if so, just return
    set err [catch {set exists [wm state .def]}]
    if {!$err} { return }

    toplevel .def
    wm title .def "Define View"
    wm geometry .def +100+100
    selection clear .def

    set viewname "Default"
    set xlo "0.0"
    set xhi "100.0"
    set ylo "0.0"
    set yhi "100.0"
    set viewParams [DEVise getparam view SortedX]
    foreach param $viewParams {
	set pname [lindex $param 0]
	set value [lindex $param 1]
	if {$pname == "xlow"} {
	    set xlo $value
	}
	if {$pname == "xhigh"} {
	    set xhi $value
	}
	if {$pname == "ylow"} {
	    set ylo $value
	}
	if {$pname == "yhigh"} {
	    set yhi $value
	}
    }

    label .def.label -text "Enter view parameters"
    frame .def.view
    frame .def.but
    pack .def.label -side top -pady 3m
    pack .def.view -side top -padx 3m -fill both -expand 1
    pack .def.but -side top -pady 3m -padx 3m -fill x -expand 1

    frame .def.view.left
    frame .def.view.right
    pack .def.view.left .def.view.right -side left -fill both \
	    -expand 1

    label .def.view.left.xlo -text "X low" -width 8
    label .def.view.left.xhi -text "X high" -width 8
    label .def.view.left.ylo -text "Y low" -width 8
    label .def.view.left.yhi -text "Y high" -width 8
    label .def.view.left.name -text Name -width 8
    pack .def.view.left.xlo .def.view.left.xhi \
	    .def.view.left.ylo .def.view.left.yhi -side top
    pack .def.view.left.name -side top -pady 3m

    entry .def.view.right.xlo -relief sunken -width 25 -textvariable xlo
    entry .def.view.right.xhi -relief sunken -width 25 -textvariable xhi
    entry .def.view.right.ylo -relief sunken -width 25 -textvariable ylo
    entry .def.view.right.yhi -relief sunken -width 25 -textvariable yhi
    entry .def.view.right.name -relief sunken -width 25 -textvariable viewname
    pack .def.view.right.xlo .def.view.right.xhi \
	    .def.view.right.ylo .def.view.right.yhi -side top -pady 0.5m
    pack .def.view.right.name -side top -pady 3m

    button .def.but.ok -text OK -width 10 \
	    -command {
	if {$viewname == ""} {
	    dialog .needInfo "Missing Information" \
		    "Please enter all requested information." \
		    "" 0 {OK}
	} else {
	    set err [catch {set exists $views($viewname)}]
	    if {!$err} {
		dialog .viewExists "View Exists" \
			"View $viewname exists already." \
			"" 0 {OK}
	    } else {
		destroy .def
	    }
	}
    }
    button .def.but.cancel -text Cancel -width 10 \
	    -command {
	set viewname ""
	destroy .def
    }
    pack .def.but.ok .def.but.cancel -padx 3m -side left -expand 1

    tkwait visibility .def
    grab set .def
    tkwait window .def

    if {$viewname != ""} {
	set defn [list $xlo $xhi $ylo $yhi white]
	set views($viewname) $defn
    }

    return $viewname
}

proc DefLink {} {
    global links x y color shape size pattern orient linkname

    # see if .def window already exists; if so, just return
    set err [catch {set exists [wm state .def]}]
    if {!$err} { return }

    toplevel .def
    wm title .def "Define Link"
    wm geometry .def +100+100
    selection clear .def

    set linkname "Default"
    set x 1
    set y 0
    set color 0
    set shape 0
    set size 0
    set pattern 0
    set orient 0

    label .def.label -text "Enter link parameters"
    frame .def.link
    frame .def.name
    frame .def.but
    pack .def.label -side top -pady 3m
    pack .def.link -side top -padx 3m -fill both -expand 1
    pack .def.name -side top -padx 3m -fill x -expand 1
    pack .def.but -side top -pady 3m -padx 3m -fill x -expand 1

    checkbutton .def.link.x -text X -variable x -anchor w
    checkbutton .def.link.y -text Y -variable y -anchor w
    checkbutton .def.link.color -text Color -variable color -anchor w
    checkbutton .def.link.shape -text Shape -variable shape -anchor w
    checkbutton .def.link.size -text Size -variable size -anchor w
    checkbutton .def.link.pattern -text Pattern -variable pattern -anchor w
    checkbutton .def.link.orient -text Orientation \
	    -variable orient -anchor w
    pack .def.link.x .def.link.y .def.link.color .def.link.shape \
	    .def.link.size .def.link.pattern .def.link.orient \
	    -side top -fill x -expand 1

    label .def.name.label -text "Name"
    entry .def.name.name -relief sunken -width 18 -textvariable linkname
    pack .def.name.label -side left -pady 3m
    pack .def.name.name -side right -pady 3m

    button .def.but.ok -text OK -width 10 \
	    -command {
	if {$linkname == ""} {
	    dialog .needInfo "Missing Information" \
		    "Please enter all requested information." \
		    "" 0 {OK}
	} else {
	    set err [catch {set exists $links($linkname)}]
	    if {!$err} {
		dialog .linkExists "Link Exists" \
			"Link $linkname exists already." \
			"" 0 {OK}
	    } else {
		destroy .def
	    }
	}
    }
    button .def.but.cancel -text Cancel -width 10 \
	    -command {
	set linkname ""
	destroy .def
    }
    pack .def.but.ok .def.but.cancel -side left -padx 3m -expand 1

    tkwait visibility .def
    grab set .def
    tkwait window .def

    if {$linkname != ""} {
	# ask DEVise to create link
	set flag [expr $x | ($y << 1) | ($color << 2) | ($size << 3) | \
		       ($pattern << 4) | ($orient << 5) | ($shape << 6)]
	set result [DEVise create link Visual_Link $linkname $flag]
	if {$result == ""} {
	    dialog .linkError "Link Error" \
		    "Error creating link $linkname" "" 0 OK
	    return ""
	}
	set links($linkname) $flag
    }

    return $linkname
}

# initialize macro definition utility
MacroDefInit
