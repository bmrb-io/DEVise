<!--
  ========================================================================
  DEVise Data Visualization Software
  (c) Copyright 1992-1999
  By the DEVise Development Group
  Madison, Wisconsin
  All Rights Reserved.
  ========================================================================

  Under no circumstances is this software to be copied, distributed,
  or altered in any way without prior permission from the DEVise
  Development Group.
-->

<!--
  $Id$
-->

<HTML>

<HEAD>

<TITLE>DEVise DataReader Manual</TITLE>

</HEAD>

<BODY BACKGROUND="logo_background.gif">

<BR><BR>

<CENTER><H1>A Guide to DataReader for the schema writer</H1></CENTER>
<CENTER><H3>Version 2.0: February 3, 1999</H3></CENTER>

<BR><BR>

<UL>
	<LI><H2><A HREF="#Intro">Introduction</A></H2>
	<LI><H2><A HREF="#Simple">A Simple Schema</A></H2>
	<LI><H2><A HREF="#Schema">A Schema In General</A></H2>

	<LI><H2><A HREF="#data_types">Data Types</A></H2>
	<LI><H2><A HREF="#comments">Comments</A></H2>
	<LI><H2><A HREF="#skip">Skip Attributes</A></H2>

	<LI><H2><A HREF="#Reserve">Reserved Words</A></H2>
	<LI><H2><A HREF="#Level1">Schema-Level Options</A></H2>
	<LI><H2><A HREF="#Level2">Attribute-Level Options</A></H2>
</UL>


<BR><BR>

<H2><A NAME="Intro">Introduction</A></H2>

The DataReader library allows a program that uses it to read nearly any file
consisting of uniformly-formatted records.  To do this, it requires a
description of the physical layout of the file that will be referred to as
a "schema".  This document is intended as a tutorial and reference on how to
write a DataReader schema.  
<BR><BR><BR>


<H2><A NAME="Simple">A Simple Schema</A></H2>

<P>Let's start out by taking a quick look at a simple example for a
schema defining two integer attributes, "x" and "y":</P>

<PRE>
	datareader 2.0;

	record_separator = [\n]+;
	field_separator = [ ]+;

	# Definition of attribute x
	int x;

	# Definition of attribute y
	int y;

	# A "skip" attribute
	int;
</PRE>


A sample of the data file:<BR>

<PRE>
	3 5 7
	273 0 32
	12 34 144
</PRE>

<BR>


The keyword 'datareader' starts a schema definition; it is followed by
a DataReader version number.  Schema-level options and attributes are
then defined.  Attributes are defined by a type, followed by the attribute
name except in the case of 'skip' attributes.  The name can be followed
by attribute-level options.  'skip' attributes are treated as garbage and
thrown away when the data is read.

<BR><BR><BR>


<H2><A NAME="Schema">A Schema In General</A></H2>

A DataReader schema has the following form, where angle brackets (&lt; and
&gt;) indicate required items and square brackets ([ and ]) indicate
optional items:
<BR><BR>

<PRE>
	datareader &lt;version&gt;;
	[schema-level options]
	[attribute definitions]
</PRE>

<br>
Option definitions are of the form:
<PRE>
	&lt;option&gt; = &lt;value&gt;;
</PRE>

<br>
Attribute definitions are of the form:
<PRE>
	&lt;type&gt; [name] [attribute-level options];
</PRE>

<BR>
Note that schema-level options and attribute definitions can actually
be mixed, but for clarity it is recommended to define all schema-level
options before defining any attributes.

<BR><BR><br>


<h2><a name="data_types">Data Types</a></h2>
The built-in types (with their equivalent C types) are currently:<BR><BR>

<TABLE width=50% border=0>
	<TH align=left>DataReader type<BR></TH>
	<TH align=left>equivalent C type<BR></TH>
	<TR>
		<TD>int</TD><TD>int</TD>
		</TR>
	<TR>
		<TD>double</TD><TD>double</TD>
		</TR>
	<TR>
		<TD>string</TD><TD>char *</TD>
		</TR>
	<TR>
		<TD>date</TD><TD>EncodedDTF</TD>
		</TR>
</TABLE>

<BR><br><br>


<h2><a name="comments">Comments in Schemas<a></h2>
Note that comments can be used within a schema; '#' or '//' can be used for a single line comment.  For multi-lines, comments can be specified between /* and */.

<BR><BR><br>


<h2><a name="skip">Skip Attributes</a></h2>
Skip attributes are attributes that are not of interest, but exist in the
data and are specified in the schema only to ensure proper parsing of the
data.  A skip attribute is specified by giving a DataReader type, and
optionally attribute-level options, but no attribute name.
<br>

Sample use:<br>
<pre>
	int;
	string maxlen = 10;
</pre>

When a record is read, the field corresponding to the skip attribute is
read, but the data is simply discarded.  No space is reserved in
the output buffer for skip attributes.


<BR><BR><BR>


<A NAME="Reserve"><H2>Reserved Words</H2></A>

The following words are reserved, and should not be used as names of items within the schema.  Names are case-sensitive.<BR>

<BR>

<TABLE BORDER=0 width="40%">
	<TR>
		<TD>C-style</TD>
		<TD>comment</TD>
		<TD>datareader</TD>
		</TR>
	<TR>
		<TD>date</TD>
		<TD>date_format</TD>
		<TD>double</TD>
		</TR>
	<TR>
		<TD>field_separator</TD>
		<TD>int</TD>
		<TD>key</TD>
		</TR>
	<TR>
		<TD>length</TD>
		<TD>maxlen</TD>
		<TD>noescape</TD>
		</TR>
	<TR>
		<TD>nullif</TD>
		<TD>quote</TD>
		<TD>record_separator</TD>
		</TR>
	<TR>
		<TD>sorted</TD>
		<TD>type</TD>
		<TD>url</TD>
		</TR>
</TABLE>

<BR>

<H2><A NAME="Level1">Schema-Level Options</A></H2>

There are several options that can be expressed within the outermost level of the schema, and not nested within an attribute definition.  These options apply to the entire data file, or to each record in it.<BR>

<BR>

<H3><B>Options:</B></H3>


<LI><B>comment</B><BR><BR>

<UL>

<LI>The 'comment' option indicates what sections within the datafile should be considered comments.  Comments are currently only allowed at the beginning of records.  DataReader ignores rest of of the record when it encounters a comment at the beginning and skips all the characters up to next record.<BR>

<BR>

Allowed values: &lt;quoted string&gt ; <BR>

<BR>

Sample use:<BR>

<pre>
	comment = "##";
</pre>

Default value: none
<br>

<BR>

</UL>


<LI><B>field_separator</B><br>
<br>Note that 'field_separator' can also be specified at the attribute level.<br>

<UL>

<li>The 'field_separator' option specifies a character or characters
designating the end of a field.  If multiple characters are specified, any
one of them indicates the end of a field.  A '+' character at the end of a
field_separator specification indicates that repetitions of the field
separator character(s) should be ignored.
<BR><br>

Allowed values: &lt;string in brackets&gt[+] ;<BR>

<BR>

Sample use:<BR>

<pre>
	field_separator = [,]; // Comma ends fields; don't ignore repetitions
	field_separator = [ \t]+; // Space or tab ends fields; ignore repetitions
</pre>

<BR>

Default value: [ \t]+<BR>

<BR>

</UL>


<LI><B>key</B><BR><BR>

<UL>

<LI>The 'key' option specifies the attributes that are keys of the data.
The DataReader doesn't make use of this information; it simply passes it
on to upper layers of the software.  More than one attribute can be specified
as a key.
<br>
<BR>

Allowed values: (&lt;attribute name&gt;, &lt;attribute name&gt;, ....)

<BR>
<BR>

Sample use:<BR>
<pre>
	key = (name, id);
</pre>

Default value: none

</UL>


<LI><B>record_separator</B><BR><BR>

<UL>

<li>The 'record_separator' option specifies a character or characters
designating the end of a record.  If multiple characters are specified, any
one of them indicates the end of a record.  If a record separator is not
specified, the default record_separator value is used.  If record_separator
is specified as empty, fields are counted to find the end of a record.  A
'+' character at the end of a record_separator specification indicates that
repetitions of the record separator character(s) should be ignored.
<br>
<BR>

Allowed values: &lt;string in brackets&gt[+] ; <BR>

<BR>

Sample use:<BR>
<pre>
	record_separator = [\n]; // Newline ends records; don't ignore repetitions
	record_separator = [\n]+; // Newline ends records; ignore repetitions
	record_separator = []; // No record_separator, fields are counted to find the end of record.
</pre>

<BR>

Default value: [\n]+<BR>

<BR>

</UL>


<LI><B>sorted</B><BR><BR>

<UL>

<li>The 'sorted' option specifies attributes that are sorted in the data.
The DataReader doesn't make use of this information; it simply passes it
on to upper layers of the software.  More than one attribute can be specified
as sorted.
<br>
<BR>

Allowed values: (&lt;attribute name&gt;, &lt;attribute name&gt;, ....)

<BR>

<BR>

Sample use:<BR>
<pre>
	sorted = (name, id);
</pre>

Default value: none

</UL>



</UL>

<BR><BR>

<H2><A NAME="Level2">Attribute-Level Options</A></H2>

These options can be specified within an attribute definition.  Some of
them can also be specified at the top level of the schema as well.  The
ones that work this way will have a mention of that fact in their
description, but generally, it's the one's that could make sense at the
top-level.
<BR>
<BR>

<LI><B>encoding</B><BR><BR>

<UL>

<LI>The 'encoding' option defines encoding type used for specifying escape characters.  C-style reads any character after a '\' without checking it.<BR>

Only C-style is currently supported.<br>

<BR>



Allowed values: one of C-style, quoted, url, noescape<BR>

<BR>

Sample use:<BR>
<pre>
	encoding = C-style
</pre>

Default value: C-style<BR>

<BR>

</UL>

<li><B>date_format</B><BR>
<br>Note that 'date_format' can also be specified at the schema level.<br>

<UL>
<LI>The 'date_format' option indicates how date values should be parsed.
<br>
<BR>
Allowed values: &lt;a quoted string containing a legitimate format&gt;<BR>
<BR>
Sample use:<BR>
<pre>
	# Reads dates like: 12/2/97-14:22:30
	date_format = "%m/%d/%y-%H:%M:%S";
</pre>

Default value: none
<BR>
<BR>
The format codes have the following meanings:<BR>
<BR>
<TABLE CELLSPACING=0 BORDER=0 WIDTH=623>
	<TR><TD WIDTH="11%" VALIGN="MIDDLE">
		<P><b>Code</b></TD>
		<TD WIDTH="89%" VALIGN="MIDDLE">
		<P><b>Replaced by</b></TD>
		</TR>
	<TR><TD WIDTH="11%" VALIGN="MIDDLE">
		<B><P>%E</B></TD>
		<TD WIDTH="89%" VALIGN="MIDDLE">
		<P>"BC" or "AD" (epoch)</TD>
		</TR>
	<TR><TD WIDTH="11%" VALIGN="MIDDLE">
		<B><P>%d</B></TD>
		<TD WIDTH="89%" VALIGN="MIDDLE">
		<P>day of the month as a decimal number (1-31)</TD>
		</TR>
	<TR><TD WIDTH="11%" VALIGN="MIDDLE">
		<B><P>%f</B></TD>
		<TD WIDTH="89%" VALIGN="MIDDLE">
		<P>fractional second, as a decimal number (0-999999)</TD>
		</TR>
	<TR><TD WIDTH="11%" VALIGN="MIDDLE">
		<B><P>%H</B></TD>
		<TD WIDTH="89%" VALIGN="MIDDLE">
		<P>the hour as a decimal integer (0-23 or 1-12)</TD>
		</TR>
	<TR><TD WIDTH="11%" VALIGN="MIDDLE">
		<B><P>%M</B></TD>
		<TD WIDTH="89%" VALIGN="MIDDLE">
		<P>minute, as a decimal number (0-59)</TD>
		</TR>
	<TR><TD WIDTH="11%" VALIGN="MIDDLE">
		<B><P>%m</B></TD>
		<TD WIDTH="89%" VALIGN="MIDDLE">
		<P>month, as a decimal number (1-12)</TD>
		</TR>
	<TR><TD WIDTH="11%" VALIGN="MIDDLE">
		<B><P>%B</B></TD>
		<TD WIDTH="89%" VALIGN="MIDDLE">
		<P>full month name, e.g., "February"</TD>
		</TR>
	<TR><TD WIDTH="11%" VALIGN="MIDDLE">
		<B><P>%b</B></TD>
		<TD WIDTH="89%" VALIGN="MIDDLE">
		<P>abbreviated month name, e.g., "Feb"</TD>
		</TR>
	<TR><TD WIDTH="11%" VALIGN="MIDDLE">
		<B><P>%P</B></TD>
		<TD WIDTH="89%" VALIGN="MIDDLE">
		<P>AM/PM designation for 12-hour clock (AM)</TD>
		</TR>
	<TR><TD WIDTH="11%" VALIGN="MIDDLE">
		<B><P>%S</B></TD>
		<TD WIDTH="89%" VALIGN="MIDDLE">
		<P>second, as a decimal number (0-59)</TD>
		</TR>
	<TR><TD WIDTH="11%" VALIGN="MIDDLE">
		<B><P>%y</B></TD>
		<TD WIDTH="89%" VALIGN="MIDDLE">
		<P>year without century as a decimal number (0-99)</TD>
		</TR>
	<TR><TD WIDTH="11%" VALIGN="MIDDLE">
		<B><P>%Y</B></TD>
		<TD WIDTH="89%" VALIGN="MIDDLE">
		<P>year with century as a decimal number (0-9999)</TD>
		</TR>
	<TR><TD WIDTH="11%" VALIGN="MIDDLE">
		<B><P>%%</B></TD>
		<TD WIDTH="89%" VALIGN="MIDDLE">
		<P>literal %</TD>
		</TR>
	<TR><TD WIDTH="11%" VALIGN="MIDDLE">
		<P><B>&lt;other&gt;</B></TD>
		<TD WIDTH="89%" VALIGN="MIDDLE">
		<P>A literal character, to be ignored.</TD>
		</TR>
</TABLE>
<BR>

</UL>

<LI><B>length</B><BR><BR>

<UL>

<LI>The 'length' option is used for fixed-length attributes and defines the length of the attribute.  maxlen and length can't be used together.  Separator cannot be specified if length is used, also quoted strings can't specify length.  Note that the length value does <em>not</em> include the terminating NULL.<BR>

<BR>

Allowed values: &lt;integer value&gt;<BR>

<BR>

Sample use:<BR>
<pre>
	length = 8;
</pre>

Default value: none<BR>

<BR>

</UL>

<LI><B>maxlen</B><BR><BR>

<UL>

<!-- TEMPTEMP need to explain string foo[10] format -->
<LI>The 'maxlen' option indicates how much storage should be reserved for strings that are read in.  This option can only be specified for strings.  Attribute can't have maxlen and length at the same time.  If the specified string is longer than given 'maxlen', only first maxlen bytes of the strings are read and a warning message is displayed.  Note that the maxlen value <em>does</em> include the terminating NULL (the opposite of length).<BR>

<BR>

Allowed values: &lt;integer value&gt;<BR>

<BR>

Sample use:<BR>
<pre>
	maxlen = 40;
</pre>

Default value: none<BR>

<BR>

</UL>

<LI><B>nullif (not supported yet)</B><BR><BR>

<UL>

<LI>The 'nullif' option defines the null string for this attribute.  If DataReader encounters this string, assigns NULL to this attribute.<BR>

<BR>



Allowed values: &lt;quoted string&gt;<BR>

<BR>

Sample use:<BR>
<pre>
	nullif = "NULL";
</pre>

Default value: none<BR>

<BR>

</UL>

<LI><B>quote</B><BR>

<br>Note that 'quote' can also be specified at the schema level.<br>

TEMPTEMP -- note that this whole section is pretty messed up<br>

<UL>

<LI>The 'quote' option indicates what the quoting character is for strings in the datafile.  All strings in the file need not be quoted.  Any string that begins with the quote character is presumed to end with it also, so a string in the data who's first character is literally the quote character _must_ be quoted to be read properly.<BR><BR>
Fixed length fields can't define a quote character.<BR><BR>
If field separator is not defined for quoted strings, quoted field terminates at the second quote character and the next character is assumed to be the beginning of the next field (even if it is xxx separator).  Because of this implementation, schema-level xxx separator definition does not effect string fields, if schema-level (or field-level) quote character is defined.<BR><BR>
<BR>

Allowed values: &lt;single character in brackets&gt;<BR>

<BR>

Sample use:<BR>
<pre>
	quote = ['];
</pre>

Default value: none<br>

<br><br>
Consider the following schema:<BR>

<BR>

<PRE>

schema {
	record_separator = [\n];
	field_separator = [ +];
	attr x {
		type = string;
		quote = ["];
		maxlen = 10;
	}

	attr y {
		type = string;
		quote = ["];
		maxlen = 10;
	}
}

</PRE>



<BR>

For the following record:<BR>

<BR>

"try+me"+first<BR>

&#9;&#9;<BR>

x would be "try+me" and y would be "first"<BR>

<BR>

&#9;&#9;For<BR>

<BR>

try+me+first<BR>

<BR>

x would be "try" , y would be "me" and the rest of the line would be ignored.<BR>

<BR>
<PRE>
schema {
	record_separator = [\n];
	field_separator = [ ];
	attr x {
		type = string;
		quote = ["];
		maxlen = 10;
	}

	attr y {
		type = string;
		maxlen = 10;
	}
}

<B>is equivalent to</B>

schema {
	record_separator = [\n];
	attr x {
		type = string;
		quote = ["];
		maxlen = 10;
	}

	attr y {
		type = string;
		field_separator = [ ];
		maxlen = 10;
	}
}
</PRE>

<BR>

</UL>


</UL>

<hr>

<br>

<!-- TEMPTEMP -- give code example?; alignment -->

All text and images Copyright &#169; 1996-1999, DEVise Development Group,
Madison, WI.

</BODY>

</HTML>

