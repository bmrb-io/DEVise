<!--
  ========================================================================
  DEVise Data Visualization Software
  (c) Copyright 1992-1998
  By the DEVise Development Group
  Madison, Wisconsin
  All Rights Reserved.
  ========================================================================

  Under no circumstances is this software to be copied, distributed,
  or altered in any way without prior permission from the DEVise
  Development Group.
-->

<!--
  $Id$
-->

<HTML>

<HEAD>

<TITLE>DEVise DataReader Manual</TITLE>

</HEAD>

<BODY BACKGROUND="logo_background.gif">

<BR><BR>

<CENTER><H1>A Guide to DataReader for the schema writer</H1></CENTER>

<BR><BR>

<UL>
	<LI><H2><A HREF="#Intro">Introduction</A></H2>
	<LI><H2><A HREF="#Simple">A Simple Schema</A></H2>
	<LI><H2><A HREF="#Schema">A Schema In General</A></H2>
	<LI><H2><A HREF="#Reserve">Reserved Words</A></H2>
	<LI><H2><A HREF="#Level1">Schema-Level Options</A></H2>
	<LI><H2><A HREF="#Level2">Attribute-Level Options</A></H2>
</UL>


<BR><BR>

<H2><A NAME="Intro">Introduction</A></H2>

The DataReader library allows a program that uses it to read nearly any file.  To do this, it requires a description of the physical layout of the file that will be referred to as a "schema".  This document is intended as a tutorial and reference on how to write a schema.

<BR><BR><BR>


<H2><A NAME="Simple">A Simple Schema</A></H2>

<P>Let's start out by taking a quick look at a simple example for the schema "my_schema" defining two integer attributes, "x" and "y":</P>

<PRE>
	schema my_schema {

		# Definition of attribute x
		attr x {
			type = int;
		}

		# Definition of attribute y
		attr y {
			type = int;
		}

		skip {
			type = int;
		}
	}
</PRE>


A sample of the data file:<BR>

<PRE>
	3 5
	273 0
	12 34
</PRE>

<BR>


The keyword 'schema' starts a schema definition, it is followed by an identifier that is the name of the schema, and then the actual schema definition within braces.  Similarly, each attribute is defined with the keyword 'attr' or 'skip'.  Attributes defined with 'attr' are followed by the name of the attribute, followed by the actual definition within braces.  'skip' attributes are treated as garbage and thrown away.  Within the attribute definition the setting 'type' is set to 'int'.  As you might suspect, this is only one of several built-in types available.

<h2>Data Types</h2>
The built-in types (with their equivalent C types) are currently:<BR><BR>

<LI>int: int<BR></LI>
<LI>double : double<BR></LI>
<LI>string : char*<BR></LI>
<LI>date : EncodedDTF (see DateTime.h) <BR></LI>
<BR>

<h2>Comments in Schemas</h2>
Notice that comments can be used within the schema; '#' or '//' can be used for a single line comment.  For multi-lines, comments can be specified between /* and */.

<BR><BR><BR>

<H2><A NAME="Schema">A Schema In General</A></H2>



A generic schema is presented here.  &lt;&gt; brackets are used to indicate a specific item needed at this point.  [] brackets are used to indicate optional items that can be supplied.  Ellipsis (...) are used to indicate that an arbitrary number of items can be supplied.<BR><BR>



<PRE>

schema &lt;schema-name&gt; {

	[schema-level options]

	attr &lt;attribute-name&gt; {

		type = &lt;type-name&gt;;
		[attr-level options]
	}

	[more attr definitions]

}
</PRE>

<BR>

The curly braces (i.e., {}) are required to balance, to allow simple programs to be able to easily skip over a schema without having to parse it.  If a brace is used in a literal string or comment, a matching brace should be added in that or another comment to keep the total number of each brace side equal.<BR>

<BR>

Every item that is not inclosed in braces should be terminated with a semicolon.  Extra semicolons (blank statements), are silently ignored.<BR>

<BR><BR><BR>

<A NAME="Reserve"><H2>Reserved Words:</H2></A>

The following words are reserved, and should not be used as names of items within the schema.  Names are case-sensitive.<BR>



<BR>



<TABLE BORDER=0 width="40%">

<TR><TD>attr</TD><TD>C-style</TD><TD>comment</TD></TR>

<TR><TD>date</TD><TD>date_format</TD><TD>delimiter</TD></TR>

<TR><TD>double</TD><TD>int</TD><TD>key</TD></TR>

<TR><TD>length</TD><TD>maxlen</TD><TD>noescape</TD></TR>

<TR><TD>nullif</TD><TD>quote</TD><TD>schema</TD></TR>

<TR><TD>separator</TD><TD>skip</TD><TD>sorted</TD><TD></TR>

<TR>string</TD><TD>type</TD><TD>url</TD></TR>

</TABLE>

<BR>

<H2><A NAME="Level1">Schema-Level Options</A></H2>

There are several options that can be expressed within the outermost level of the schema, and not nested within an attribute definition.  These options apply to the entire data file, (or to each record in it separately).<BR>

<BR>

<H3><B>Options:</B></H3>




<LI><B>comment</B><BR><BR>

<UL>

<LI>The 'comment' keyword indicates what sections within the datafile should be considered comments.  Comments are currently only allowed at the beginning of records.  DataReader ignores rest of of the record when it encounters a comment at the beginning and skips all the characters up to next record.<BR>

<BR>

Allowed values: &lt;string value&gt ; <BR>

<BR>

Sample Use:<BR>

comment = "##";<BR>

<BR>

</UL>

<LI><B>delimiter</B><BR><BR>

<UL>

<LI>The 'delimiter' keyword indicates what character an input record ends.  If delimiter is not used, default delimiter value is used. If delimiter is specified as empty, fields are counted to find the end of a record.  '+' character at the end of a delimiter specification can be used for ignoring repetitions.<BR>

<BR>

Allowed values: &lt;string in bracket&gt+ ; <BR>

<BR>

Sample Use:<BR>

delimiter = [\n];<BR>

delimiter = [\n]+;<BR>

delimiter = []; // No delimiter, fields are counted to find the end of record.<BR>

<BR>

Default value: [\n]+<BR>

<BR>

</UL>

<LI><B>key</B><BR><BR>

<UL>

<LI>The 'key' keyword specifies the keys of this table.  DataReader doesn't use this option, instead it passes this information to upper layer.  DataReader allows more than one key entry.<BR>

<BR>

Allowed values : &lt;(attribute name, attribute name, ....)&gt;

<BR>

<BR>

Sample Use:<BR>

key = (name, id);<BR>

</UL>


<LI><B>separator</B><br>
<br>Note that 'separator' can also be specified at the attribute level.<br>

<UL>

<LI>The 'separator' keyword indicates what character separates the fields of this record.  An attribute can either have a separator or length, both of them can't be specified at the same time.  '+' character at the end of a separator specification can be used for ignoring repetitions.<BR>
<BR>

Allowed values: &lt;string in bracket&gt + ;<BR>

<BR>

Sample Use:<BR>

separator = [,];<BR>

separator = [ \t]+;<BR>

<BR>

Default value: [ \t]+<BR>

<BR>

</UL>



<LI><B>sorted</B><BR><BR>

<UL>

<LI>The 'sorted' keyword specifies the order that this table will be displayed.  DataReader doesn't use this option, instead it passes this information to upper layer. <BR>

<BR>

Allowed values : &lt;(attribute name, attribute name, ....)&gt;

<BR>

<BR>

Sample Use:<BR>

sorted = (name, id);<BR>

</UL>



</UL>

<BR><BR>

<H2><A NAME="Level2">Attribute-Level Options</A></H2>

These options can be expressed with an attribute definition.  Some of them can also be expressed at the top-level of the schema as well.  The ones that work this way will have a mention of that fact in their description, but generally, it's the one's that could make sense at the top-level.<BR>

<BR>

<LI><B>encoding (only C-style is supported)</B><BR><BR>

<UL>

<LI>The 'encoding' keyword defines encoding type used for specifying escape characters.  C-style reads any character after a '\' without checking it.<BR>

<BR>



Allowed values: one of C-style, quoted, url, noescape<BR>

<BR>

Sample Use:<BR>

nullif = "NULL";<BR>

<BR>

Default value: none<BR>

<BR>

</UL>

<li><B>date_format</B><BR>
<br>Note that 'date_format' can also be specified at the schema level.<br>

<UL>
<LI>The 'date_format' keyword indicates how attributes of type dates should be interpreted.<BR>
<BR>
Allowed values: &lt;a string containing a legitimate format&gt;<BR>
<BR>
Sample Use:<BR>
# Reads dates like: 12/2/97-14:22:30 <BR>
date_format = "MM/DD/YY-hh:mm:ss";<BR>
<BR>
Date Formats:<BR>
<BR>
The codes have the following meanings:<BR>
<BR>
CodeReplaced By <BR><BR>
<TABLE CELLSPACING=0 BORDER=0 WIDTH=623>
<TR><TD WIDTH="11%" VALIGN="MIDDLE">
<P><B>&lt;any&gt;</B></TD>
<TD WIDTH="89%" VALIGN="MIDDLE">
<P>A literal character, to be ignored.</TD>
</TR>
<TR><TD WIDTH="11%" VALIGN="MIDDLE">
<B><P>B</B></TD>
<TD WIDTH="89%" VALIGN="MIDDLE">
<P>"BC" or "AD"</TD>
</TR>
<TR><TD WIDTH="11%" VALIGN="MIDDLE">
<B><P>DD</B></TD>
<TD WIDTH="89%" VALIGN="MIDDLE">
<P>day of the month as a decimal number (1-31)</TD>
</TR>
<TR><TD WIDTH="11%" VALIGN="MIDDLE">
<B><P>ff</B></TD>
<TD WIDTH="89%" VALIGN="MIDDLE">
<P>fractional second, as a decimal number (0-999999)</TD>
</TR>
<TR><TD WIDTH="11%" VALIGN="MIDDLE">
<B><P>hh</B></TD>
<TD WIDTH="89%" VALIGN="MIDDLE">
<P>the hour as a decimal integer (0-23 or 1-12)</TD>
</TR>
<TR><TD WIDTH="11%" VALIGN="MIDDLE">
<B><P>mm</B></TD>
<TD WIDTH="89%" VALIGN="MIDDLE">
<P>minute, as a decimal number (0-59)</TD>
</TR>
<TR><TD WIDTH="11%" VALIGN="MIDDLE">
<B><P>MM</B></TD>
<TD WIDTH="89%" VALIGN="MIDDLE">
<P>month, as a decimal number (1-12)</TD>
</TR>
<TR><TD WIDTH="11%" VALIGN="MIDDLE">
<B><P>MONTH</B></TD>
<TD WIDTH="89%" VALIGN="MIDDLE">
<P>full month name, e.g., "February"</TD>
</TR>
<TR><TD WIDTH="11%" VALIGN="MIDDLE">
<B><P>MON</B></TD>
<TD WIDTH="89%" VALIGN="MIDDLE">
<P>abbreviated month name, e.g., "Feb"</TD>
</TR>
<TR><TD WIDTH="11%" VALIGN="MIDDLE">
<B><P>P</B></TD>
<TD WIDTH="89%" VALIGN="MIDDLE">
<P>AM/PM designation for 12-hour clock (AM)</TD>
</TR>
<TR><TD WIDTH="11%" VALIGN="MIDDLE">
<B><P>ss</B></TD>
<TD WIDTH="89%" VALIGN="MIDDLE">
<P>second, as a decimal number (0-59)</TD>
</TR>
<TR><TD WIDTH="11%" VALIGN="MIDDLE">
<B><P>YY</B></TD>
<TD WIDTH="89%" VALIGN="MIDDLE">
<P>year without century as a decimal number (0-99)</TD>
</TR>
<TR><TD WIDTH="11%" VALIGN="MIDDLE">
<B><P>YYYY</B></TD>
<TD WIDTH="89%" VALIGN="MIDDLE">
<P>year with century as a decimal number (0-9999)</TD>
</TR>
</TABLE>
<BR>

</UL>

<LI><B>length</B><BR><BR>

<UL>

<LI>The 'length' keyword is used for fixed-length attributes and defines the length of the attribute.  maxlen and length can't be used together.  Separator can not be specified if length is used, also quoted strings can't specify length.  Note that the length value does <em>not</em> include the terminating NULL.<BR>

<BR>

Allowed values: &lt;an integer value&gt;<BR>

<BR>

Sample Use:<BR>

length = 8;<BR>

<BR>

Default value: none<BR>

<BR>

</UL>

<LI><B>maxlen</B><BR><BR>

<UL>

<LI>The 'maxlen' keyword indicates how much storage should be reserved for strings that are read in.  This option can only be specified for strings.  Attribute can't have maxlen and length at the same time.  If the specified string is longer than given 'maxlen', only first maxlen bytes of the strings are read and a warning message is displayed.  Note that the maxlen value <em>does</em> include the terminating NULL (the opposite of length).<BR>

<BR>

Allowed values: &lt;an integer value&gt;<BR>

<BR>

Sample Use:<BR>

maxlen = 40;<BR>

<BR>

Default value: none<BR>

<BR>

</UL>

<LI><B>nullif (not supported yet)</B><BR><BR>

<UL>

<LI>The 'nullif' keyword defines the null string for this attribute.  If DataReader encounters this string, assigns NULL to this attribute.<BR>

<BR>



Allowed values: &lt;string value&gt;<BR>

<BR>

Sample Use:<BR>

nullif = "NULL";<BR>

<BR>

Default value: none<BR>

<BR>

</UL>

<LI><B>quote</B><BR><BR>

<UL>

<LI>The 'quote' keyword indicates what the quoting character is for strings in the datafile.  All strings in the file need not be quoted.  Any string that begins with the quote character is presumed to end with it also, so a string in the data who's first character is literally the quote character _must_ be quoted to be read properly.<BR><BR>
Fixed length fields can't define a quote character.<BR><BR>
If separator is not defined for quoted strings, quoted field terminates at the second quote character and the next character is assumed to be the beginning of the next field (even if it is separator).  Because of this implementation, schema-level separator definition does not effect string fields, if schema-level (or field-level) quote character is defined.<BR><BR>
This option works at the schema-level also. <BR>
<BR>

Allowed values: &lt;a single character string&gt;<BR>

<BR>

Sample Use:<BR>

quote = ['];<BR>

<BR>

Consider the following schema ;<BR>

<BR>

<PRE>

schema {
	delimiter = [\n];
	separator = [ +];
	attr x {
		type = string;
		quote = ["];
		maxlen = 10;
	}

	attr y {
		type = string;
		quote = ["];
		maxlen = 10;
	}
}

</PRE>



<BR>

For the following record:<BR>

<BR>

"try+me"+first<BR>

&#9;&#9;<BR>

x would be "try+me" and y would be "first"<BR>

<BR>

&#9;&#9;For<BR>

<BR>

try+me+first<BR>

<BR>

x would be "try" , y would be "me" and the rest of the line would be ignored.<BR>

<BR>
<PRE>
schema {
	delimiter = [\n];
	separator = [ ];
	attr x {
		type = string;
		quote = ["];
		maxlen = 10;
	}

	attr y {
		type = string;
		maxlen = 10;
	}
}

<B>is equivalent to</B>

schema {
	delimiter = [\n];
	attr x {
		type = string;
		quote = ["];
		maxlen = 10;
	}

	attr y {
		type = string;
		separator = [ ];
		maxlen = 10;
	}
}
</PRE>
Default value: none<BR>

<BR>

</UL>



<LI><B>type</B><BR><BR>

<UL>

<LI>The 'type' keyword indicates the type of the attribute, where the choices are the built-in types.<BR>

<BR>

Allowed values: one of int, double, string, date<BR>

<BR>

Sample Use:<BR>

type = double;<BR>

<BR>

Default value: none<BR>

<BR>

The built-in types correspond directly to C types:<BR>

<BR>

<CENTER>

<TABLE width=50% border=0>

<TH align=left>DataReader type<BR></TH>

<TH align=left>equivalent C type<BR></TH>

<TR>

<TD>int</TD><TD>int</TD>

</TR>

<TR>

<TD>double</TD><TD>double</TD>

</TR>

<TR>

<TD>string</TD><TD>char *</TD>

</TR>

<TR>

<TD>date</TD><TD>EncodedDTF</TD>

</TR>

</TABLE>

</CENTER>

<BR>

</UL>

</UL>

<hr>

<br>

All text and images Copyright &#169; 1996-1998, DEVise Development Group,
Madison, WI.

</BODY>

</HTML>

