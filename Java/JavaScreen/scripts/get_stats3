#! /bin/env python

#  ========================================================================
#  DEVise Data Visualization Software
#  (c) Copyright 2000-2015
#  By the DEVise Development Group
#  Madison, Wisconsin
#  All Rights Reserved.
#  ========================================================================
#
#  Under no circumstances is this software to be copied, distributed,
#  or altered in any way without prior permission from the DEVise
#  Development Group.

#  This script gets JavaScreen usage statistics.

#  Note:  If this is run on "mixed" usage files (some with client IDs/
#  command counts and some without) the command averages per session
#  category won't be accurate.

#  The data structures involved are as follows:
#  * We have an array that has an entry for each client ID.
#  * For each client ID we also store the host.
#  * For each client ID we have an array with an entry for
#    each session open.
#  * For each session open we store a command count.
#TEMPTEMP -- hmm -- or maybe we just store a list where [0] is the hostname, [1] is the command count for the first session, etc.  When we see an open, we add a new element to the list with a value of 0; when we see a command, we increment the last value in the list

#TEMPTEMP -- hmm -- I think I have to store the session name, too...

############################################################

#  $Id$

#  $Log$
#  Revision 1.5  2015/10/08 22:28:54  wenger
#  Got filtering by host working.
#
#  Revision 1.4  2015/10/08 21:09:18  wenger
#  Basic command counts are now working.
#
#  Revision 1.3  2015/10/08 18:10:04  wenger
#  Got rid of version history junk; we now parse the period argument
#  and set a beginning time accordingly; added filter argument,
#  although we don't do anything with it yet.
#
#  Revision 1.2  2015/08/26 18:11:30  wenger
#  Got regexes working in new get_stats script.
#
#  Revision 1.1  2015/08/25 15:17:09  wenger
#  First version of new get_stats script (get_stats3 will replace
#  get_stats when it's finished).
#

############################################################

import sys
import getopt
import datetime
import glob
import re

#-----------------------------------------------------------------
def main(argv):
	global debug
	debug = 2#TEMPTEMP

	version = "4.0.0"

	# Initialize command-line arguments.
	filter = False # if True filter out UW usage from stats
	idStr = "all"
	period = "week"
	curTime = datetime.datetime.now()

	# Process command-line arguments.
	if (debug > 1):
		print("Args: ", argv)

	try:
		(opts, args) = getopt.getopt(argv, "fi:p:t:uv", [])
	except getopt.GetoptError:
		#TEMPTEMP -- we don't seem to get here on unrecognized arg
		print("Error in command-line arguments")
		usage()
		sys.exit(2)

	for opt, arg in opts:
		if (opt == "-f"):
			filter = True
		elif (opt == "-i"):
			idStr = arg
		elif (opt == "-p"):
			period = arg
		elif (opt == "-t"):
			#TEMPTEMP -- parse time argument here...
			curTime = arg
		elif (opt == "-u"):
			usage()
			sys.exit(0)
		elif (opt == "-v"):
			print("get_stats version " + version)
			sys.exit(0)
		else:
			print("Unrecognized argument: ", opt)
			usage()
			sys.exit(2)

	if (debug > 0):
		print("idStr: ", idStr)
		print("period: ", period)
		print("curTime: ", curTime)

	#TEMPTEMP -- document this
	cmdData = {}

	process(idStr, period, curTime, cmdData)
	printReport(cmdData, filter)

#-----------------------------------------------------------------
def usage():
	print("Usage: get_stats [-f] [-i <id>] [-p <period>] [-t <time>] | -u | -v")
	print("  -f(ilter): filter out BMRB, UW CS, etc, usage")
	print("  <id> can be all (default), regular, soil, test, or tst2")
	print("  <period> can be week (default), day, or all")
	print("  <time> should be of the form 'dd-mmm-yy hh:mm:ss ap' or " +
		"'mmm dd, yyyy hh:mm:ss ap' (e.g., 'Sep 26, 2003 00:00:00 AM')")
	print("  -u(sage): print usage message")
	print("  -v(ersion):  print version")

#-----------------------------------------------------------------
def process(idStr, period, curTime, cmdData):
	print("process:")#TEMPTEMP
	print("  idStr: ", idStr)#TEMPTEMP
	print("  period: ", period)#TEMPTEMP
	print("  curTime: ", curTime)#TEMPTEMP

	#TEMPTEMP -- where do we want to enforce the begin time?  when we're reading data or when we're outputting it?  what if the session open falls before the beginTime but some commands fall after beginTime?
	if (period == "day"):
		beginTime = curTime - datetime.timedelta(1)
	elif (period == "week"):
		beginTime = curTime - datetime.timedelta(7)
	elif (period == "all"):
		beginTime = datetime.datetime(datetime.MINYEAR, 1, 1)
	else:
		print("Illegal period value: ", period)
		usage()
		sys.exit(2)

	if (debug > 0):
		print("beginTime: ", beginTime)

	# See if we have an appropriate JSPoP PID file, and print a
	# warning if we don't.
	if (idStr == "all"):
		pidPattern = "jspop_pid:*"
	else:
		pidPattern = "jspop_pid:" + idStr + ":*"
	pidFiles = glob.glob(pidPattern)
	if (len(pidFiles) < 1):
		print("WARNING: no JSPoP PID file (" + pidPattern + ") found")
		response = raw_input("Are you sure this script is being run in the " +
			"directory that the JSPoP is actually run in? (y/n) ")
		print("DIAG response: ", response)#TEMPTEMP
		if (response in ("y", "Y", "yes")):
			print("Script continuing")
		else:
			print("Script terminated")
			sys.exit(1)

	# Find the log files to look for.
	if (idStr == "all"):
		usagePattern = "logs/jspop.usage*"
	else:
		#TEMPTEMP -- this won't work!!
		usagePattern = "logs/jspop.usage." + idStr + "*"
	usageFiles = glob.glob(usagePattern)
	if (debug > 0):
		print("Usage files: ", usageFiles)

	if (len(usageFiles) < 1):
		print("No appropriate jspop.usage* files found -- exiting")
		sys.exit(1)

	# Now process each usage file
	for uf in usageFiles:
		processFile(uf, cmdData)

#-----------------------------------------------------------------
def processFile(uf, cmdData):
	if (debug > 1):
		print("Processing usage file: " + uf)

	file = open(uf, "r")
	for line in file:
		line = line.rstrip('\n')
		if (debug > 2):
			print("Line: " + line)

		processOpen(line, cmdData)
		#TEMPTEMP processClose(line, cmdData)
		processCmd(line, cmdData)

#-----------------------------------------------------------------
def processOpen(line, cmdData):
	if (debug > 2):
		print("processOpen(" + line + ")")

	regex = re.compile(r"(?P<host>\S*)( \((?P<client>\d+)\))?: JAVAC_OpenSession {(?P<session>.*)}.*\[(?P<time>.*)\]")
	result = regex.search(line)
	if (result != None):
		if (debug > 1):
			print("  processOpen matches line " + line)
		host = result.group('host')
		clientId = result.group('client')
		session = result.group('session')
		timestamp = result.group('time')
		if (debug > 1):
			print("Found open:")
			print("  host: ", host)
			print("  clientId: ", clientId)
			print("  session: ", session)
			print("  timestamp: ", timestamp)

		if (clientId not in cmdData):
			cmdData[clientId] = [host]

		# Command count for this session.
		cmdData[clientId].append([session, 0])

#-----------------------------------------------------------------
def processClose(line, cmdData):
	if (debug > 2):
		print("processClose(" + line + ")")

	regex = re.compile(r"(?P<host>\S*) \((?P<client>\d+)\): JAVAC_CloseCurrentSession \[(?P<time>.*)\]")
	result = regex.search(line)
	if (result != None):
		if (debug > 1):
			print("  processClose matches line " + line)
		host = result.group('host')
		clientId = result.group('client')
		timestamp = result.group('time')
		if (debug > 1):
			print("Found close:")
			print("  host: ", host)
			print("  clientId: ", clientId)
			print("  timestamp: ", timestamp)
	#TEMPTEMP -- add stuff here
	#TEMPTEMP -- do we even need to do anything on a close?

#-----------------------------------------------------------------
#TEMPTEMP -- be sure not to count open and close as commands
def processCmd(line, cmdData):
	if (debug > 2):
		print("processClose(" + line + ")")
	#TEMPTEMP -- add stuff here

	regex = re.compile(r"(?P<host>\S*) \((?P<client>\d+)\): (?P<cmd>\w*)(?P<args> \{.*\})*\s*\[(?P<time>.*)\]")
	result = regex.search(line)
	if (result != None):
		if (debug > 1):
			print("  processCmd matches line " + line)
		host = result.group('host')
		clientId = result.group('client')
		cmd = result.group('cmd')
		args = result.group('args')
		timestamp = result.group('time')
		if (debug > 1):
			print("Found command:")
			print("  host: ", host)
			print("  clientId: ", clientId)
			print("  cmd: ", cmd)
			print("  args: ", args)
			print("  timestamp: ", timestamp)

		if (clientId in cmdData):
			print("Client data:", cmdData[clientId])#TEMPTEMP
			cmdData[clientId][-1][1] += 1
		else:
			#TEMPTEMP -- throw error
			print("ERROR: clientId " + clientId + " not found!")

#-----------------------------------------------------------------
def printReport(cmdData, filter):
	print("printReport...")#TEMPTEMP
	if (filter):
		print("BMRB and CS hosts are filtered from statistics")

	# Print the raw data (for debugging).
	if (debug) > 0:
		print("Raw data:")
		for clientId in cmdData.keys():
			if (passHost(cmdData[clientId][0], filter)):
				print("Client {0} on {1}:".format(clientId, cmdData[clientId][0]))
				for tmp in cmdData[clientId][1:]:
					print("  Session {0}: {1} commands(s)".format(tmp[0], tmp[1]))

	# Collect the command count histogram data.
	cmdHist = {}
	for clientId in cmdData.keys():
		if (passHost(cmdData[clientId][0], filter)):
			for tmp in cmdData[clientId][1:]:
				count = tmp[1]
				print("Command count: ", count)#TEMPTEMP
				if (count in cmdHist):
					cmdHist[count] += 1
				else:
					cmdHist[count] = 1

	print(cmdHist)#TEMPTEMP

	counts = cmdHist.keys()
	counts.sort()
	for count in counts:
		print("Command count {0}, frequency {1}".format(count, cmdHist[count]))

#-----------------------------------------------------------------
def passHost(host, filter):
	value = True
	if (filter):
		if (host.find("localhost") != -1):
			value = False
		elif (host.find("cs.wisc.edu") != -1):
			value = False
		elif (host.find("128.105.") == 0):
			value = False
		elif (host.find("bmrb.wisc.edu") != -1):
			value = False
		elif (host.find("144.92.") == 0):
			value = False
	return value

#-----------------------------------------------------------------
main(sys.argv[1:])
