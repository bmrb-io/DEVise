#! /bin/env python

#  ========================================================================
#  DEVise Data Visualization Software
#  (c) Copyright 2000-2015
#  By the DEVise Development Group
#  Madison, Wisconsin
#  All Rights Reserved.
#  ========================================================================
#
#  Under no circumstances is this software to be copied, distributed,
#  or altered in any way without prior permission from the DEVise
#  Development Group.

#  This script gets JavaScreen usage statistics.

#  Note:  If this is run on "mixed" usage files (some with client IDs/
#  command counts and some without) the command averages per session
#  category won't be accurate.

############################################################

#  $Id$

#  $Log$
#  Revision 1.13  2015/10/12 21:29:35  wenger
#  Added open counts by session name.
#
#  Revision 1.12  2015/10/12 20:28:26  wenger
#  Added filtering by time period (to open commands).
#
#  Revision 1.11  2015/10/09 22:39:04  wenger
#  Now printing session category counts (still need command counts per
#  category, and sorting).
#
#  Revision 1.10  2015/10/09 21:03:09  wenger
#  We now also report command counts per host, and sort the hosts
#  in (decreasing) order of session open count.
#
#  Revision 1.9  2015/10/09 17:40:34  wenger
#  Cleaned things up by using classes to hold the information as we go;
#  various other cleanups; changed version number because I decided to
#  not rename this script to get_stats when it's ready; we now print
#  header info.
#
#  Revision 1.8  2015/10/09 16:20:40  wenger
#  We now output total session open count, and histogram frequencies
#  as a percentage of the total session count.
#
#  Revision 1.7  2015/10/09 15:26:14  wenger
#  Changed output formatting to older style for older Perl version at
#  BMRB.
#
#  Revision 1.6  2015/10/08 22:38:11  wenger
#  Got basic command count histograms working.
#
#  Revision 1.5  2015/10/08 22:28:54  wenger
#  Got filtering by host working.
#
#  Revision 1.4  2015/10/08 21:09:18  wenger
#  Basic command counts are now working.
#
#  Revision 1.3  2015/10/08 18:10:04  wenger
#  Got rid of version history junk; we now parse the period argument
#  and set a beginning time accordingly; added filter argument,
#  although we don't do anything with it yet.
#
#  Revision 1.2  2015/08/26 18:11:30  wenger
#  Got regexes working in new get_stats script.
#
#  Revision 1.1  2015/08/25 15:17:09  wenger
#  First version of new get_stats script (get_stats3 will replace
#  get_stats when it's finished).
#

############################################################

import sys
import getopt
import datetime
import glob
import re
import os
import socket

#-----------------------------------------------------------------
# To hold the info for each client.
class ClientInfo:
	def __init__(self, host):
		self.host = host
		self.sessions = [] # List of SessionInfo objects
	def totalOpens(self):
		return len(self.sessions)
	def totalCmds(self):
		tot = 0
		for tmp in self.sessions:
			tot += tmp.cmdCt
		return tot

#-----------------------------------------------------------------
# To hold session name and command count.
class SessionInfo:
	def __init__(self, session):
		self.name = session
		self.cmdCt = 0

#-----------------------------------------------------------------
# To hold per-host info.
class HostInfo:
	def __init__(self, sessions, cmds):
		self.openCt = sessions
		self.cmdCt = cmds

#-----------------------------------------------------------------
# To hold per-session category info.
class CatInfo:
	def __init__(self, cmds):
		self.openCt = 1
		self.cmdCt = cmds

#-----------------------------------------------------------------
def main(argv):
	global debug
	debug = 0

	version = "0.0.1"

	# Initialize command-line arguments.
	filter = False # if True filter out UW usage from stats
	idStr = "all"
	period = "week"
	curTime = datetime.datetime.now()

	# Process command-line arguments.
	if (debug > 1):
		print("Args: ", argv)

	try:
		(opts, args) = getopt.getopt(argv, "fi:p:t:uv", [])
	except getopt.GetoptError:
		#TEMPTEMP -- we don't seem to get here on unrecognized arg
		print("Error in command-line arguments")
		usage()
		sys.exit(2)

	for opt, arg in opts:
		if (opt == "-f"):
			filter = True
		elif (opt == "-i"):
			idStr = arg
		elif (opt == "-p"):
			period = arg
		elif (opt == "-t"):
			curTime = parseTimestamp(arg)
		elif (opt == "-u"):
			usage()
			sys.exit(0)
		elif (opt == "-v"):
			print("get_stats3 version " + version)
			sys.exit(0)
		else:
			print("Unrecognized argument: ", opt)
			usage()
			sys.exit(2)

	if (debug > 0):
		print("idStr: ", idStr)
		print("period: ", period)
		print("curTime: ", curTime)
		print("filter: ", filter)

	# cmdData maps clientId keys to ClientInfo values
	cmdData = {}

	process(idStr, period, curTime, filter, cmdData)
	printReport(cmdData, filter)

#-----------------------------------------------------------------
def usage():
	print("Usage: get_stats [-f] [-i <id>] [-p <period>] [-t <time>] | -u | -v")
	print("  -f(ilter): filter out BMRB, UW CS, etc, usage")
	print("  <id> can be all (default), regular, soil, test, or tst2")
	print("  <period> can be week (default), day, or all")
	print("  <time> should be of the form 'dd-mmm-yy hh:mm:ss ap' or " +
		"'mmm dd, yyyy hh:mm:ss ap' (e.g., 'Sep 26, 2003 00:00:00 AM')")
	print("  -u(sage): print usage message")
	print("  -v(ersion):  print version")

#-----------------------------------------------------------------
def process(idStr, period, curTime, filter, cmdData):
	if (debug > 1):
		print("process:")
		print("  idStr: ", idStr)
		print("  period: ", period)
		print("  curTime: ", curTime)

	if (period == "day"):
		beginTime = curTime - datetime.timedelta(1)
	elif (period == "week"):
		beginTime = curTime - datetime.timedelta(7)
	elif (period == "all"):
		beginTime = datetime.datetime(datetime.MINYEAR, 1, 1)
	else:
		print("Illegal period value: ", period)
		usage()
		sys.exit(2)

	if (debug > 0):
		print("beginTime: ", beginTime)

	# Print header info.
	print("")
	print("JavaScreen usage for ID %s" % (idStr)) 
	print("  in %s on %s" % (os.getcwd(), socket.gethostname()))
	print("JavaScreen usage statistics for %s through %s" % (beginTime, curTime))
	if (filter):
		print("CS/BMRB usage is filtered out")
	else:
		print("CS/BMRB usage is not filtered out")
	print("")

	# See if we have an appropriate JSPoP PID file, and print a
	# warning if we don't.
	if (idStr == "all"):
		pidPattern = "jspop_pid:*"
	else:
		pidPattern = "jspop_pid:" + idStr + ":*"

	pidFiles = glob.glob(pidPattern)
	if (len(pidFiles) < 1):
		print("WARNING: no JSPoP PID file (" + pidPattern + ") found")
		print("Are you sure this script is being run in the " +
			"directory that the JSPoP is actually run in?")

	# Find the log files to look for.
	if (idStr == "all"):
		usagePattern = "logs/jspop.usage*"
	else:
		#TEMPTEMP -- this won't work!!
		usagePattern = "logs/jspop.usage." + idStr + "*"
	usageFiles = glob.glob(usagePattern)
	if (debug > 0):
		print("Usage files: ", usageFiles)

	if (len(usageFiles) < 1):
		print("No appropriate jspop.usage* files found -- exiting")
		sys.exit(1)

	# Now process each usage file
	for uf in usageFiles:
		processFile(uf, beginTime, curTime, cmdData)

#-----------------------------------------------------------------
def processFile(uf, beginTime, curTime, cmdData):
	if (debug > 1):
		print("Processing usage file: " + uf)

	file = open(uf, "r")
	for line in file:
		line = line.rstrip('\n')
		if (debug > 2):
			print("Line: " + line)

		#TEMPTEMP -- don't call processCmd if processOpen found an open command?
		processOpen(line, beginTime, curTime, cmdData)
		#TEMPTEMP processClose(line, cmdData)
		processCmd(line, cmdData)

#-----------------------------------------------------------------
def processOpen(line, beginTime, curTime, cmdData):
	if (debug > 2):
		print("processOpen(" + line + ")")

	regex = re.compile(r"(?P<host>\S*)( \((?P<client>\d+)\))?: JAVAC_OpenSession {(?P<session>.*)}.*\[(?P<time>.*)\]")
	result = regex.search(line)
	if (result != None):
		if (debug > 1):
			print("  processOpen matches line " + line)
		host = result.group('host')
		clientId = result.group('client')
		session = result.group('session')
		timestamp = result.group('time')
		if (debug > 1):
			print("Found open:")
			print("  host: ", host)
			print("  clientId: ", clientId)
			print("  session: ", session)
			print("  timestamp: ", timestamp)

		timeVal = parseTimestamp(timestamp)
		if (timeVal < beginTime):
			if (debug > 1):
				print("Open time (%s) is before begin time (%s)" % (timeVal, beginTime))
		elif (timeVal > curTime):
			if (debug > 1):
				print("Open time (%s) is after \"current\" time (%s)" % (timeVal, curTime))
		else:
			if (clientId not in cmdData):
				ci = ClientInfo(host)
				cmdData[clientId] = ci

			# Command count for this session.
			si = SessionInfo(session)
			cmdData[clientId].sessions.append(si)

#-----------------------------------------------------------------
def processClose(line, cmdData):
	if (debug > 2):
		print("processClose(" + line + ")")

	regex = re.compile(r"(?P<host>\S*) \((?P<client>\d+)\): JAVAC_CloseCurrentSession \[(?P<time>.*)\]")
	result = regex.search(line)
	if (result != None):
		if (debug > 1):
			print("  processClose matches line " + line)
		host = result.group('host')
		clientId = result.group('client')
		timestamp = result.group('time')
		if (debug > 1):
			print("Found close:")
			print("  host: ", host)
			print("  clientId: ", clientId)
			print("  timestamp: ", timestamp)
	#TEMPTEMP -- add stuff here
	#TEMPTEMP -- do we even need to do anything on a close?

#-----------------------------------------------------------------
#TEMPTEMP -- be sure not to count open and close as commands
def processCmd(line, cmdData):
	if (debug > 2):
		print("processCmd(" + line + ")")

	regex = re.compile(r"(?P<host>\S*) \((?P<client>\d+)\): (?P<cmd>\w*)(?P<args> \{.*\})*\s*\[(?P<time>.*)\]")
	result = regex.search(line)
	if (result != None):
		if (debug > 1):
			print("  processCmd matches line " + line)
		host = result.group('host')
		clientId = result.group('client')
		cmd = result.group('cmd')
		args = result.group('args')
		timestamp = result.group('time')
		if (debug > 1):
			print("Found command:")
			print("  host: ", host)
			print("  clientId: ", clientId)
			print("  cmd: ", cmd)
			print("  args: ", args)
			print("  timestamp: ", timestamp)

		if (clientId in cmdData):
			cmdData[clientId].sessions[-1].cmdCt += 1
		else:
			# This means we didn't find an open for this client.
			if (debug > 0):
				print("Warning: clientId " + clientId + " not found!")

#-----------------------------------------------------------------
def printReport(cmdData, filter):
	if (debug > 2):
		print("printReport")

	if (filter):
		print("BMRB and CS hosts are filtered from statistics")

	# Print the raw data (for debugging).
	if (debug) > 0:
		print("Raw data:")
		for clientId in cmdData.keys():
			if (passHost(cmdData[clientId].host, filter)):
				print("Client %s on %s:" % (clientId, cmdData[clientId].host))
				for tmp in cmdData[clientId].sessions:
					print("  Session %s: %s commands(s)" % (tmp.name, tmp.cmdCt))

	# Count the total number of session opens and session opens by
	# session category.
	sessionCount = 0
	opensByHost = {}
	sessionCats = {}
	#TEMPTEMP -- need open count, cmd count for session cats
	for clientId in cmdData.keys():
		if (passHost(cmdData[clientId].host, filter)):
			sessionCount += (len(cmdData[clientId].sessions))
			host = cmdData[clientId].host
			if (host in opensByHost):
				opensByHost[host].openCt += cmdData[clientId].totalOpens()
				opensByHost[host].cmdCt += cmdData[clientId].totalCmds()
			else:
				hi = HostInfo(cmdData[clientId].totalOpens(), cmdData[clientId].totalCmds())
				opensByHost[host] = hi
			for si in cmdData[clientId].sessions:
				cat = getSessionCat(si.name)
				if (cat in sessionCats):
					ci = sessionCats[cat]
					ci.openCt += 1
					ci.cmdCt += si.cmdCt
				else:
					ci = CatInfo(si.cmdCt)
					sessionCats[cat] = ci

	print("\nTotal session opens: %s" % (sessionCount))

	print("\nSession category counts:")
	cats = sessionCats.items()
	cats.sort(key=compareHostOpens, reverse=True)#TEMPTEMP -- rename compare function?
	for tmp in cats:
		avg = 1.0 * tmp[1].cmdCt / tmp[1].openCt
		print("  %4d opens of %s (%d commands: %.1f per open)" % (tmp[1].openCt, tmp[0], tmp[1].cmdCt, avg))

	print("\nClient host info:")
	hosts = opensByHost.items()
	hosts.sort(key=compareHostOpens, reverse=True)
	for tmp in hosts:
		avg = 1.0 * tmp[1].cmdCt / tmp[1].openCt
		print("  %4d opens from host %s (%s commands: %.1f per open)" % (tmp[1].openCt, tmp[0], tmp[1].cmdCt, avg))

	# Collect the command count histogram data.
	cmdHist = {}
	for clientId in cmdData.keys():
		if (passHost(cmdData[clientId].host, filter)):
			for tmp in cmdData[clientId].sessions:
				count = tmp.cmdCt
				if (debug > 1):
					print("Command count: ", count)
				if (count in cmdHist):
					cmdHist[count] += 1
				else:
					cmdHist[count] = 1

	print("\nCommand frequency histogram")
	counts = cmdHist.keys()
	counts.sort()
	for count in counts:
		percent = 100.0 * cmdHist[count] / sessionCount
		print("  Command count %3d, frequency %3d (%.1f%%)" % (count, cmdHist[count], percent))

	# Collect the per-session open counts.
	sessionOpens = {}
	for clientId in cmdData.keys():
		if (passHost(cmdData[clientId].host, filter)):
			for tmp in cmdData[clientId].sessions:
				if (tmp.name in sessionOpens):
					sessionOpens[tmp.name] += 1
				else:
					sessionOpens[tmp.name] = 1

	print("\nSession info:")
	sessions = sessionOpens.items()
	sessions.sort(key=compareSessionOpens, reverse=True)
	for tmp in sessions:
		print("%4d %s" % (tmp[1], tmp[0]))

#-----------------------------------------------------------------
# Returns True if we should include data from this host in our
# statistics.
def passHost(host, filter):
	value = True
	if (filter):
		if (host.find("localhost") != -1):
			value = False
		elif (host.find("cs.wisc.edu") != -1):
			value = False
		elif (host.find("128.105.") == 0):
			value = False
		elif (host.find("bmrb.wisc.edu") != -1):
			value = False
		elif (host.find("144.92.") == 0):
			value = False
	return value

#-----------------------------------------------------------------
# Convert session file name to session category.
def getSessionCat(session):
	cat = "other/unknown"

	# Note:  Put most restrictive patterns first to avoid mis-counting
	# (e.g., SPARTA (sd) before chem shift deltas (d)).
	relist = []
	relist.append((re.compile(r"dna_histogram.ds$"), "DNA histogram"))
	relist.append((re.compile(r"rna_histogram.ds$"), "RNA histogram"))
	relist.append((re.compile(r"histogram2.ds$"), "dual-protein histogram"))
	relist.append((re.compile(r"histogram.ds$"), "single-protein histogram"))
	relist.append((re.compile(r"lacs\d+.ds$"), "LACS"))
	relist.append((re.compile(r"distr\d+.ds$"), "distance restraints"))
	relist.append((re.compile(r"tar\d+.ds$"), "torsion angle restraints"))
	relist.append((re.compile(r"as\d+.ds$"), "chem shift by AA/nucleotide"))
	relist.append((re.compile(r"am\d+.ds$"), "ambiguity codes"))
	relist.append((re.compile(r"ac\d+.ds$"), "atomic coordinates"))
	relist.append((re.compile(r"sd\d+.ds$"), "SPARTA"))
	relist.append((re.compile(r"ps\d+.ds$"), "Pistachio"))
	relist.append((re.compile(r"h[cn]\d+\+\d+.ds$"), "two-entry simulated HSQC spectra"))
	relist.append((re.compile(r"h[cn]\d+.ds$"), "simulated HSQC spectra"))
	relist.append((re.compile(r"t[12]\d+.ds$"), "T1/T2 relaxation"))
	relist.append((re.compile(r"d\d+.ds$"), "chem shift deltas"))
	relist.append((re.compile(r"c\d+.ds$"), "chem shift index"))
	relist.append((re.compile(r"p\d+.ds$"), "percent assigned"))
	relist.append((re.compile(r"g\d+.ds$"), "coupling constants"))
	relist.append((re.compile(r"n\d+.ds$"), "heteronuclear NOE"))
	relist.append((re.compile(r"o\d+.ds$"), "S2 order parameters"))
	relist.append((re.compile(r"s2p\d+-\d+.ds$"), "S2 predicted vs. experimental"))

	for tmp in relist:
		result = tmp[0].search(session)
		if (result != None):
			cat = tmp[1]
			break
		
	return cat

#-----------------------------------------------------------------
# For sorting.
def compareHostOpens(tmp):
	return tmp[1].openCt

#-----------------------------------------------------------------
# For sorting.
def compareSessionOpens(tmp):
	return tmp[1]

#-----------------------------------------------------------------
# Parse a timestamp of the form 'Aug 5, 2015 3:25:53 PM' into a
# datetime object.
def parseTimestamp(timeStr):
	if (debug > 1):
		print("parseTimestamp(%s)" % (timeStr))

	timeVal = None

	regex = re.compile(r"(?P<month>\w+)\s+(?P<day>\d+),\s+(?P<year>\d+)\s+(?P<hour>\d+):(?P<min>\d+):(?P<sec>\d+)\s+(?P<ampm>(am)|(pm))")
	result = regex.search(timeStr.lower())
	if (result != None):
		if (debug > 1):
			print("  parseTimestamp matches timeStr " + timeStr)
		monthStr = result.group('month')
		day = int(result.group('day'))
		year = int(result.group('year'))
		hour = int(result.group('hour'))
		minute = int(result.group('min'))
		second = int(result.group('sec'))
		ampm = result.group('ampm')

		if (debug > 1):
			print("    monthStr: ", monthStr)
			print("    day: ", day)
			print("    year: ", year)
			print("    hour: ", hour)
			print("    minute: ", minute)
			print("    second: ", second)
			print("    ampm: ", ampm)

		monthList = ["jan", "feb", "mar", "apr", "may", "jun", "jul", "aug", "sep", "oct", "nov", "dec"]
		if (monthStr in monthList):
			monthNum = monthList.index(monthStr) + 1
			if (debug > 1):
				print("    monthNum: ", monthNum)
			if (ampm == "pm" and hour < 12):
				hour += 12
			timeVal = datetime.datetime(year, monthNum, day, hour, minute, second)
	else:
		print("Unrecognized time string: %s", (timeStr))

	if (debug > 1):
		print("timeVal:", timeVal)
	return timeVal

#-----------------------------------------------------------------
main(sys.argv[1:])
