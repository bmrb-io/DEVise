/*
  ========================================================================
  DEVise Data Visualization Software
  (c) Copyright 1992-1997
  By the DEVise Development Group
  Madison, Wisconsin
  All Rights Reserved.
  ========================================================================

  Under no circumstances is this software to be copied, distributed,
  or altered in any way without prior permission from the DEVise
  Development Group.
*/

/*
  Implementation of Client (and CompDate) classes.
 */

/*
  $Id$

  $Log$
  Revision 1.3  1998/03/11 18:25:19  wenger
  Got DEVise 1.5.2 to compile and link on Linux; includes drastically
  reducing include dependencies between csgroup code and the rest of
  the code, and within the csgroup code.  (Note: running collaboration
  doesn't work yet.)

  Revision 1.2  1998/02/12 17:15:07  wenger
  Merged through collab_br_2; updated version number to 1.5.1.

  Revision 1.1.2.3  1998/02/02 08:24:09  liping
  Added CVS header

*/

/* 
** Copyright 1997 Collaborator Design Team
** 
** Permission to use, copy, modify, and distribute this software and its
** documentation for any purpose and without fee is hereby granted,
** provided that the above copyright notice appear in all copies and that
** both that copyright notice and this permission notice appear in
** supporting documentation, and that the names of the University of
** Wisconsin and the Collaborator Design Team not be used in advertising or
** publicity pertaining to distribution of the software without specific,
** written prior permission.  The University of Wisconsin and the Collaborator
** Design Team make no representations about the suitability of this
** software for any purpose.  It is provided "as is" without express
** or implied warranty.
** 
** THE UNIVERSITY OF WISCONSIN AND THE COLLABORATOR DESIGN TEAM DISCLAIM ALL
** WARRANTIES WITH REGARD TO THIS SOFTWARE, INCLUDING ALL IMPLIED WARRANTIES
** OF MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE UNIVERSITY OF
** WISCONSIN OR THE COLLABORATOR DESIGN TEAM BE LIABLE FOR ANY SPECIAL, 
** INDIRECT OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING 
** FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, 
** NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION 
** WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
** 
** Author:  Ashish Thusoo
** 	         University of Wisconsin, Computer Sciences Dept.
** 
*/ 
/*
 * This is sample code generated by rpcgen.
 * These are only templates and you can use them
 * as a guideline for developing your own functions.
 */
#include <sys/ioctl.h>
#include <sys/types.h>
#include <sys/socket.h>
#include <netinet/in.h>
#include <arpa/inet.h>
#include <errno.h>
#include <sys/time.h>
#include <string.h>

#include <unistd.h> /* this might change later for the close function call */

#include "error.h"
#include "queue.h"
#include "server.h"
#include "colbr.h"
#include "colbrLog.h"
#include "serverInterface.h"
#include "sndMsg.h"
#include "prnfns.h"
#include "Csprotocols.h"
#include "ClientAPI.h"
#include "ctrlMsg.h"

int
register_1_svc(int fd, GroupKey *arg1, ConnectInfo arg2, int arg3)
{
	static int  result;
	DbEntry entry;

	prnBuf(PRN_BDG, "\n");
	prnBuf(PRN_HDG, "Rcvd: REGISTER \n");
	prnBuf(PRN_BDG, "From: ");
	prnConnectInfo(&arg2);
	prnBuf(PRN_BDG, "\n");
	prnBuf(PRN_BDG, "\t Group = %s ", arg1->grpName);
	prnBuf(PRN_BDG, "Modebits = ");
	prnMode(MOD_REG, arg3);

	entry.FileDesc = fd;
	memmove(&(entry.ServerAddr), &arg2, sizeof(arg2));
	entry.Enable = 1;
	if ((arg3 & CRM_LEADER) && (arg3 & CRM_FOLLOWER)) {
		
		result = ER_INVALIDMODE;
		return (result);
	}
	if (arg3 & CRM_CREATE) {

		result = AddGroup(arg1, LOG_ENABLE);
/*		if (result != 0) 
			return (result); */
	}
	if (arg3 & CRM_LEADER) {

		if (arg3 & CRM_CREATE) 
			result = NewLeader(arg1, &entry, LOG_ENABLE);
		else
			result = MakeLeader(arg1, &entry, LOG_ENABLE);
	}

	if (arg3 & CRM_FOLLOWER) {

		result = AppendServer(arg1, &entry, LOG_ENABLE);
	}
	return (result);
}

int
deregister_1_svc(int fd, GroupKey *arg1, ConnectInfo arg2, int arg3)
{
	static int  result;
	DbEntry entry;

	prnBuf(PRN_BDG, "\n");
	prnBuf(PRN_HDG, "Rcvd: DEREGISTER \n");
	prnBuf(PRN_BDG, "From: ");
	prnConnectInfo(&arg2);
	prnBuf(PRN_BDG, "\n");
	prnBuf(PRN_BDG, "\t Group = %s ", arg1->grpName);
	prnBuf(PRN_BDG, "Modebits = ");
	prnMode(MOD_DEREG, arg3);

	entry.FileDesc = fd;
	memmove(&(entry.ServerAddr), &arg2, sizeof(arg2));
	entry.Enable = 1;
	result = DeleteMaster(arg1, &entry, LOG_ENABLE);
	if (!result) {
/*		SetNewLeader(arg1, LOG_ENABLE); */
		goto delLabel;
	}
	if (result != ER_NOTLEADER) {
		return (result);
	}
	result = DeleteServer(arg1, &entry, LOG_ENABLE);
	if (!result) {
		goto delLabel;
	}
	result = DeleteWaiter(arg1, &entry, LOG_ENABLE);
	if (result) {
		return (result);
	}

delLabel:
	if (arg3 & CRM_DELETE) {

		result = DeleteGroup(arg1, LOG_ENABLE);
	}
	return (result);
}

int
querygroup_1_svc(GroupKey *arg1, ConnectInfo arg2, char*& arg3)
{
	TokenList tk(0);
	Entry *entr = NULL;
	GroupKey *GroupName;
	GroupInfo *gInfo;
	int		argc = 0;
	char	*argv[1000];

	for(entr = GroupDB.getfirst(); entr; entr = GroupDB.getnext()) 
	{
		GroupName = new GroupKey;
		memmove(GroupName->grpName, (entr->getKey())->data(),
			  (entr->getKey())->size());
		gInfo = (GroupInfo *)(entr->getData())->data();
		strcpy(GroupName->grpPwd, gInfo->pwd);

		// return non-control groups only
		if (strncmp(SERVERTAG,
				GroupName->grpPwd,
				strlen(SERVERTAG)))
			tk.appendToken(GroupName->grpName);
	}
	arg3 = strdup(tk.getList());
	return strlen(arg3)+1;
}
int
leadership_1_svc(GroupKey *arg1, ConnectInfo arg2, int arg3)
{
	static int result;
	DbEntry entry;

	prnBuf(PRN_BDG, "\n");
	prnBuf(PRN_HDG, "Rcvd: LEADERSHIP \n");
	prnBuf(PRN_BDG, "From: ");
	prnConnectInfo(&arg2);
	prnBuf(PRN_BDG, "\n");
	prnBuf(PRN_BDG, "\t Group = %s ", arg1->grpName);
	prnBuf(PRN_BDG, "Modebits = ");
	prnMode(MOD_LDR, arg3);

	entry.FileDesc = -1;
	memmove(&(entry.ServerAddr), &arg2, sizeof(arg2));
	entry.Enable = 1;

	if (arg3 & CRM_GRAB) {
		result = MakeLeader(arg1, &entry, LOG_ENABLE);
	}
	else if (arg3 & CRM_RELINQUISH) {
		result = MakeServer(arg1, &entry, LOG_ENABLE);
	}
	else {
		result = ER_INVALIDMODE;
	}
	
	return (result);
}

int
groupsend_1_svc(GroupKey *arg1, ConnectInfo arg2, Msg arg3)
{
	static int  result;
	Queue *servers;
	QueueElem *qElem;
	DbEntry *dbe;

	prnBuf(PRN_BDG, "\n");
	prnBuf(PRN_HDG, "Rcvd: GROUPSEND \n");
	prnBuf(PRN_BDG, "From: ");
	prnConnectInfo(&arg2);
	prnBuf(PRN_BDG, "\n");
	prnBuf(PRN_BDG, "\t Group = %s ", arg1->grpName);

	/* DT, 01/30 */
	/* fix message display */
	int argc, tsize;
	char** argv;
	int i;
	int hLength = ServerServerProt::getHeaderLength();

	NetworkAnalyzeHeader((const char *)arg3.msg, argc, tsize);
	NetworkParse((const char *)(arg3.msg + NetworkHeaderSize), argc, argv);

	for (i=0; (i<argc-hLength) && (i< 3); ++i)
	{
		prnBuf(PRN_BDG, "\t Msg = %s\n", argv[i+hLength]);
	}
	/* DT, 01/30 */

	servers = FetchServers(arg1);
	dbe = FetchMaster(arg1);
	if (dbe == NULL) {
		result = ER_NOTLEADER;
		return (result);
	}
	if (memcmp(&(dbe->ServerAddr), &arg2, sizeof(ConnectInfo))) {
		result = ER_NOTLEADER;
		return (result);
	}
	for(qElem = servers->getfirst(); qElem != NULL; 
		qElem = servers->getnext()) {
		dbe = (DbEntry *) (qElem->getelement()->data());
		if (dbe->Enable) {
			SendDataMsg(dbe, arg3.msg, arg3.size);
		}
	}

	/* DT: 01/30 */
	// broadcast also to those who requested for tokens
	Queue *waiters;

	waiters = FetchWaiters(arg1);
	for(qElem = waiters->getfirst(); qElem != NULL; 
		qElem = waiters->getnext()) {
		dbe = (DbEntry *) (qElem->getelement()->data());
		if (dbe->Enable) {
			SendDataMsg(dbe, arg3.msg, arg3.size);
		}
	}
	/* DT: 01/30 */
	result = 0;
	return (result);
}

int 
getckpt_1_svc(GroupKey *arg1, ConnectInfo arg2)
{
	static int  result;
	DbEntry *dbe;
	DbEntry entry;

	prnBuf(PRN_BDG, "\n");
	prnBuf(PRN_HDG, "Rcvd: GETCKPT \n");
	prnBuf(PRN_BDG, "From: ");
	prnConnectInfo(&arg2);
	prnBuf(PRN_BDG, "\n");
	prnBuf(PRN_BDG, "\t Group = %s ", arg1->grpName);

	dbe = FetchMaster(arg1);
	if (dbe == NULL) {

		result = ER_NOLEADER;
		return (result);
	}
	if (!memcmp(&(dbe->ServerAddr), &arg2, sizeof(ConnectInfo))) {
		
		result = 0;
		return (result);
	}
	memmove(&(entry.ServerAddr), &arg2, sizeof(ConnectInfo));
	entry.FileDesc = -1;
	entry.Enable = 0;
	result = DisableForwarding(arg1, &entry, LOG_ENABLE); /* Ctrl Msg sent*/
	if (result != 0) {

		return (result);
	}
	SendCtrlMsg(dbe, CTRL_CKPTSERVER, &arg2, arg1);
	return (result);
}

int 
execckpt_1_svc(GroupKey *arg1, ConnectInfo arg2)
{
	static int  result;
	DbEntry *dbe;
	DbEntry entry;

	prnBuf(PRN_BDG, "\n");
	prnBuf(PRN_HDG, "Rcvd: EXECCKPT \n");
	prnBuf(PRN_BDG, "From: ");
	prnConnectInfo(&arg2);
	prnBuf(PRN_BDG, "\n");
	prnBuf(PRN_BDG, "\t Group = %s ", arg1->grpName);

	dbe = FetchMaster(arg1);
	if (dbe == NULL) {

		result = ER_NOTLEADER;
		return (result);
	}
	memmove(&(entry.ServerAddr), &arg2, sizeof(ConnectInfo));
	entry.FileDesc = -1;
	entry.Enable = 0;
	result = EnableForwarding(arg1, &entry, LOG_ENABLE); /* Ctrl Msg sent*/
	if (result != 0) {

		return (result);
	}
	result = 0;
	return (result);
}

int
setnewleader_1_svc(GroupKey *GroupName) {
	int ret;

	ret = SetNewLeader(GroupName, LOG_ENABLE);
	return ret;
}
