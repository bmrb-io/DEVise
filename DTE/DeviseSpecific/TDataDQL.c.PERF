/*
  ========================================================================
  DEVise Data Visualization Software
  (c) Copyright 1992-1996
  By the DEVise Development Group
  Madison, Wisconsin
  All Rights Reserved.
  ========================================================================

  Under no circumstances is this software to be copied, distributed,
  or altered in any way without prior permission from the DEVise
  Development Group.
*/

/*
  $Id$

  $Log$
  Revision 1.33  1998/06/29 17:18:16  wenger
  Fixed bug 372 (crashed in DataReader caused by a pointer alignment problem).

  Revision 1.32  1998/04/16 17:34:58  donjerko
  *** empty log message ***

  Revision 1.31  1998/04/14 17:04:02  donjerko
  Removed command "schema", using typecheck "select * from ..." instead.

  Revision 1.30  1998/04/10 16:25:53  donjerko
  *** empty log message ***

  Revision 1.29  1998/03/12 18:23:46  donjerko
  *** empty log message ***

  Revision 1.28  1997/12/23 23:34:19  liping
  Changed internal structure of BufMgrFull and classes it called
  The buffer manager is now able to accept queries on any attribute from the
          Query Processor
  The buffer manager is also able to issue queries on various attributes to DTE
  Instead of keeping an in memory list for each T/GData, the buffer manager keeps
          a list for each (T/GData, AttrName, Granularity) combination
  The class Range was replaced by Interval

  Revision 1.27  1997/12/04 04:05:33  donjerko
  *** empty log message ***

  Revision 1.26  1997/11/12 23:17:47  donjerko
  Improved error checking.

  Revision 1.25  1997/11/05 00:20:28  donjerko
  Added some error checking calls to the DTE.

  Revision 1.24  1997/10/10 21:07:27  liping
  The interface provided by TData::InitGetRecs and TData::GetRecs was changed
  The new interface carries the information of 1. LowId 2. HighId 3. AttrName
  	4. Granularity in the structure "Range"

  Revision 1.23  1997/09/17 02:36:07  donjerko
  *** empty log message ***

  Revision 1.22  1997/09/05 22:56:17  donjerko
  *** empty log message ***

  Revision 1.21  1997/09/05 22:20:31  donjerko
  Made changes for port to NT.

  Revision 1.20  1997/08/21 21:04:52  donjerko
  Implemented view materialization

  Revision 1.19  1997/08/09 00:55:03  donjerko
  Added indexing of select-project unmaterialized views.

  Revision 1.18  1997/07/22 15:01:31  donjerko
  Moved querying in InitGetRec

  Revision 1.17  1997/07/03 01:51:44  liping
  changed query interface to TData from RecId to double

  Revision 1.16  1997/06/27 23:17:29  donjerko
  Changed date structure from time_t and tm to EncodedDTF

  Revision 1.15  1997/06/16 16:05:11  donjerko
  New memory management in exec phase. Unidata included.

  Revision 1.13  1997/06/10 19:21:25  wenger
  Removed (some) debug output.

*/

//#define DEBUG
#include <assert.h>
#include <iostream.h>
#include <stdio.h>
#include <stdlib.h>
#include <fcntl.h>
#include <limits.h>
#include <unistd.h>
#include <errno.h>
#include <sys/types.h>
#include <sys/stat.h>
#include <string.h>
#include <string>
#include "AttrList.h"
#include "Timer.h"

#include "Parse.h"
#include "TDataDQL.h"
#include "Exit.h"
#include "Util.h"
#include "DataSourceFileStream.h"
#include "DataSourceSegment.h"
#include "DataSourceBuf.h"
#include "DevError.h"
#include "DataSeg.h"
#include "QueryProc.h"

#include "Engine.h"
#include "exception.h"
#include "types.h"
#include "queue.h"
#include "CatalogComm.h"

#ifdef ATTRPROJ
#   include "ApInit.h"
#else
#   include "Init.h"
#   include "DataSourceWeb.h"
#endif

# define  _STREAM_COMPAT

AttrType getDeviseType(string type){
	if(type == "int"){
		return IntAttr;
	}
	else if(type == "float"){
		return FloatAttr;
	}
	else if(type == "double"){
		return DoubleAttr;
	}
	else if(type.substr(0, 6) == "string"){
		return StringAttr;
	}
	else if(type == "date"){
		return DateAttr;
	}
	else if(type == "time_t"){
		return DateAttr;
	}
	else{
		cout << "Don't know DEVise type for: " << type << endl;
		assert(0);
	}
}

TDataDQL::TDataDQL(
	AttrList attrs,char *name, char *type, 
	int numFlds, string* types, int recSize, long totalRecs,
	int* sizes) : 
	TData(name, type, strdup("query"), 0), // query <- name
	_attrs(attrs),
	_numFlds(numFlds),
	_types(types),
	_sizes(sizes),
	_attributeNames(NULL),
	_marshalPtrs(NULL),
	engine(NULL),
	tuple(0)
{
  
#ifdef DEBUG
    printf("TDataDQL::TDataDQL(name = %s, type = %s, recSize = %d) called\n", 
	name, type, recSize);
    cout << "_attrs = ";
    _attrs.Print();
#endif

	_totalRecs = totalRecs;

	TData::_recSize = recSize;
}

void TDataDQL::runQuery(){

#if defined(DEBUG)
	cout << "Running query: " << _query << endl;
	cerr << ".";
#endif

	Timer::StopTimer();

	delete engine;
	tuple = 0;
	engine = new Engine(_query);
     TRY(engine->optimize(), );
     if(_numFlds != engine->getNumFlds() / 2){
		cerr << "_numFlds = " << _numFlds << endl;
		cerr << "engine->getNumFlds() = " << engine->getNumFlds() << endl;
	}
     assert(_numFlds == engine->getNumFlds() / 2);
	_types = new TypeID[_numFlds];
	const TypeID* tmpTypes = engine->getTypeIDs();
	for(int i = 0; i < _numFlds; i++){
		_types[i] = tmpTypes[2 * i];
	}
	_marshalPtrs = new MarshalPtr[_numFlds];
	for(int i = 0; i < _numFlds; i++){
		if(_types[i] == DATE_TP){
			_marshalPtrs[i] = dateToUnixTime;
		}
		else{
			_marshalPtrs[i] = getMarshalPtr(_types[i]);
		}
	}

	TRY(const Tuple* firstTup = engine->getFirst(), );
	if(!firstTup){
		cout << "Empty result set" << endl;
	}

	int offset = 0;
	_sizes = new int[_numFlds]; 
	_attrs.Clear();
	for(int i = 0; i < _numFlds; i++){

		int deviseSize;
		if(_types[i] == DATE_TP){
			deviseSize = sizeof(time_t);	
		}
		else{
			TRY(deviseSize = packSize(_types[i]), );
		}
#if defined(DEBUG)
		cout << "deviseSize = " << deviseSize << endl;
#endif

		_sizes[i] = deviseSize;
		AttrType deviseType = getDeviseType(_types[i]);
		bool hasHighLow = false;
		AttrVal* hiVal = new AttrVal;
		AttrVal* loVal = new AttrVal;
		if(_types[i].substr(0, 6) == "string"){

			// Devise will not take high and low values for strings

			hasHighLow = false;
		}
		else if(firstTup) {
			assert((unsigned) _sizes[i] <= sizeof(AttrVal));
			hasHighLow = true;
			_marshalPtrs[i](firstTup[2 * i + 1], (char*) hiVal);
			_marshalPtrs[i](firstTup[2 * i], (char*) loVal);
		}
		else {
			hasHighLow = false;
		}

		_attrs.InsertAttr(i, strdup(_attributeNames[i].c_str()), 
			offset, deviseSize, 
			deviseType, false, 0, false, false, hasHighLow, hiVal, 
			hasHighLow, loVal); 
		offset += deviseSize;
	}

	_recSize = offset;

	if(firstTup){
		// this is max(recId)
		_totalRecs = IInt::getInt(firstTup[2 * _recIdAttrPosition + 1]) + 1;
	}
	else{
		_totalRecs = 0;
	}

//	DataSeg::Set(_tableName, _query, 0, 0);

#if defined(DEBUG)
	cout << "_totalRecs = " << _totalRecs << endl;
//	cout << "Attr list is:\n";
	_attrs.Print();
#endif

	Timer::StartTimer();
}

TDataDQL::TDataDQL(char* tableName, List<char*>* attrList, char* query) : 
	_attrs(tableName), 
	_attributeNames(NULL),
	engine(NULL),
	tuple(0),
	TData(strdup(tableName), strdup("DQL"), strdup("query"), 0) 
{
	_tableName = strdup(tableName);
	_marshalPtrs = NULL;
	EXIT(char* attNames = dteListAttributes(_tableName));
	assert(attNames);
	char* attName = strtok(attNames, " ");
	string minmaxQ("select ");
	queryHeader += "select ";
	const int MAX_NUM_ATTRS = 100;
	_attributeNames = new string[MAX_NUM_ATTRS];
	int i = 0;
	_recIdAttrPosition = -1;
	while(attName){
		assert(i < MAX_NUM_ATTRS);	
		_attributeNames[i] = string(attName);
		if(_attributeNames[i] == RID_STRING){
			_recIdAttrPosition = i;
		}
		string delimiAttNm = addSQLQuotes(attName, '"');
		minmaxQ += string("min(t.") + delimiAttNm + 
			"), max(t." + delimiAttNm + ")";
		queryHeader += string("t.") + delimiAttNm;
		attName = strtok(NULL, " "); 	
		if(attName){
			minmaxQ += ", ";
			queryHeader += ", ";
		}
		i++;
	}
	assert(_recIdAttrPosition >= 0 || !"recId not found in schema");
	_numFlds = i;
	minmaxQ += string(" from ") + _tableName + " as t";
	queryHeader += string(" from ") + _tableName + " as t where ";
	_query = strdup(minmaxQ.c_str());
	this->attrList = attrList;
	runQuery();
	CATCH(
		cout << "DTE error coused by query: \n";
		cout << "   " << _query << endl;
		cout << currExcept->toString(); 
		currExcept = NULL; 
		cout << endl;
		exit(0);
	)
}

AttrList* TDataDQL::GetAttrList(){
  return &_attrs;
}

TDataDQL::~TDataDQL()
{
#ifdef DEBUG
  printf("TDataDQL destructor\n");
#endif
	delete [] _marshalPtrs;
	delete engine;
}

Boolean TDataDQL::CheckFileStatus()
{
  return true;
}

int TDataDQL::Dimensions(int *sizeDimension)
{
  sizeDimension[0] = _totalRecs;
  return 1;
}

Boolean TDataDQL::HeadID(RecId &recId)
{
  recId = 0;
  return (_totalRecs > 0);
}

Boolean TDataDQL::LastID(RecId &recId)
{
  // Find the last record 
  recId = _totalRecs - 1;
  return (_totalRecs > 0);
}

TData::TDHandle TDataDQL::InitGetRecs(Interval *interval, int &bytesleft,
                                 Boolean asyncAllowed,
                                 ReleaseMemoryCallback *callback
				 )
{

/*
        cout << "********************* log record ******************\n"
             << "TDataDQL::InitGetRecs called\n"
             << "interval->AttrName = " << interval->AttrName << "\n"
             << "interval->Low = " << interval->Low << "\n"
             << "interval->High = " << interval->High << "\n"
             << "interval->NumRecs = " << interval->NumRecs << "\n"
             << "*************** end of log record ******************\n";
*/

	
#if defined(DEBUG)
  cerr << "TDataDQL::InitGetRecs(" << interval->Low << ", " << interval->High << ")\n";
#endif

  TDataRequest *req = new TDataRequest;
  DOASSERT(req, "Out of memory");

  req->nextVal = interval->Low;
  req->endVal = interval->High;
  // req->MaxNumRecs = interval->NumRecs;
  //req->NumReturnedSoFar = 0;
  req->relcb = callback;
  req->AttrName = new char[strlen(interval->AttrName)+1];
  strcpy(req->AttrName, interval->AttrName);
  req->granularity = 0;
  //req->validRecInTmpBuf = false;
  //req->tmpBuf = new char[_recSize];
  //req->ChunksReturnedSoFar=0;

  AttrInfo *attrInfo = _attrs.Find(interval->AttrName);

  string SQLquery ( queryHeader);
  char whereClause[79+strlen(interval->AttrName)*2+sizeof(double)*2];
  sprintf(whereClause, "t.%s>=%.20g and t.%s<=%.20g", interval->AttrName, interval->Low, interval->AttrName, interval->High);
  SQLquery+=whereClause;
  char orderbyClause[25 + strlen(interval->AttrName)];
  sprintf(orderbyClause, " order by t.\"%s\"", interval->AttrName);
  SQLquery+=orderbyClause;
  string query(SQLquery);

#if defined(DEBUG)
	cout << "Running: " << query << endl;
	static int entryCount;
	static double cumRecs;
	if(entryCount++ % 100 == 0){
		int percent = int(cumRecs / _totalRecs * 100);
		cerr << cumRecs << " records retreived (" << percent << "%) ";
		cerr << "dte called " << entryCount << " times" << endl;
	}
	cumRecs += interval->High - interval->Low + 1;
#endif

	delete engine;
	engine = new Engine(query);
	engine->optimize();
CATCH(
     cout << "DTE error coused by query: \n";
     cout << "   " << query << endl;
     cout << currExcept->toString();
     currExcept = NULL;
     cout << endl;
     exit(0);
)

  tuple = engine->getFirst();
CATCH(
     cout << "DTE error coused by query: \n";
     cout << "   " << query << endl;
     cout << currExcept->toString();
     currExcept = NULL;
     cout << endl;
     exit(0);
)

  bytesleft = (int)(RecSize() * ( req->endVal - req->nextVal + 1));

  return req;
}

Boolean TDataDQL::GetRecs(TDHandle req, void *buf, int bufSize, 
			  Interval *interval, int &dataSize)
{
  DOASSERT(req, "Invalid request handle");

  interval->NumRecs = bufSize / _recSize;
  DOASSERT(interval->NumRecs, "Not enough record buffer space");

  if (req->nextVal > req->endVal)
    return false;
  
  ReadRec((RecId)(req->nextVal), interval->NumRecs, buf);

  if (interval->NumRecs == 0)
	return false;
  
  //interval->Low = req->nextVal;
  dataSize = interval->NumRecs * _recSize;
  // req->nextVal += interval->NumRecs;
  
  _bytesFetched += dataSize;

  //interval->High = interval->Low + interval->NumRecs - 1;
  // interval->AttrName = req->AttrName;
  interval->Granularity = req->granularity;

/*
  RecId HIGHId, LOWId;
  DOASSERT(HeadID(LOWId), "can not find HeadID");
  DOASSERT(LastID(HIGHId), "can not find LastID");
  if (LOWId < req->nextVal)
  {
        interval->has_left = true;
        interval->left_adjacent = interval->Low - 1;
  }
  else
        interval->has_left = false;

  if (HIGHId > interval->High)
  {
        interval->has_right = true;
        interval->right_adjacent = interval->High + 1;
  }
  else
        interval->has_right = false;
*/


#if defined(DEBUG)
	static int entryCount;
	if(entryCount++ % 1000 == 0){
		cerr << " get recs called " << entryCount << "times\n";
	}
#endif

#ifdef DEBUG
  printf("TDataDQL::GetRecs buf = ");
  cout << " _recSize = " <<  _recSize << endl;
  for(int i = 0; i < _recSize; i++){
	printf("%x, ", *(((char*)buf) + i));
	// cout << hex << (short) *(((char*)buf) + i) << ", ";
  }
  cout << endl;
#endif

  
  return true;
}

void TDataDQL::DoneGetRecs(TDHandle req)
{
  DOASSERT(req, "Invalid request handle");

  delete req;
}

void TDataDQL::GetIndex(RecId id, int *&indices)
{
  static int index[1];
  index[0] = id;
  indices = index;
}

int TDataDQL::GetModTime()
{
  if (!CheckFileStatus())
    return -1;

  return _data->GetModTime();
}

char *TDataDQL::MakeIndexFileName(char *name, char *type)
{
  return 0;
}

void TDataDQL::Initialize()
{
 // Probably do all the things here..

}

void TDataDQL::Checkpoint()
{
}

void TDataDQL::InvalidateTData()
{
#if defined(DEBUG)
    cout << "Invalidating TDataDQL" << endl;
#endif
    runQuery();
	CATCH(
		cout << "DTE error coused by query: \n";
		cout << "   " << _query << endl;
		cout << currExcept->toString(); 
		currExcept = NULL; 
		cout << endl;
		exit(0);
	)
    TData::InvalidateTData();
}


/* Build index for the file. This code should work when file size
   is extended dynamically. Before calling this function, position
   should be at the last place where file was scanned. */

void TDataDQL::BuildIndex()
{

 // Find the last record, total Recs,...
 // _totalRecs = 2000;

}

// numRecs is in and out. in: max # of records. out: real # of records returned.
TD_Status TDataDQL::ReadRec(RecId rid, int &numRecs, void *buf){
	
	char *ptr = (char *)buf;

  int counter=0; // how many tuples have been written to buf;

  while(tuple && counter < numRecs){

		assert(tuple);
		for(int j = 0; j < _numFlds; j++){
			#if 0 
				WritePtr* writePtrs = newWritePtrs(_types, _numFlds);
				writePtrs[j](cerr, tuple[j]);
				delete [] writePtrs;
			#endif 
			_marshalPtrs[j](tuple[j], (char*) ptr);
			ptr += _sizes[j];
		}
		_nextToFetch++;
		counter++;
		tuple = engine->getNext();
	}

    numRecs = counter;
    return TD_OK;
}

void TDataDQL::WriteRecs(RecId startRid, int numRecs, void *buf)
{
 printf(" Failing Write Recs not supported \n");
 assert(0); 
}

void TDataDQL::WriteLine(void *line)
{
 printf(" Failing Write Recs not supported \n");
 assert(0); 
}

void TDataDQL::Run()
{
}

void TDataDQL::Cleanup()
{
}

void TDataDQL::PrintIndices()
{
}

