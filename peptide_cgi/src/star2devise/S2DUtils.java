// ========================================================================
// DEVise Data Visualization Software
// (c) Copyright 2000-2005
// By the DEVise Development Group
// Madison, Wisconsin
// All Rights Reserved.
// ========================================================================

// Under no circumstances is this software to be copied, distributed,
// or altered in any way without prior permission from the DEVise
// Development Group.

// ------------------------------------------------------------------------

// This class contains utility methods for Star to DEVise conversions.

// ------------------------------------------------------------------------

// $Id$

// $Log$
// Revision 1.2  2006/02/01 20:23:13  wenger
// Merged V2_1b4_br_0 thru peptide_cgi_10_8_0_base to the
// trunk.
//
// Revision 1.1.2.12.2.3  2005/10/14 21:19:31  wenger
// Most LACS processing now in place -- still needs lots of cleanup,
// though.
//
// Revision 1.1.2.12.2.2  2005/07/27 15:58:30  wenger
// Fixed S2DNmrStarIfc.getPdbIdsFromMolSys() to work for NMR-STAR 3.0,
// added test34 which tests that; better error handling in
// S2DUtils.arrayStr2Double().
//
// Revision 1.1.2.12.2.1  2005/05/19 16:07:43  wenger
// Merged nmrfam_mods2_br (argh -- must have forgotten to make
// nmrfam_mods2_br_0 tag!) thru nmrfam_mods2_br_3 to
// peptide_cgi_10_8_0_br.
//
// Revision 1.1.2.12  2005/04/22 21:41:10  wenger
// Okay, chemical shift data now pretty much works with NMR-STAR
// 3.0 (although a lot of cleanup is still needed).  The other
// types of data still need to be adapted to work with the
// "multiple entities per loop" model of 3.0.
//
// Revision 1.1.2.11.4.1  2005/05/12 19:07:41  wenger
// Merged nmrfam_mods_br_0 thru nmrfam_mods_br_1 to new
// nmrfam_mods2_br (created to get ambiguity visualization help
// and fix to coordinate visualization help).
//
// Revision 1.1.2.11.2.1  2005/05/12 17:40:33  wenger
// The format of the input file name (e.g., bmrXXXX.str, or whatever)
// and the comment email for the web pages are now configurable.
//
// Revision 1.1.2.11  2005/03/22 20:34:38  wenger
// Merged ambiguity_vis2_br_0 thru ambiguity_vis2_br_3 to V2_1b4_br.
//
// Revision 1.1.2.10.4.1  2005/03/10 19:27:36  wenger
// Merged ambiguity_vis_br_0 thru ambiguity_vis_br_end to
// ambiguity_vis2_br.
//
// Revision 1.1.2.10.2.1  2005/03/10 18:34:08  wenger
// I need to commit the ambiguity stuff I've done so far so I can make
// a new ambiguity branch that has the latest Pistachio changes.
//
// Revision 1.1.2.10  2005/01/31 23:02:55  wenger
// Merged pistachio_vis_br_0 thru pistachio_vis_br_1a to V2_1b4_br.
//
// Revision 1.1.2.9  2004/11/18 19:10:36  wenger
// Peptide-CGI now checks the version of the ChemShift software, since
// the current version of Peptide-CGI needs at least ChemShift 1.4.0.
//
// Revision 1.1.2.8.2.3  2005/01/28 18:49:01  wenger
// Added "color by figure of merit" option to the Pistachio visualization.
//
// Revision 1.1.2.8.2.2  2005/01/12 20:46:42  wenger
// Pistachio processing is now integrated into the normal Peptide-CGI
// processing -- the Pistachio visualization is generated autmatically
// if the Pistachio data exists.  (Still needs some cleanup, though.)
// (We generate the Pistachio visualization by generating a temporary
// mmCIF file with coordinates -- that is then run through the normal
// coordinate processing to generate the DEVise file with Pistachio
// coordinates.)
//
// Revision 1.1.2.8.2.1  2004/11/11 23:13:03  wenger
// Early prototype of Pistachio calculations and visualization;
// session, etc., are not automatically generated yet.  Note: I
// added some HN data to bmr6318_pistachio.str.nmrstr for the
// sake of my testing.
//
// Revision 1.1.2.8  2004/06/23 17:39:26  wenger
// Preliminary version of chem shift reference visualization 3 in
// place; cleaned up 4317 chem shift ref test data; changed fonts
// in chem shift ref visualization 1.
//
// Revision 1.1.2.7  2004/06/16 19:23:32  wenger
// Added headers to data files generated by Peptide-CGI.
//
// Revision 1.1.2.6  2004/01/30 18:20:41  wenger
// S2D errors and warnings are now saved to files (the files are
// named according to the data name).
//
// Revision 1.1.2.5  2004/01/26 18:55:37  wenger
// Incorporated "Eldon's" chemical shift reference session; added help
// pages for both chem shift ref visualizations (with no help info
// for now).
//
// Revision 1.1.2.4  2003/11/12 17:24:29  wenger
// S2d no longer uses do_csr.bat scripts -- all that stuff is now directly
// done in Java, to get around the problem that DOS batch files don't work
// right when run from within Java.  (New code is not yet fully tested.)
//
// Revision 1.1.2.3  2003/10/23 18:08:57  wenger
// Basic chem shift ref stuff is in place -- session and specific html
// files are generated, summary html file has link, etc.  The main thing
// left is the mechanics of calling Dan's chem shift ref software --
// right now I am just using a script that creates dummy chem shift
// ref data files.
//
// Revision 1.1.2.2  2003/05/09 16:21:06  wenger
// Removed case-sensitivity in residue labels.
//
// Revision 1.1.2.1  2003/04/22 21:58:16  wenger
// Added package name to peptide-cgi java code and put everything into
// a single jar file; version is now 6.0.
//
// Revision 1.7.18.1  2003/01/14 16:51:49  wenger
// Merged V2_1b3_br_0 thru V2_1b3_br_end to V2_1b4_br.
//
// Revision 1.7.16.1  2002/10/31 22:17:36  wenger
// Changed Exception output to use toString() instead of getMessage()
// because that (at least sometimes) produces more complete information.
//
// Revision 1.7  2001/10/10 22:37:33  wenger
// First version of atomic coordinate extraction and visualization (atoms,
// not bonds, only tested on 4096 -- coordinates must be in same NMR-STAR
// file as other data); fixed various minor problems with peptide-cgi code.
//
// Revision 1.6  2001/04/17 17:09:10  wenger
// Added display of H vs. N chem shifts.
//
// Revision 1.5  2001/04/16 19:49:11  wenger
// Added display of all chem shifts by amino acid.
//
// Revision 1.4  2001/03/08 20:33:25  wenger
// Merged changes from no_collab_br_0 thru no_collab_br_2 from the branch
// to the trunk.
//
// Revision 1.3.2.1  2001/02/09 16:57:13  wenger
// Added heteronuclear NOE; made T1 and T2 relaxation errors optional
// (conversion doesn't fail if they are not found); added an X margin of
// 0.5 in all sessions; updated star file list; misc. minor cleanups.
//
// Revision 1.3  2001/01/19 15:39:07  wenger
// Added T1 and T2 relaxation; removed some unnecessary variables from
// coupling constants; added schema files to installation, unified T1
// and T2 relaxation schema.
//
// Revision 1.2  2001/01/17 19:55:46  wenger
// Restructured the peptide-cgi code to make it much more maintainable.
//
// Revision 1.1  2000/08/11 21:41:34  wenger
// Fixed problems with the code assuming that BMRB accession numbers always
// have four digits.
//

// ========================================================================

package star2devise;

import java.io.*;
import java.util.*;
import java.text.DateFormat;

public class S2DUtils
{
    //===================================================================
    // VARIABLES

    private static final int DEBUG = 0;

    public static final int TYPE_INVALID = 0, TYPE_DELTASHIFT = 1,
      TYPE_CSI = 2, TYPE_PCT_ASSIGN = 3, TYPE_COUPLING = 4,
      TYPE_HXRATES = 5, TYPE_ORDER = 6, TYPE_T1_RELAX = 7, TYPE_T2_RELAX = 8,
      TYPE_HETNOE = 9, TYPE_ALL_CHEM_SHIFTS = 10, TYPE_HVSN_CHEM_SHIFTS = 11,
      TYPE_ATOMIC_COORDS = 12, TYPE_CHEM_SHIFT_REF1 = 13,
      TYPE_CHEM_SHIFT_REF2 = 14, TYPE_CHEM_SHIFT_REF3 = 15,
      TYPE_PISTACHIO = 16, TYPE_AMBIGUITY = 17, TYPE_LACS = 18;

    //===================================================================
    // PUBLIC METHODS

    //-------------------------------------------------------------------
    public static double[] arrayStr2Double(String[] values)
    {
	int count = values.length;
	double[] results = new double[count];

        for (int index = 0; index < count; index++) {
	    try {
	        results[index] = new Double(values[index]).doubleValue();
	    } catch(NumberFormatException ex) {
		// Note: the S2DWarning object below is *not* supposed to be
		// thrown...
		System.err.println(new S2DWarning(
		  "Exception parsing double: " + ex.toString()));
	        results[index] = Double.NaN;
	    }
	}

        return results;
    }

    //-------------------------------------------------------------------
    public static int[] arrayStr2Int(String[] values)
    {
	int count = values.length;
	int[] results = new int[count];

        for (int index = 0; index < count; index++) {
	    try {
	        results[index] = Integer.parseInt(values[index]);
	    } catch(NumberFormatException ex) {
	        System.err.println("Exception parsing int: " +
		  ex.toString());
	        results[index] = 0;
	    }
	}

        return results;
    }

    //-------------------------------------------------------------------
    public static String[] arrayToUpper(String[] values)
    {
	int count = values.length;
	String[] results = new String[count];

        for (int index = 0; index < count; index++) {
	    results[index] = values[index].toUpperCase();
	}
        
        return results;
    }

    //-------------------------------------------------------------------
    /**
     * Select all values in values for which the corresponding keys value
     * matches matchWith.
     * @param An array of values to match with.
     * @param An array of values to be selected from.
     * @param The value to match with.
     * @return An array of values selected from the values array.
     */
    public static String[] selectMatches(String[] keys, String[] values,
      String matchWith) throws S2DException
    {
        if (keys.length != values.length) {
	    throw new S2DError("Arrays of unequal length in " +
	      "S2DUtils.selectMatches");
	}

        int matchCount = 0;
	for (int index = 0; index < values.length; index++ ) {
	    if (keys[index].equals(matchWith)) matchCount++;
	}

	String[] result;
	if (matchCount == values.length) {
	    result = values;
	} else {
	    result = new String[matchCount];

	    int outIndex = 0;
	    for (int index = 0; index < values.length; index++ ) {
	    if (keys[index].equals(matchWith)) {
	            result[outIndex++] = values[index];
	        }
	    }
	}

	return result;
    }

    //-------------------------------------------------------------------
    static String replace(String str, String pattern, String replace)
    {
        int s = 0;
        int e = 0;
        StringBuffer result = new StringBuffer();

        while ((e = str.indexOf(pattern, s)) >= 0) {
            result.append(str.substring(s, e));
            result.append(replace);
            s = e+pattern.length();
        }
        result.append(str.substring(s));
        return result.toString();
    }

    //-------------------------------------------------------------------
    static void copyFile(String inFile, String outFile) throws IOException
    {
        if (DEBUG >= 1) {
	    System.out.println("S2DUtils.copyFile(" + inFile + ", " +
	      outFile + ")");
	}

	Reader reader = new FileReader(inFile);
	Writer writer = S2DFileWriter.create(outFile);

	char[] buffer = new char[8192];
	int totalBytes = 0;

	while (true) {
	    int tmpCount = reader.read(buffer);
	    if (tmpCount == -1) break;
	    writer.write(buffer, 0, tmpCount);
	    totalBytes += tmpCount;

	    if (DEBUG >= 2) {
	        System.out.println("  Copied " + totalBytes +
		  " bytes so far");
	    }
	}

	if (DEBUG >= 1) {
	    System.out.println("  Copied " + totalBytes + " bytes total");
	}

	writer.close();
	reader.close();
    }

    //-------------------------------------------------------------------
    static void deleteFile(String fileName) throws IOException
    {
        File file = new File(fileName);
	if (file.exists()) {
	    if (!file.delete()) {
	        throw new IOException("Failed to delete existing file " +
		  fileName);
	    }
	}
    }

    //-------------------------------------------------------------------
    static String getCurrentDateStr()
    {
        Date date = new Date();
	DateFormat dtf = DateFormat.getDateTimeInstance(DateFormat.MEDIUM,
	  DateFormat.MEDIUM);
        String str = dtf.format(date);

	return str;
    }

    //-------------------------------------------------------------------
    /**
     * Compare two version strings.
     * @param The first version string.
     * @param The second version string.
     * @return -1 if the first version is less than the second; 0 if
     *   the versions are equal; 1 if version1 is greater than version2.
     */
    static int compareVersions(String version1, String version2)
      throws S2DError
    {
    	MyVersion v1 = new MyVersion(version1);
    	MyVersion v2 = new MyVersion(version2);

	if (v1.major > v2.major) {
	    return 1;
	} else if (v1.major < v2.major) {
	    return -1;
	} else if (v1.minor > v2.minor) {
	    return 1;
	} else if (v1.minor < v2.minor) {
	    return -1;
	} else if (v1.rev > v2.rev) {
	    return 1;
	} else if (v1.rev < v2.rev) {
	    return -1;
        } else {
	    return 0;
	}
    }

    //===================================================================
    // PRIVATE METHODS
    private static class MyVersion
    {
        public int major;
	public int minor;
	public int rev;

	public MyVersion(String versionString) throws S2DError
	{
            String[] substrs = versionString.split("[\\.x]");
	    if (substrs.length < 2) {
	        throw new S2DError("Incomplete version string: " +
		  versionString);
	    }

	    major = Integer.parseInt(substrs[0]);
	    minor = Integer.parseInt(substrs[1]);
	    rev = Integer.parseInt(substrs[2]);
	}
    }
}

// ========================================================================
