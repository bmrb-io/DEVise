// ========================================================================
// DEVise Data Visualization Software
// (c) Copyright 2000-2002
// By the DEVise Development Group
// Madison, Wisconsin
// All Rights Reserved.
// ========================================================================

// Under no circumstances is this software to be copied, distributed,
// or altered in any way without prior permission from the DEVise
// Development Group.

// ------------------------------------------------------------------------

// This class reads an NMR-Star file and generates data and session files
// to be used by DEVise, and a summary html page and individual html pages
// for each session.

// ------------------------------------------------------------------------

// $Id$

// $Log$
// Revision 1.32  2002/02/23 19:30:19  wenger
// Peptide-cgi now identifies related PDB entries.
//
// Revision 1.31  2002/01/15 22:16:13  wenger
// Added residue selection to atomic coordiate sessions.
//
// Revision 1.30  2002/01/10 22:16:57  wenger
// Forgot to update version with addition of structure type selection.
//
// Revision 1.29  2001/12/18 18:42:59  wenger
// Changed mouse location display in peptide-cgi session templates as
// requested by John Markley.
//
// Revision 1.28  2001/12/12 21:55:18  wenger
// Changed mouse location display formats as requested by John Markley.
//
// Revision 1.27  2001/12/12 19:56:42  wenger
// Got 4038/4096 star file combination working; fixed maximum bond length.
//
// Revision 1.26  2001/12/11 20:23:34  wenger
// First version of bond-visualization generation; added RCS Id string to
// schema files; manually added environment variables to data source
// definitions.
//
// Revision 1.25  2001/12/05 20:07:51  wenger
// Partially added provision for multiple-star-file entries; fixed minor
// problem in setup makefile.
//
// Revision 1.24  2001/12/03 19:30:21  wenger
// Added JavaScreen collaboration link to html pages generated by
// peptide-cgi.
//
// Revision 1.23  2001/10/10 22:37:33  wenger
// First version of atomic coordinate extraction and visualization (atoms,
// not bonds, only tested on 4096 -- coordinates must be in same NMR-STAR
// file as other data); fixed various minor problems with peptide-cgi code.
//
// Revision 1.22  2001/09/21 15:25:57  wenger
// Updated session templates to match DEVise font scaling fix; changed
// peptide-cgi version to 2.13.
//
// Revision 1.21  2001/07/25 21:32:53  wenger
// Various distribution-related cleanups and fixes; added a few missing
// help files.
//
// Revision 1.20  2001/07/25 19:56:23  wenger
// Started adding configuration setup stuff; s2d gets URLs from properties
// file.
//
// Revision 1.19  2001/07/25 17:46:49  wenger
// Added -usage and -version args to S2DMain, changed version to 2.12;
// slightly improved s2d error messages; install script now uses find
// to change the mode of html/data files to avoid argument overflow;
// distribution now generates tar file name with version number.
//
// Revision 1.18  2001/05/21 18:57:04  wenger
// Updated peptide-cgi code to match JavaScreen with package.
//
// Revision 1.17  2001/05/14 19:36:50  wenger
// We now still generate chemical shift visualizations if we can't get
// residue counts.
//
// Revision 1.16  2001/05/14 18:08:26  wenger
// Parameterized all star file tag names, etc.
//
// Revision 1.15  2001/05/08 18:24:18  wenger
// Fixed problem getting residue count if a star file contains info for
// more than one protein; added residue counts to 'all shifts' and 'H
// vs. N' visualizations.
//
// Revision 1.14  2001/04/30 17:45:18  wenger
// Added special link to 3D 4096 visualization to 4096 summary page;
// added "No chemical shift data available" message to appropriate
// summary pages.
//
// Revision 1.13  2001/04/24 18:06:43  wenger
// More improvements to "all chem shifts" visualization; found and fixed
// bug 666.
//
// Revision 1.12  2001/04/24 15:26:11  wenger
// Reversed axes in "all chem shifts" and "H vs. N chem shift"
// visualizations, and added atom type selection to "all chem shifts";
// updated star file list.
//
// Revision 1.11  2001/04/18 15:14:50  wenger
// Various improvements to "H vs. N" and "all chem shift" visualizations
// as requested yesterday at BMRB meeting; added string files to CVS and
// the install process.
//
// Revision 1.10  2001/04/17 17:09:09  wenger
// Added display of H vs. N chem shifts.
//
// Revision 1.9  2001/04/16 19:49:11  wenger
// Added display of all chem shifts by amino acid.
//
// Revision 1.8  2001/03/13 14:50:10  wenger
// Added cache invalidation: cache files are not used if peptide-cgi code
// or NMR-Star file has changed since relevant cache files were generated.
//
// Revision 1.7  2001/03/08 21:10:34  wenger
// Merged changes from no_collab_br_2 thru no_collab_br_3 from the branch
// to the trunk.
//
// Revision 1.6  2001/03/08 20:33:24  wenger
// Merged changes from no_collab_br_0 thru no_collab_br_2 from the branch
// to the trunk.
//
// Revision 1.5.2.2  2001/02/22 19:52:54  wenger
// Made most coupling constant values optional; added (optional) coupling
// constant error values.
//
// Revision 1.5.2.1  2001/02/09 16:57:12  wenger
// Added heteronuclear NOE; made T1 and T2 relaxation errors optional
// (conversion doesn't fail if they are not found); added an X margin of
// 0.5 in all sessions; updated star file list; misc. minor cleanups.
//
// Revision 1.5  2001/01/30 17:44:47  wenger
// Added path for set_modes.
//
// Revision 1.4  2001/01/25 16:37:46  wenger
// Fixed a bug that could cause an infinite loop in the perecent assignment
// calculations; put filesize, cpu, and coredump limits in s2d script;
// updated star file list; got rid of some unnecessary warnings.
//
// Revision 1.3  2001/01/23 19:35:19  wenger
// Made a few minor fixes to get things to work right at BMRB.
//
// Revision 1.2  2001/01/19 15:39:06  wenger
// Added T1 and T2 relaxation; removed some unnecessary variables from
// coupling constants; added schema files to installation, unified T1
// and T2 relaxation schema.
//
// Revision 1.1  2001/01/17 20:00:07  wenger
// Restructured the peptide-cgi code to make it much more maintainable.
//

// ========================================================================

import EDU.bmrb.starlibj.SaveFrameNode;
import java.util.*;
import java.io.*;
import java.text.*;

// for chemical shifts

public class S2DMain {
    //===================================================================
    // VARIABLES

    private static final int DEBUG = 0;

    public static final String PEP_CGI_VERSION = "2.21";

    private int _masterAccNum; // accession number the user requested

    // A list of all accession numbers we need to access for this entry.
    private Vector _accNums = new Vector();

    // A list of related PDB files we want to process for this entry.
    private Vector _pdbIds = new Vector(); // Vector contains Strings

    private String _dataDir;
    private String _sessionDir;
    private String _connectionFile;
    
    private boolean _force = false;

    private S2DSummaryHtml _summary;

    //===================================================================
    // PUBLIC METHODS

    //-------------------------------------------------------------------
    public static void main(String args[]) throws S2DException
    {
        S2DMain s2d = new S2DMain(args);
	try {
	    if (!s2d.useCache()) {
	        s2d.process();
	    } else {
	        if (DEBUG >= 1) {
		    System.out.println("Cache files used");
		}
	    }
	} catch (S2DWarning ex) {
	    System.err.println(ex.getMessage());
	} catch (Exception ex) {
	    ex.printStackTrace();
	    throw new S2DError("NMR-Star to DEVise conversion failed");
	}
    }

    //-------------------------------------------------------------------
    // Constructor.
    public S2DMain(String args[]) throws S2DException
    {
        if (DEBUG >= 1) {
	    String sep = "";
	    System.out.print("S2DMain.S2DMain(");
	    for (int index = 0; index < args.length; index++) {
	        System.out.print(sep + args[index]);
		sep = ", ";
	    }
	    System.out.print(")\n");
	}

	checkArgs(args);
	getProperties();
    }

    //===================================================================
    // PRIVATE METHODS

    //-------------------------------------------------------------------
    // Get configuration-specific properties and set variables accordingly.
    private void getProperties() throws S2DException
    {
        Properties props = new Properties();
	try {
	    props.load(new BufferedInputStream(
	      new FileInputStream("s2d.props")));
        } catch (FileNotFoundException ex) {
	    throw new S2DError("Can't find s2d properties file: " +
	      ex.getMessage());
	} catch (IOException ex) {
	    throw new S2DError("Error reading s2d properties file: " +
	      ex.getMessage());
	}

	S2DNames.BMRB_STAR_URL = props.getProperty("bmrb_mirror.star_url");
	if (S2DNames.BMRB_STAR_URL == null) {
	    throw new S2DError("Unable to get value for " +
	      "bmrb_mirror.star_url property");
	}

	S2DNames.PDB_FILE_URL = props.getProperty("bmrb_mirror.pdb_file_url");
	if (S2DNames.PDB_FILE_URL == null) {
	    throw new S2DError("Unable to get value for " +
	      "bmrb_mirror.pdb_file_url property");
	}

	S2DNames.BMRB_3D_URL = props.getProperty("bmrb_mirror.3d_url");
	if (S2DNames.BMRB_3D_URL == null) {
	    throw new S2DError("Unable to get value for " +
	      "bmrb_mirror.3d_url property");
	}
    }

    //-------------------------------------------------------------------
    // Check arguments to constructor, set member variables accordingly.
    private void checkArgs(String args[]) throws S2DException
    {
	String usage = "Usage: java S2DMain [-force] " +
	  "<accession number> <data directory> <session directory> " +
	  "<connection file>";

	if (args.length == 1 && args[0].equals("-usage")) {
	    System.out.println(usage);
	    System.exit(0);
	} else if (args.length == 1 && args[0].equals("-version")) {
	    System.out.println(PEP_CGI_VERSION);
	    System.exit(0);
	} else if (args.length < 4 || args.length > 5) {
	    System.out.println(usage);
	    throw new S2DError("Illegal arguments");
	} else {
	    int index = 0;
	    if (args.length == 5) {
		if (args[index].equals("-force")) {
		    _force = true;
		} else {
	            System.out.println(usage);
	            throw new S2DError("Illegal arguments");
		}
	        index++;
	    }
	    try {
	        _masterAccNum = Integer.parseInt(args[index]);
		addAccNum(_masterAccNum);
	        index++;
	        _dataDir = args[index];
	        index++;
	        _sessionDir = args[index];
	        index++;
		_connectionFile = args[index];
	    } catch(NumberFormatException ex) {
	        System.err.println("Error parsing arguments: " +
		  ex.getMessage());
	        throw new S2DError("Error parsing " + ex.getMessage());
	    }
	}
    }

    //-------------------------------------------------------------------
    // Decide whether to use cached versions of the relevant output files.
    private boolean useCache()
    {
        boolean result = false;

	check:
	if (!_force) {
	    FileReader freader;

	    //
	    // Find out whether the summary html file exists.
	    //
	    try {
	        freader = new FileReader(S2DSummaryHtml.fileName(_dataDir,
		  _masterAccNum));
	    } catch (FileNotFoundException ex) {
		if (DEBUG >= 1) {
		    System.out.println("Summary html file " +
		      ex.getMessage() + " not found; cache not used");
		}
	        break check;
	    }

	    //
	    // Get summary html file version and date.
	    //
	    String fileVersion = null;
	    Date fileDate = null;
	    BufferedReader breader = new BufferedReader(freader);
	    try {
	        String line;
	        while ((line = breader.readLine()) != null) {
		    int index;
		    if ((index = line.indexOf(S2DSummaryHtml.VERSION_LABEL))
		      != -1) {

		        int index1 = line.indexOf("{", index);
		        int index2 = line.indexOf("}", index1);
			if (index1 != -1 && index2 != -1) {
			    fileVersion = line.substring(index1 + 1, index2);
			}
		    }

		    if ((index = line.indexOf(S2DSummaryHtml.GEN_DATE_LABEL))
		      != -1) {
		        int index1 = line.indexOf("{", index);
		        int index2 = line.indexOf("}", index1);
			if (index1 != -1 && index2 != -1) {
			    String dateStr = line.substring(index1 + 1, index2);
			    fileDate = DateFormat.getDateInstance().
			      parse(dateStr);
			}
		    }
	        }
	    } catch (ParseException ex) {
		System.err.println("ParseException: " + ex.getMessage());
		break check;
	    } catch (IOException ex) {
		System.err.println("IOException: " + ex.getMessage());
		break check;
	    } finally {
		try {
	            breader.close();
		} catch (IOException ex) {
		    System.err.println("IOException: " + ex.getMessage());
		    break check;
		}
	    }

	    //
	    // Compare summary file version to current peptide-cgi software
	    // version.
	    //
	    if (!PEP_CGI_VERSION.equals(fileVersion)) {
		if (DEBUG >= 1) {
		    System.out.println("Existing summary html file version (" +
		      fileVersion + ") does not " +
		      "match current software version (" + PEP_CGI_VERSION +
		      "); cache not used");
		}
	        break check;
	    }

	    //
	    // Compare the generation date of the summary html file to the
	    // modification date for the NMR-Star file.
	    //
	    Date starModDate = S2DStarIfc.getModDate(_masterAccNum);
	    if (starModDate == null || starModDate.after(fileDate)) {
		if (DEBUG >= 1) {
		    System.out.println("Existing summary html file is " +
		      "older than NMR-Star file; cache not used");
		}
	        break check;
	    }

	    result = true;
	}

	return result;
    }

    //-------------------------------------------------------------------
    // Add an accession number to the list to be processed (avoiding
    // duplicates).
    private void addAccNum(int accNum)
    {
        if (DEBUG >= 2) {
            System.out.println("addAccNum(" + accNum + ")");
        }

	boolean found = false;
        for (int index = 0; index < _accNums.size(); index++) {
	    Integer entry = (Integer)_accNums.elementAt(index);
	    if (entry.intValue() == accNum) found = true;
	}

	if (!found) {
	    _accNums.insertElementAt(new Integer(accNum), _accNums.size());
	}
    }

    //-------------------------------------------------------------------
    // Add PDB IDs to the list of PDB files to be processed.
    private void addPDB(Vector ids)
    {
        if (DEBUG >= 2) {
            System.out.println("addPDB()");
        }

	for (int index = 0; index < ids.size(); index++) {
	    String id = (String)ids.elementAt(index);

	    // Avoid duplicates.
	    if (!_pdbIds.contains(id)) {
	        _pdbIds.addElement(id);
	    }
	}
    }

    //-------------------------------------------------------------------
    // Do the processing.
    private void process() throws S2DException
    {
        S2DStarIfc star = new S2DStarIfc(_masterAccNum);

	_summary = new S2DSummaryHtml(_masterAccNum, _dataDir,
	  star.getFileName(), star.getSystemName(),
	  star.getEntryTitle());

        for (int index = 0; index < _accNums.size(); index++) {
            Integer entry = (Integer)_accNums.elementAt(index);
	    int accNum = entry.intValue();

	    // TEMP -- removed hard-coded links once we establish some
	    // kind of convention for the _Related_BMRB_accession_number
	    // info.

	    // Note: 4038 has chem shifts for 4096.
            if (accNum == 4038) {
	        addAccNum(4096);
	    } else if (accNum == 4096) {
	        addAccNum(4038);
	    }

	    if (index > 0) { // avoid parsing the "master" file twice
                star = new S2DStarIfc(accNum);
	    }

	    Vector ids = star.getPdbIds();
	    addPDB(ids);

	    //TEMP -- do I really want to skip stuff if I get an error?
	    saveChemShifts(star);
	    saveT1Relaxation(star);
	    saveT2Relaxation(star);
	    saveHetNOE(star);
	    saveHExchangeRate(star);
	    saveCoupling(star);
	    saveHExchangeProtFact(star);
	    saveS2Params(star);
	    saveAtomicCoords(star);
        }

	for (int index = 0; index < _pdbIds.size(); index++) {
	    String id = (String)_pdbIds.elementAt(index);
	    //TEMP processPDB(star, id);
	}

	_summary.close();
	_summary = null;

	//
	// Make sure that all of the files that we generated are world-
	// readable.
	//
	try {
	    Runtime currentRT = Runtime.getRuntime();
	    Process ps = currentRT.exec("./set_modes " + _masterAccNum);
	    ps.waitFor();
	    int result = ps.exitValue();
	    if (result != 0) {
	        throw new S2DWarning("Non-zero exit value from set_modes; " +
		  "see set_modes.out");
	    }
	} catch (Exception ex) {
	    System.err.println("Error setting file permissions: " +
	      ex.getMessage());
	}
    }

    //-------------------------------------------------------------------
    // Save all chem shift data for this entry.
    // Note: this can be tested with 4264.
    private void saveChemShifts(S2DStarIfc star) throws S2DException
    {
        if (DEBUG >= 2) {
	    System.out.println("  S2DMain.saveChemShifts()");
	}

	Enumeration frameList = star.getDataFramesByCat(
	  S2DNames.ASSIGNED_CHEM_SHIFTS);

	int frameIndex = 1;
        while (frameList.hasMoreElements()) {
	    SaveFrameNode frame = (SaveFrameNode)frameList.nextElement();

	    // We only want to output chemical shifts if this save frame
	    // has data for a protein.  (This can be tested with bmr4038.str
	    // and bmr4056.str.)
	    if (!star.isAProtein(frame)) {
                if (DEBUG >= 1) {
                    System.out.println("Chemical shifts not saved for " +
                      "save frame " + frame.getLabel() + " because it is " +
                      "not a protein");
                }
	    } else {
		try {
	            saveFrameResCounts(star, frame, frameIndex);
	            saveFrameChemShifts(star, frame, frameIndex);
		} catch(S2DException ex) {
		    System.err.println("Exception saving chem shifts for " +
		      "frame " + star.getFrameName(frame) + ": " +
		      ex.getMessage());
		}
		frameIndex++;
	    }
	}
    }

    //-------------------------------------------------------------------
    // Save all T1 relaxation data for this entry.
    // Note: this can be tested with 4267.
    private void saveT1Relaxation(S2DStarIfc star) throws S2DException
    {
        if (DEBUG >= 2) {
	    System.out.println("  S2DMain.saveT1Relaxation()");
	}

	Enumeration frameList = star.getDataFramesByCat(S2DNames.T1_RELAX);

	int frameIndex = 1;
        while (frameList.hasMoreElements()) {
	    SaveFrameNode frame = (SaveFrameNode)frameList.nextElement();
	    try {
	        saveFrameT1Relax(star, frame, frameIndex);
	    } catch(S2DException ex) {
		System.err.println("Exception saving T1 relaxation for " +
		  "frame " + star.getFrameName(frame) + ": " +
		  ex.getMessage());
	    }
	    frameIndex++;
        }
    }

    //-------------------------------------------------------------------
    // Save all T2 relaxation data for this entry.
    // Note: this can be tested with 4267.
    private void saveT2Relaxation(S2DStarIfc star) throws S2DException
    {
        if (DEBUG >= 2) {
	    System.out.println("  S2DMain.saveT2Relaxation()");
	}

	Enumeration frameList = star.getDataFramesByCat(S2DNames.T2_RELAX);

	int frameIndex = 1;
        while (frameList.hasMoreElements()) {
	    SaveFrameNode frame = (SaveFrameNode)frameList.nextElement();
	    try {
	        saveFrameT2Relax(star, frame, frameIndex);
	    } catch(S2DException ex) {
		System.err.println("Exception saving T2 relaxation for " +
		  "frame " + star.getFrameName(frame) + ": " +
		  ex.getMessage());
	    }
	    frameIndex++;
        }
    }

    //-------------------------------------------------------------------
    // Save all heteronuclear NOE values for this entry.
    // Note: this can be tested with 4267.
    private void saveHetNOE(S2DStarIfc star) throws S2DException
    {
        if (DEBUG >= 2) {
	    System.out.println("  S2DMain.saveHetNOE()");
	}

	// add real code here
	Enumeration frameList = star.getDataFramesByCat(
	  S2DNames.HETERONUCLEAR_NOE);

	int frameIndex = 1;
        while (frameList.hasMoreElements()) {
	    SaveFrameNode frame = (SaveFrameNode)frameList.nextElement();
	    try {
	        saveFrameHetNOE(star, frame, frameIndex);
	    } catch(S2DException ex) {
		System.err.println("Exception saving heteronuclear NOE for " +
		  "frame " + star.getFrameName(frame) + ": " +
		  ex.getMessage());
	    }
	    frameIndex++;
        }
    }

    //-------------------------------------------------------------------
    private void saveHExchangeRate(S2DStarIfc star)
    {
        if (DEBUG >= 2) {
	    System.out.println("  S2DMain.saveHExchangeRate()");
	}

	// add real code here
    }

    //-------------------------------------------------------------------
    // Save all coupling constants for this entry.
    // Note: this can be tested with 4297.
    private void saveCoupling(S2DStarIfc star) throws S2DException
    {
        if (DEBUG >= 2) {
	    System.out.println("  S2DMain.saveCoupling()");
	}

	Enumeration frameList = star.getDataFramesByCat(
	  S2DNames.COUPLING_CONSTANTS);

	int frameIndex = 1;
        while (frameList.hasMoreElements()) {
	    SaveFrameNode frame = (SaveFrameNode)frameList.nextElement();
	    try {
	        saveFrameCoupling(star, frame, frameIndex);
	    } catch(S2DException ex) {
		System.err.println("Exception saving coupling constants for " +
		  "frame " + star.getFrameName(frame) + ": " +
		  ex.getMessage());
	    }
	    frameIndex++;
        }
    }

    //-------------------------------------------------------------------
    private void saveHExchangeProtFact(S2DStarIfc star)
    {
        if (DEBUG >= 2) {
	    System.out.println("  S2DMain.saveHExchangeProtFact()");
	}

	// add real code here
    }

    //-------------------------------------------------------------------
    private void saveS2Params(S2DStarIfc star)
    {
        if (DEBUG >= 2) {
	    System.out.println("  S2DMain.saveS2Params()");
	}

	// add real code here
    }

    //-------------------------------------------------------------------
    private void saveAtomicCoords(S2DStarIfc star) throws S2DException
    {
        if (DEBUG >= 2) {
	    System.out.println("  S2DMain.saveAtomicCoords()");
	}

	Enumeration frameList = star.getDataFramesByCat(
	  S2DNames.ATOM_COORD_SAVE_FRAME);

	int frameIndex = 1;
        while (frameList.hasMoreElements()) {
	    SaveFrameNode frame = (SaveFrameNode)frameList.nextElement();
	    try {
	        saveFrameAtomicCoords(star, frame, frameIndex);
	    } catch(S2DException ex) {
		System.err.println("Exception saving atomic coordinates for " +
		  "frame " + star.getFrameName(frame) + ": " +
		  ex.getMessage());
	    }
	    frameIndex++;
        }
    }

    //-------------------------------------------------------------------
    // Save residue counts for the given save frame.
    private void saveFrameResCounts(S2DStarIfc star, SaveFrameNode frame,
      int frameIndex) throws S2DException
    {
        if (DEBUG >= 3) {
	    System.out.println("    S2DMain.saveFrameResCounts(" +
	      star.getFrameName(frame) + ", " + frameIndex + ")");
	}

	SaveFrameNode tmpFrame = star.getMonoPolyFrame(frame);

	int [] resSeqCodes = null;
	String [] residueLabels = null;
	try {
	    String [] resSeqCodesTmp = star.getFrameValues(tmpFrame,
	      S2DNames.RESIDUE_SEQ_CODE, S2DNames.RESIDUE_SEQ_CODE);
	    resSeqCodes = S2DUtils.arrayStr2Int(resSeqCodesTmp);
	    resSeqCodesTmp = null;

	    residueLabels = star.getFrameValues(tmpFrame,
	      S2DNames.RESIDUE_SEQ_CODE, S2DNames.RESIDUE_LABEL);
        } catch (S2DException ex) {
	    System.err.println("Warning: unable to get residue counts: " +
	      ex.getMessage());
	}

        S2DResCount resCount = new S2DResCount(_masterAccNum, _dataDir,
	  resSeqCodes, residueLabels);

	resCount.write(frameIndex);
    }

    //-------------------------------------------------------------------
    // Save chem shifts for one save frame.
    private void saveFrameChemShifts(S2DStarIfc star, SaveFrameNode frame,
      int frameIndex) throws S2DException
    {
        if (DEBUG >= 3) {
	    System.out.println("    S2DMain.saveFrameChemShifts(" +
	      star.getFrameName(frame) + ", " + frameIndex + ")");
	}

	//
	// Get the values we need from the Star file.
	//
	String[] resSeqCodesTmp = star.getFrameValues(frame,
	  S2DNames.CHEM_SHIFT_VALUE, S2DNames.RESIDUE_SEQ_CODE);
	int[] resSeqCodes = S2DUtils.arrayStr2Int(resSeqCodesTmp);
	resSeqCodesTmp = null;

	String[] residueLabels = star.getFrameValues(frame,
	  S2DNames.CHEM_SHIFT_VALUE, S2DNames.RESIDUE_LABEL);

	String[] atomNames = star.getFrameValues(frame,
	  S2DNames.CHEM_SHIFT_VALUE, S2DNames.ATOM_NAME);

	String[] atomTypes = star.getFrameValues(frame,
	  S2DNames.CHEM_SHIFT_VALUE, S2DNames.ATOM_TYPE);

	String[] chemShiftsTmp = star.getFrameValues(frame,
	  S2DNames.CHEM_SHIFT_VALUE, S2DNames.CHEM_SHIFT_VALUE);
        double[] chemShiftVals = S2DUtils.arrayStr2Double(chemShiftsTmp);
	chemShiftsTmp = null;

	//
	// Create an S2DChemShift object with the values we just got.
	//
        S2DChemShift chemShift = new S2DChemShift(_masterAccNum, _dataDir,
	  _sessionDir, _summary, resSeqCodes, residueLabels, atomNames,
	  atomTypes, chemShiftVals);


	//
	// Now go ahead and calculate and write out the chem shift values.
	//
	_summary.startFrame(star.getFrameDetails(frame));

	try {
	    chemShift.writeDeltashifts(frameIndex);
	} catch (S2DException ex) {
	    // Don't throw a new exception here because we want to write as
	    // much as we can, even if there's an error somewhere along the
	    // line.
	    System.err.println(ex.getMessage());
	}

	// We only want to output CSI values if this save frame
	// has HA chem shifts for at least 80% of the residues in
	// the entry.  (This can be tested with bmr4001.str and
	// bmr4011.str.)
	int residueCount = star.residueCount(frame);
	if (residueCount < 0 ||
	  ((float)star.getHAChemShiftCount(frame) /
	  (float)residueCount >= 0.8)) {
	    try {
	        chemShift.writeCSI(frameIndex);
	    } catch (S2DException ex) {
	        // Don't throw a new exception here because we want to write as
	        // much as we can, even if there's an error somewhere along the
	        // line.
	        System.err.println(ex.getMessage());
	    }
	} else {
	    if (DEBUG >= 1) {
	        System.out.println("CSI values not saved for " +
		  "save frame " + frame.getLabel() + " because HA " +
		    "chem shifts are not available for 80% of the residues");
            }
	}

	try {
	    chemShift.writePctAssign(frameIndex);
	} catch (S2DException ex) {
	    // Don't throw a new exception here because we want to write as
	    // much as we can, even if there's an error somewhere along the
	    // line.
	    System.err.println(ex.getMessage());
	}

	try {
	    chemShift.writeAllShifts(frameIndex);
	} catch (S2DException ex) {
	    // Don't throw a new exception here because we want to write as
	    // much as we can, even if there's an error somewhere along the
	    // line.
	    System.err.println(ex.getMessage());
	}

	try {
	    chemShift.writeHvsNShifts(frameIndex);
	} catch (S2DException ex) {
	    // Don't throw a new exception here because we want to write as
	    // much as we can, even if there's an error somewhere along the
	    // line.
	    System.err.println(ex.getMessage());
	}

	_summary.endFrame();
    }

    //-------------------------------------------------------------------
    // Save T1 relaxation values for one save frame.
    private void saveFrameT1Relax(S2DStarIfc star, SaveFrameNode frame,
      int frameIndex) throws S2DException
    {
        if (DEBUG >= 3) {
	    System.out.println("    S2DMain.saveFrameT1Relax(" +
	      star.getFrameName(frame) + ", " + frameIndex + ")");
	}

	//
	// Get the values we need from the Star file.
	//
	String[] resSeqCodes = star.getFrameValues(frame,
	  S2DNames.T1_VALUE, S2DNames.RESIDUE_SEQ_CODE);

	String[] resLabels = star.getFrameValues(frame,
	  S2DNames.T1_VALUE, S2DNames.RESIDUE_LABEL);

	String[] atomNames = star.getFrameValues(frame,
	  S2DNames.T1_VALUE, S2DNames.ATOM_NAME);

	String[] relaxValues = star.getFrameValues(frame,
	  S2DNames.T1_VALUE, S2DNames.T1_VALUE);

	//TEMP -- 4096 has "_T1_error" instead of "_T1_value_error".
	String[] relaxErrors = star.getOptionalFrameValues(frame,
	  S2DNames.T1_VALUE, S2DNames.T1_VALUE_ERR, relaxValues.length, "0");

	//
	// Create an S2DRelaxation object with the values we just got.
	//
	S2DRelaxation relaxation = new S2DRelaxation(_masterAccNum,
	  _dataDir, _sessionDir, _summary, S2DUtils.TYPE_T1_RELAX,
	  star.getOneFrameValue(frame, S2DNames.SPEC_FREQ_1H),
	  resSeqCodes, resLabels, atomNames, relaxValues, relaxErrors);

	//
	// Now go ahead and calculate and write out the relaxation values.
	//
	_summary.startFrame(star.getFrameDetails(frame));

	try {
	    relaxation.writeRelaxation(frameIndex);
	} finally {
	    _summary.endFrame();
	}
    }

    //-------------------------------------------------------------------
    // Save T2 relaxation values for one save frame.
    private void saveFrameT2Relax(S2DStarIfc star, SaveFrameNode frame,
      int frameIndex) throws S2DException
    {
        if (DEBUG >= 3) {
	    System.out.println("    S2DMain.saveFrameT2Relax(" +
	      star.getFrameName(frame) + ", " + frameIndex + ")");
	}

	//
	// Get the values we need from the Star file.
	//
	String[] resSeqCodes = star.getFrameValues(frame,
	  S2DNames.T2_VALUE, S2DNames.RESIDUE_SEQ_CODE);

	String[] resLabels = star.getFrameValues(frame,
	  S2DNames.T2_VALUE, S2DNames.RESIDUE_LABEL);

	String[] atomNames = star.getFrameValues(frame,
	  S2DNames.T2_VALUE, S2DNames.ATOM_NAME);

	String[] relaxValues = star.getFrameValues(frame,
	  S2DNames.T2_VALUE, S2DNames.T2_VALUE);

	//TEMP -- 4096 has "_T2_error" instead of "_T2_value_error".
	String[] relaxErrors = star.getOptionalFrameValues(frame,
	  S2DNames.T2_VALUE, S2DNames.T2_VALUE_ERR, relaxValues.length, "0");

	//
	// Create an S2DRelaxation object with the values we just got.
	//
	S2DRelaxation relaxation = new S2DRelaxation(_masterAccNum,
	  _dataDir, _sessionDir, _summary, S2DUtils.TYPE_T2_RELAX,
	  star.getOneFrameValue(frame, S2DNames.SPEC_FREQ_1H),
	  resSeqCodes, resLabels, atomNames, relaxValues, relaxErrors);

	//
	// Now go ahead and calculate and write out the relaxation values.
	//
	_summary.startFrame(star.getFrameDetails(frame));

	try {
	    relaxation.writeRelaxation(frameIndex);
	} finally {
	    _summary.endFrame();
	}
    }

    //-------------------------------------------------------------------
    // Save coupling constants for one save frame.
    private void saveFrameCoupling(S2DStarIfc star, SaveFrameNode frame,
      int frameIndex) throws S2DException
    {
        if (DEBUG >= 3) {
	    System.out.println("    S2DMain.saveFrameCoupling(" +
	      star.getFrameName(frame) + ", " + frameIndex + ")");
	}

	//
	// Get the values we need from the Star file.
	//
	String[] atom1ResSeqs = star.getFrameValues(frame,
	  S2DNames.COUPLING_CONSTANT_VALUE, S2DNames.ATOM_1_RES_SEQ_CODE);

	String[] atom2ResSeqs = star.getFrameValues(frame,
	  S2DNames.COUPLING_CONSTANT_VALUE, S2DNames.ATOM_2_RES_SEQ_CODE);

	String[] couplingConstValues = star.getFrameValues(frame,
	  S2DNames.COUPLING_CONSTANT_VALUE, S2DNames.COUPLING_CONSTANT_VALUE);

	String[] couplingConstCodes = star.getOptionalFrameValues(frame,
	  S2DNames.COUPLING_CONSTANT_VALUE, S2DNames.COUPLING_CONSTANT_CODE,
	  atom1ResSeqs.length, "0");

	String[] atom1ResLabels = star.getOptionalFrameValues(frame,
	  S2DNames.COUPLING_CONSTANT_VALUE, S2DNames.ATOM_1_RES_LABEL,
	  atom1ResSeqs.length, "0");

	String[] atom1Names = star.getOptionalFrameValues(frame,
	  S2DNames.COUPLING_CONSTANT_VALUE, S2DNames.ATOM_1_NAME,
	  atom1ResSeqs.length, "0");

	String[] atom2ResLabels = star.getOptionalFrameValues(frame,
	  S2DNames.COUPLING_CONSTANT_VALUE, S2DNames.ATOM_2_RES_LABEL,
	  atom1ResSeqs.length, "0");

	String[] atom2Names = star.getOptionalFrameValues(frame,
	  S2DNames.COUPLING_CONSTANT_VALUE, S2DNames.ATOM_2_NAME,
	  atom1ResSeqs.length, "0");

	String[] couplingConstErrors = star.getOptionalFrameValues(frame,
	  S2DNames.COUPLING_CONSTANT_VALUE,
	  S2DNames.COUPLING_CONSTANT_VALUE_ERR, atom1ResSeqs.length, "0");

	//
	// Create an S2DCoupling object with the values we just got.
	//
        S2DCoupling coupling = new S2DCoupling(_masterAccNum, _dataDir,
	  _sessionDir, _summary, couplingConstCodes, atom1ResSeqs,
	  atom1ResLabels, atom1Names, atom2ResSeqs, atom2ResLabels,
	  atom2Names, couplingConstValues, couplingConstErrors);

	//
	// Now go ahead and calculate and write out the coupling contants.
	//
	_summary.startFrame(star.getFrameDetails(frame));

	try {
	    coupling.writeCoupling(frameIndex);
	} finally {
	    _summary.endFrame();
	}
    }

    //-------------------------------------------------------------------
    // Save heteronuclear NOE values for one save frame.
    private void saveFrameHetNOE(S2DStarIfc star, SaveFrameNode frame,
      int frameIndex) throws S2DException
    {
        if (DEBUG >= 3) {
	    System.out.println("    S2DMain.saveFrameHetNOE(" +
	      star.getFrameName(frame) + ", " + frameIndex + ")");
	}

	//
	// Get the values we need from the Star file.
	//
	String[] resSeqCodes = star.getFrameValues(frame,
	  S2DNames.HET_NOE_VALUE, S2DNames.RESIDUE_SEQ_CODE);

	String[] resLabels = star.getFrameValues(frame,
	  S2DNames.HET_NOE_VALUE, S2DNames.RESIDUE_LABEL);

	String[] hetNOEValues = star.getFrameValues(frame,
	  S2DNames.HET_NOE_VALUE, S2DNames.HET_NOE_VALUE);

	String[] hetNOEErrors = star.getFrameValues(frame,
	  S2DNames.HET_NOE_VALUE, S2DNames.HET_NOE_VALUE_ERR);

	//
	// Create an S2DHetNOE object with the values we just got.
	//
	S2DHetNOE hetNOE = new S2DHetNOE(_masterAccNum, _dataDir,
	  _sessionDir, _summary,
	  star.getOneFrameValue(frame, S2DNames.SPEC_FREQ_1H),
	  star.getOneFrameValue(frame, S2DNames.ATOM_1_ATOM_NAME),
	  star.getOneFrameValue(frame, S2DNames.ATOM_2_ATOM_NAME),
	  resSeqCodes, resLabels, hetNOEValues, hetNOEErrors);

	//
	// Now go ahead and calculate and write out the heteronuclear NOE
	// values.
	//
	_summary.startFrame(star.getFrameDetails(frame));

	try {
	    hetNOE.writeHetNOE(frameIndex);
	} finally {
	    _summary.endFrame();
	}
    }

    //-------------------------------------------------------------------
    // Save atomic coordinates for one save frame.
    private void saveFrameAtomicCoords(S2DStarIfc star, SaveFrameNode frame,
      int frameIndex) throws S2DException
    {
        if (DEBUG >= 3) {
	    System.out.println("    S2DMain.saveFrameAtomicCoords(" +
	      star.getFrameName(frame) + ", " + frameIndex + ")");
	}

	//
	// Get the values we need from the Star file.
	//
	String[] resSeqCodes = star.getFrameValues(frame,
	  S2DNames.ATOM_COORD_X, S2DNames.RESIDUE_SEQ_CODE);

	String[] resLabels = star.getFrameValues(frame,
	  S2DNames.ATOM_COORD_X, S2DNames.RESIDUE_LABEL);

	String[] atomNames = star.getFrameValues(frame,
	  S2DNames.ATOM_COORD_X, S2DNames.ATOM_NAME);

	String[] atomTypes = star.getFrameValues(frame,
	  S2DNames.ATOM_COORD_X, S2DNames.ATOM_TYPE);

	String[] atomCoordXTmp = star.getFrameValues(frame,
	  S2DNames.ATOM_COORD_X, S2DNames.ATOM_COORD_X);
        double[] atomCoordX = S2DUtils.arrayStr2Double(atomCoordXTmp);
        atomCoordXTmp = null;

	String[] atomCoordYTmp = star.getFrameValues(frame,
	  S2DNames.ATOM_COORD_Y, S2DNames.ATOM_COORD_Y);
        double[] atomCoordY = S2DUtils.arrayStr2Double(atomCoordYTmp);
        atomCoordYTmp = null;

	String[] atomCoordZTmp = star.getFrameValues(frame,
	  S2DNames.ATOM_COORD_Z, S2DNames.ATOM_COORD_Z);
        double[] atomCoordZ = S2DUtils.arrayStr2Double(atomCoordZTmp);
        atomCoordZTmp = null;

	//
	// Create an S2DAtomicCoords object with the values we just got.
	//
	S2DAtomicCoords atomicCoords = new S2DAtomicCoords(_masterAccNum,
	  _dataDir, _sessionDir, _summary, resSeqCodes, resLabels,
	  atomNames, atomTypes, atomCoordX, atomCoordY, atomCoordZ,
	  _connectionFile);

	//
	// Now go ahead and calculate and write out the atmoic coordinates.
	//
	String details = star.getFrameDetails(frame);
	if (details == null) {
	    details = "Representative structure";
        }
	_summary.startFrame(details);

	try {
	    atomicCoords.writeBonds(frameIndex);
	} finally {
	    _summary.endFrame();
	}
    }

    //-------------------------------------------------------------------
    // Process a PDB entry (get the atomic coordinates).
    void processPDB(S2DStarIfc star, String pdbId) throws S2DException
    {
        if (DEBUG >= 1) {
	    System.out.println("processPDB(" + pdbId + ")");
	}

	//TEMP -- what do we do if there's some error processing the
	// mmCIF file?  we should still show the stuff from the NMR-Star
	// file

	S2DCifIfc cif = new S2DCifIfc(star.getParser(), pdbId);
    }
}

// ========================================================================
