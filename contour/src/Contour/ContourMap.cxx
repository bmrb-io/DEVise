/*
::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::
TITLE:   ContourMap.h
PURPOSE: Creates contour maps given a ContourScheme and a 2D matrix of
	 real data. 
DATE:    10/22/07
DESIGN:  Roger A. Chylla
         email: rchylla@adacgeo.com
::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::
*/



/*-------- INCLUDES --------*/

#include <stdlib.h>
#include <stream.h>
#include <malloc.h>
#include <memory.h>
#include "ContourMap.hxx"
#include "BinaryFile.h"
#include "BoundaryPointList.hxx"


/*Define an integer representing an index to a null item*/
#define NULL_INDEX -1

/*Macro that yields the sign associated with direction*/
#define SIGN(direction) ( ((direction % 2)==0) ? -1 : 1 )

/*Macro that yields an x type of key associated with pos */
#define X_TYPE(pos) (pos)

/*Macro that yields an x type of key associated with pos */
#define Y_TYPE(pos) (-pos)

/*Macro that indicates whether d is positive or negative along x dimension*/
#define XDIR(d) (d % 2)

/*Macro that indicates whether d is positive or negative along y dimension*/
#define YDIR(d) (d / 2)

/*Macro that indicates whether d is oriented along x dimension*/
#define ALONGX(d) ((d%2)==1) 

/*Macro that indicates whether d is oriented along y dimension*/
#define ALONGY(d) ((d%2)==0) 

/*Define directions of a contour search*/
#define POSX_POSY 3
#define NEGX_POSY 2
#define POSX_NEGY 1
#define NEGX_NEGY 0

#define SIGN_MAX(j,k) ((abs(j) > abs(k)) ? j : k)
#define ABS_MAX(j,k)  ((abs(j) > abs(k)) ? abs(j) : abs(k))
#define FABS(r) ((r < 0.0) ? -r : r)


/*-------- END INCLUDES --------*/

/*STATIC FUNCTIONS*/

/* Returns the interpolated value of the point in pfMatrix 
   corresponding to dPX,dPY */
static double dInterpolateValue(
	Real* pfMatrix, /*2D Matrix of points to interpolate from*/
	int iDataX,	/*Resolution of x dimension*/
	int iDataY,	/*Resolution of y dimension*/
	double dPX,	/*X value of interpolated point */
	double dPY)	/*Y value of interpolated point */
{
	int iX = (int)( dPX + 0.4999 );
	int iY = (int)( dPY + 0.4999 );

	int iXIncr = ( dPX < iX ) ? -1 :
		(dPX == iX) ? 0 : 1;

	int iYIncr = ( dPY < iY ) ? -1 :
		(dPY == iY) ? 0 : 1;

	int iPos = iY*iDataX + iX;
	double dx,dy,dz,dValue,dInterpValue;

	dValue = dInterpValue = pfMatrix[iPos];

	if ( iXIncr != 0 )
	{
		dz = dValue - pfMatrix[iPos + iXIncr];
		dx = dPX - (double)iX;
		dInterpValue += dz*dx; 
	}

	if ( iYIncr != 0 )
	{
		dz = dValue - pfMatrix[iPos + iYIncr*iDataX];
		dy = dPY - (double)iY;
		dInterpValue += dz*dy; 
	}

	return dInterpValue;
}

/* Returns the nearest neighbor value of the point in pfMatrix 
   corresponding to dPX,dPY */
static Real fNearestNeighbor(
	Real* pfMatrix, /*2D Matrix of points to interpolate from*/
	int iDataX,	/*Resolution of x dimension*/
	int iDataY,	/*Resolution of y dimension*/
	double dPX,	/*X value of point */
	double dPY)	/*Y value of point */
{
	int iX = (int)( dPX + 0.4999 );
	int iY = (int)( dPY + 0.4999 );

	int iPos = iY*iDataX + iX;
	return pfMatrix[iPos];
}

/* Allocates an array of BoundaryPointList based on the number of
   contour levels in rContourScheme */
static BoundaryPointList** pptAllocBoundaryPointList(
	ContourScheme& rContourScheme)
{
	int iNLevels = rContourScheme.iGetNLevels();
	int iNLists = 2*iNLevels + 1;

	BoundaryPointList** pptList = (BoundaryPointList**)
		malloc( iNLists*sizeof(BoundaryPointList*) );

	pptList += iNLevels;

	Boolean bIsNegative = rContourScheme.bDoesPlotNegative();
	for(int i= -iNLevels; i<=iNLevels; i++)
		pptList[i] = (i == 0) ? 0 : 
			(i > 0 ) ? new BoundaryPointList(32) :
				(bIsNegative) ? new BoundaryPointList(32) : 0;

	return pptList;
}

/*Deallocates array of BoundaryPointLists created from rContourScheme*/
static void vDeallocBoundaryPointList(
	BoundaryPointList** pptList,
	ContourScheme& rContourScheme)
{
	int iNLevels = rContourScheme.iGetNLevels();

	for(int i= -iNLevels; i<iNLevels; i++)
		if ( pptList[i] != 0 )
			free( pptList[i] );

	pptList -= iNLevels;
	free(pptList);
}


/* Fills arrays of BoundaryPointList with a list of contour 
   points generated by the matrix correspoding to the  projection of pfMatrix 
   (iDataX X iDataY) unto a matrix of (iMapX X iMapY). 
   pfMatrix: 2D matrix of data points
   pptList: Array of boundary lists to hold contours.  Each boundary list
	    represents a different contour level
   rContourScheme: contour scheme which, applied to pfMatrix, generates the
		   contours
   iDataX :  Resolution of data set along X dimension
   iDataY :  Resolution of data set along Y dimension
   iMapX  :  Resolution of contour map along X dimension
   iMapY  :  Resolution of contour map along Y dimension
*/
static void vGetBoundaryPoints(
	Real* pfMatrix,	
	BoundaryPointList** pptList,
	ContourScheme& rContourScheme,
	int iDataX,int iDataY,
	int iMapX,int iMapY)
{
	/*Calculate number of points in contour map*/
	int iNPoints = iMapX*iMapY;
	int iCol,iRow,iPos;

	/*Are the map dimensions different than the data dimensions? */
	Boolean bIsTransformed = ( (iMapX != iDataX) || (iMapY != iDataY) );

	/*The default transformed matrix is identical to the data matrix*/
	Real* pfTranMatrix = pfMatrix;

	/*If map and data dimensions are not the same, then create
  	  a new matrix and fill it with interpolated values */
	if ( bIsTransformed )
	{
		/*Allocate new transform matrix with dimensions of contour map*/
		pfTranMatrix = (Real*)malloc( iNPoints*sizeof(Real) );
	
		double dPX,dPY,fValue;
		/*Get conversion factors for map to data linear transformation*/
		double dXRatio = (double)(iDataX-1)/(double)(iMapX-1);
		double dYRatio = (double)(iDataY-1)/(double)(iMapY-1);

		for(iRow=iPos=0; iRow<iMapY; iRow++)
		{
		   for(iCol=0; iCol<iMapX; iCol++,iPos++)
		   {
			/*Convert map coordinates to data coordinates*/
			dPX = (double)iCol*dXRatio;
			dPY = (double)iRow*dYRatio;
	
			/*Call static function to get interpolated value of 
			  data at dPX,dPY */
			fValue = fNearestNeighbor(pfMatrix,iDataX,iDataY,
				dPX,dPY);
			pfTranMatrix[iPos] = fValue;
		   }
		}
	}

	/*Allocate short array to hold contour levels that correspond to
	  the values in pfTranMatrix */
	short* psiContours = (short*)malloc( iNPoints*sizeof(short) );

	/*Fill psiContours with the contour levels that correspond to the
	  interpolated values in pfTranMatrix*/
	for(iPos=0; iPos<iNPoints; iPos++)
		psiContours[iPos] = 
			rContourScheme.iGetContourLevel(pfTranMatrix[iPos]);

	/*Get array of real values that represent the contour levels*/
	Real *pfContours = rContourScheme.pfGetContourValues();

	Real f1,f2,fUnit,fFrac,fContour;
	int iPos1,iPos2;
	int iLevel1,iLevel2,iNextLevel,iIncr;
	BoundaryPoint tPoint;
	BoundaryPointList *ptBoundaryList;

	/*Find contour points along x dimension...*/
	for(iRow=0; iRow<iMapY; iRow++)
	{
		for(iCol=1; iCol<iMapX; iCol++)
		{
			iPos2 = iCol + iRow*iMapX;
			iPos1 = iPos2 - 1;
			iLevel1 = psiContours[iPos1];
			iLevel2 = psiContours[iPos2];
			if ( iLevel1 != iLevel2 )
			{
				f1 = pfTranMatrix[iPos1];
				f2 = pfTranMatrix[iPos2];

				iIncr = (iLevel1 < iLevel2) ? 1 : -1;
				fUnit = 1.0/(f2-f1);

				int k;
				for(int j=k=iLevel1; j!=iLevel2; j=k)
				{
					k = j + iIncr;
					iNextLevel = ABS_MAX(j,k);
					tPoint.fY = iRow;
					tPoint.iPos = iPos2;
					tPoint.siIntensity = SIGN_MAX(j,k);
					fContour = pfContours[iNextLevel-1];
					ptBoundaryList = pptList[iNextLevel];
					fFrac = fUnit*(fContour-f1);
					tPoint.fX = (iCol-1) + fFrac;
					tPoint.siDirection = 
						(iIncr == 1) ? 1 : 3;
					ptBoundaryList->vAppendItem(tPoint);
				} 
			}
		}
	}

	/*Find contour points along y dimension...*/
	for(iCol=0; iCol<iMapX; iCol++)
	{
		for(iRow=1; iRow<iMapY; iRow++)
		{
			iPos2 = iCol + iRow*iMapX;
			iPos1 = iPos2 - iMapX;
			iLevel1 = psiContours[iPos1];
			iLevel2 = psiContours[iPos2];

			if ( iLevel1 != iLevel2 )
			{
				f1 = pfTranMatrix[iPos1];
				f2 = pfTranMatrix[iPos2];

				iIncr = (iLevel1 < iLevel2) ? 1 : -1;
				fUnit = 1.0/(f2-f1);

				int k;
				for(int j=k=iLevel1; j!=iLevel2; j=k)
				{
					k = j + iIncr;
					iNextLevel = ABS_MAX(j,k);
					tPoint.fX = iCol;
					tPoint.iPos = iPos2;
					tPoint.siIntensity = SIGN_MAX(j,k);
					fContour = pfContours[iNextLevel-1];
					ptBoundaryList = pptList[iNextLevel];
					fFrac = fUnit*(fContour-f1);
					tPoint.fY = (iRow-1) + fFrac;
					tPoint.siDirection = 
						(iIncr == 1) ? 0 : 2;
					ptBoundaryList->vAppendItem(tPoint);
				} 
			}
		}
	}

	free(psiContours);
	free(pfContours);

	/*If transformed matrix is different than data matrix, free memory
	  allocated to the transformed matrix */
	if ( pfTranMatrix != pfMatrix )
		free(pfTranMatrix);
}


/*Returns the key corresponding to the next point along the contour
  piIndexes = Indexes to positions of contour points
  rtBoundaryPoint = Current contour point
  iDirection = current direction
	0 = -x,-y 
	1 = +x,-y
	2 = -x,+y
	3 = +x,+y 
  iStrideY = Distance between adjacent points along y dimension
  iMaxKey = Maximum absolute value of key 
*/
static int iGetNextBoundaryPoint(
	int* piIndexes,
	BoundaryPoint& rtBoundaryPoint,
	int& riDirection,
	int iStrideY,
	int iMaxKey)
{
	int iKey;
	int iIndex = NULL_INDEX;
	int iPos = rtBoundaryPoint.iPos;
	int iPointDirection = rtBoundaryPoint.siDirection;

	int iaKey[3],iaDirection[3];
	int p1,p2;

	/*If along y dimension ... */
	if ( ALONGY(iPointDirection) )
	{
		/*If x direction is positive ...*/
		if ( XDIR(riDirection) )
		{
			p1 = iPos + 1;
			p2 = p1 - iStrideY;
			iaKey[0] = Y_TYPE(p1); iaDirection[0] = riDirection; 
			iaKey[1] = X_TYPE(p1); iaDirection[1] = POSX_POSY; 
			iaKey[2] = X_TYPE(p2); iaDirection[2] = POSX_NEGY; 
		}
		/*else x direction is negative...*/
		else
		{
			p1 = iPos - iStrideY;
			p2 = iPos - 1;
			iaKey[0] = Y_TYPE(p2);  iaDirection[0] = riDirection; 
			iaKey[1] = X_TYPE(iPos);iaDirection[1] = NEGX_POSY;
			iaKey[2] = X_TYPE(p1);  iaDirection[2] = NEGX_NEGY;
		}
	}
	/*else along x dimension ... */
	else
	{
		/*If y direction is positive ...*/
		if ( YDIR(riDirection) )
		{
			p1 = iPos + iStrideY;
			p2 = p1 - 1; 
			iaKey[0] = X_TYPE(p1); iaDirection[0] = riDirection; 
			iaKey[1] = Y_TYPE(p1); iaDirection[1] = POSX_POSY; 
			iaKey[2] = Y_TYPE(p2); iaDirection[2] = NEGX_POSY; 
		}
		else
		/*else y direction is negative ...*/
		{
			p1 = iPos - 1;
			p2 = iPos - iStrideY; 
			iaKey[0] = X_TYPE(p2);   iaDirection[0] = riDirection; 
			iaKey[1] = Y_TYPE(iPos); iaDirection[1]= POSX_NEGY; 
			iaKey[2] = Y_TYPE(p1);   iaDirection[2] = NEGX_NEGY; 
		}
	}

	for(int j=0; j<3; j++)
	{
		iKey = iaKey[j];
		iIndex = (abs(iKey) < iMaxKey) ? piIndexes[iKey] : NULL_INDEX;
		if (iIndex != NULL_INDEX)
		{
			riDirection = iaDirection[j];
			piIndexes[iKey] = NULL_INDEX;
			break;
		}
	}

	return iIndex;
}


/*Trace the set of contours in the direction of iDirection starting
  at the boundary point tBPoint */
static void vTraceContourDirection(
	BoundaryPointList *ptBoundaryList,
	Drawable2D& rDrawable,
	int* piIndexes,
	BoundaryPoint& rtBPoint,
	int iDirection,
	int iStrideX,
	int iMaxKey)
{
	BoundaryPoint tbp = rtBPoint;

	Real fX = tbp.fX;
	Real fY = tbp.fY;
	Real xdiff,ydiff;

	rDrawable.vSetCursor(fX,fY);

	short siColor = tbp.siIntensity;
	rDrawable.vSetPenColor(siColor);

	int iIndex = piIndexes[tbp.iPos];
	while ( iIndex != NULL_INDEX )
	{
		iIndex = iGetNextBoundaryPoint(piIndexes,tbp,
			iDirection,iStrideX,iMaxKey);
		if ( iIndex != NULL_INDEX )
		{
			tbp = ptBoundaryList->tGetItem(iIndex);
			xdiff = fX - tbp.fX;
			ydiff = fY - tbp.fY;
			fX = tbp.fX;
			fY = tbp.fY;
			if ( (xdiff*xdiff > 4.0) || (ydiff*ydiff > 4.0) )
				rDrawable.vSetCursor(fX,fY);
			else
				rDrawable.vDrawTo(fX,fY);
		}
	}
}

/*Trace the set of contours associated with the input boundary
  point list.  The resolution of the contour map is given
  by iMapX*iMapY.  rDrawable is a reference to the canvas
  where the contour lines are drawn. */ 
static void vTraceContours(BoundaryPointList* ptBoundaryList,
	Drawable2D& rDrawable,
	int iMapX,
	int iMapY)
{
	int iNPoints = iMapX*iMapY;

	/*Indexes for the boundary points in ptBoundaryList*/
	int iIndexSize = 2*iNPoints + 1;
	int* piIndexes = (int*)malloc(iIndexSize*sizeof(int));
	piIndexes += iNPoints;

	// Changed declaration of i here for new ASCI C++ scoping rules
	// (g++ 2.7.2 complained).  RKW Dec. 22, 1997.
	int i;
	for(i= -iNPoints; i<iNPoints; i++)
		piIndexes[i] = NULL_INDEX;

	BoundaryPoint tBPoint;

	/*Load indexes with position of boundary points*/
	int iPos,iKey;
	int iNItems = ptBoundaryList->iGetNItems();
	for(i=0; i<iNItems; i++)
	{
		tBPoint = ptBoundaryList->tGetItem(i);
		iPos = tBPoint.iPos;
		iKey = iPos*SIGN(tBPoint.siDirection);
		piIndexes[iKey] = i;
	}

	/*Loop through all unused boundary points in list*/
	for(i=0; i<iNItems; i++)
	{
		tBPoint = ptBoundaryList->tGetItem(i);
		iPos = tBPoint.iPos;
		iKey = iPos*SIGN(tBPoint.siDirection);
		if ( piIndexes[iKey] != NULL_INDEX )
		{
			vTraceContourDirection(ptBoundaryList,rDrawable,
				piIndexes,tBPoint,POSX_POSY,iMapX,iNPoints);
			vTraceContourDirection(ptBoundaryList,rDrawable,
				piIndexes,tBPoint,NEGX_NEGY,iMapX,iNPoints);
			piIndexes[iKey] = NULL_INDEX;
		}
	} 

	piIndexes -= iNPoints;
	free(piIndexes);
}


/*METHODS*/
/*Stream constructor
  Attributes are read from the input stream in the following order:
  1) The 2D x,y real matrix resolution
  	FORMAT: iDataX <DELIM> iDataY <RET> 
  2) The filenm of the binary file of N float values
	where N = iDataX*iDataY
  3) The x,y resolution of the contour map
	FORMAT: iMapX <DELIM> iMapY <RET>
  4) The contour scheme
	FORMAT: fMinLevel <DELIM>
		iNLevels  <DELIM>
		fContourMult <DELIM>
		bPosNegative <RET>
	where fMinLevel is the absolute value of the minimum
	contour level, iNLevels is the number of contour levels,
	fContourMult is the geometric spacing between consecutive
	contour levels (e.g. 2.0), and bPosNegative is a boolean
	value 0/1  that indicates whether or not negative contours
	are to be displayed. 
  The above formats are not as strict as documented. Almost any
  white space character (' ','\t','\n') should be able to replace 
  either <DELIM> or <RET> 
*/
ContourMap::ContourMap( istream& rIStream )
{
	ptContourScheme = 0;
	pfMatrix = 0;

	rIStream >> *this;
}

/*Sets the current x,y resolutions of the contour map*/
void ContourMap::vSetMapResolution(int iNewMapX,int iNewMapY)
{
	iMapX = iNewMapX;
	iMapY = iNewMapY;
}

/*Sets pointer to new data set.  iNewDataX and iNewDataY are the
  resolutions of the new data set */
void ContourMap::vSetMatrixData(float *pfNewMatrix,
	int iNewDataX,
	int iNewDataY)
{
	if ( pfMatrix != 0 )
		free(pfMatrix);

	pfMatrix = pfNewMatrix;
	iDataX = iNewDataX;
	iDataY = iNewDataY;
}


/*Sends all info associated with this instance through the ostream.
  The data is sent in the following way:
  1) The 2D x,y real matrix resolution
  	FORMAT: iDataX <DELIM> iDataY <RET> 
  2) The filenm of the binary file of N float values
	where N = iDataX*iDataY
  3) The x,y resolution of the contour map
	FORMAT: iMapX <DELIM> iMapY <RET>
  4) The contour scheme
	FORMAT: fMinLevel <DELIM>
		iNLevels  <DELIM>
		fContourMult <DELIM>
		bPosNegative <RET>
      where <DELIM> is a '\t' and <RET> is a '\n'
*/
ostream& operator<<(ostream& rOStream,
	ContourMap& rContourMap)
{
	int iNPoints = rContourMap.iDataX*rContourMap.iDataY;

	rOStream << rContourMap.iDataX << '\t' << rContourMap.iDataY << endl;
	rOStream << rContourMap.pcFilenm << endl;
	vWriteBinaryFile(rContourMap.pcFilenm,
		(void*)rContourMap.pfMatrix,
		iNPoints*sizeof(float));

	rOStream << rContourMap.iMapX << '\t' << rContourMap.iMapY << endl;

	if ( rContourMap.ptContourScheme != 0 )
		rOStream << *(rContourMap.ptContourScheme);

	return rOStream;
}

/*Retrieves all info associated with this instance from an istream.
  The data is retrieved in the same manner as documented in the
  istream constructor*/
istream& operator>>(istream& rIStream,
	ContourMap& rContourMap)
{
	rIStream >> rContourMap.iDataX >> rContourMap.iDataY;
	int iNPoints = rContourMap.iDataX*rContourMap.iDataY;

	char pcFilenm[80];
	rIStream >> pcFilenm;
	rContourMap.pcFilenm = (char*)malloc( strlen(pcFilenm) );
	strcpy(rContourMap.pcFilenm,pcFilenm);

	rContourMap.pfMatrix = 
		(float*)pvReadBinaryFile(pcFilenm,iNPoints*sizeof(float));

	rIStream >> rContourMap.iMapX >> rContourMap.iMapY;
	rContourMap.ptContourScheme = new ContourScheme(rIStream);

	return rIStream;
}


void ContourMap::vDrawIntensityMap(Drawable2D& rDrawable)
{
	/*Set image size of drawable canvas*/
	rDrawable.vSetImageSize(iMapX,iMapY);

	/*Get conversion factors for map to data linear transformation*/
	double dXRatio = (double)(iDataX-1)/(double)(iMapX-1);
	double dYRatio = (double)(iDataY-1)/(double)(iMapY-1);

	double dPX,dPY;
	Real fValue;
	int iCol,iRow,iPos;

	/*
	  -----------------------------------------------------------------
		Store in map the interpolated intensity level corresponding to each 
	        point
	*/
	short siColor;

	for(iRow=iPos=0; iRow<iMapY; iRow++)
	{
	   for(iCol=0; iCol<iMapX; iCol++,iPos++)
	   {
		/*Convert map coordinates to data coordinates*/
		dPX = (double)iCol*dXRatio;
		dPY = (double)iRow*dYRatio;

		/*Call static function to get interpolated value of data at 
		  dPX,dPY */
		fValue = dInterpolateValue(pfMatrix,iDataX,iDataY,dPX,dPY);

		/*Store in map the intensity level corresponding to 
		  fValue */
		siColor = ptContourScheme->iGetContourLevel(fValue);
		rDrawable.vSetPenColor(siColor);
		rDrawable.vSetCursor( (Real)iCol, (Real)iRow );
		rDrawable.vDrawPoint();
	   }
	}
	/* --------------------------------------------------------*/
}


void ContourMap::vDrawContourMap(Drawable2D& rDrawable)
{
	/*Set image size of drawable canvas*/
	rDrawable.vSetImageSize(iMapX,iMapY);

	/*Set size of coordinate system */
	int iContourX = (iDataX < iMapX) ? iDataX : iMapX;
	int iContourY = (iDataY < iMapY) ? iDataY : iMapY;
	rDrawable.vSetCoordSize( (Real)iContourX, (Real)iContourY );

	BoundaryPointList** pptBoundaryPointList = 
		pptAllocBoundaryPointList(*ptContourScheme);

	vGetBoundaryPoints(pfMatrix,pptBoundaryPointList,*ptContourScheme,
		iDataX,iDataY,iContourX,iContourY);

	BoundaryPointList *ptList;
	int iNContours = ptContourScheme->iGetNLevels();
	for(int i=1; i<=iNContours; i++)
	{
		ptList = pptBoundaryPointList[-i];
		if ( ptList != NULL )
			vTraceContours(ptList,rDrawable,iContourX,iContourY);
		ptList = pptBoundaryPointList[i];
		if ( ptList != NULL )
			vTraceContours(ptList,rDrawable,iContourX,iContourY);
	}

	vDeallocBoundaryPointList( pptBoundaryPointList , *ptContourScheme );
}

/*Destructor*/
ContourMap::~ContourMap()
{
	if ( ptContourScheme != 0 )
		delete ptContourScheme;
	if ( pfMatrix != 0 )
		delete pfMatrix;
	if ( pcFilenm != 0 )
		free (pcFilenm);
}
