/*
  ========================================================================
  DEVise Data Visualization Software
  (c) Copyright 1992-2000
  By the DEVise Development Group
  Madison, Wisconsin
  All Rights Reserved.
  ========================================================================

  Under no circumstances is this software to be copied, distributed,
  or altered in any way without prior permission from the DEVise
  Development Group.
*/

/*
  Implementation of Client (and CompDate) classes.
 */

/*
  $Id$

  $Log$
  Revision 1.6  2000/03/14 17:04:50  wenger
  Fixed bug 569 (group/ungroup causes crash); added more memory checking,
  including new FreeString() function.

  Revision 1.5  1998/08/21 22:16:11  wenger
  Got DEVise 1.5.4 to compile on SPARC/SunOS (sundance) -- to make statically-
  linked DEVise for distribution.

  Revision 1.4  1998/06/24 15:49:14  beyer
  changed include for egcs 2.90.27

  Revision 1.3  1998/03/11 18:25:19  wenger
  Got DEVise 1.5.2 to compile and link on Linux; includes drastically
  reducing include dependencies between csgroup code and the rest of
  the code, and within the csgroup code.  (Note: running collaboration
  doesn't work yet.)

  Revision 1.2  1998/02/12 17:15:08  wenger
  Merged through collab_br_2; updated version number to 1.5.1.

  Revision 1.1.2.2  1998/02/02 08:24:10  liping
  Added CVS header

*/

/* 
** Copyright 1997 Collaborator Design Team
** 
** Permission to use, copy, modify, and distribute this software and its
** documentation for any purpose and without fee is hereby granted,
** provided that the above copyright notice appear in all copies and that
** both that copyright notice and this permission notice appear in
** supporting documentation, and that the names of the University of
** Wisconsin and the Collaborator Design Team not be used in advertising or
** publicity pertaining to distribution of the software without specific,
** written prior permission.  The University of Wisconsin and the Collaborator
** Design Team make no representations about the suitability of this
** software for any purpose.  It is provided "as is" without express
** or implied warranty.
** 
** THE UNIVERSITY OF WISCONSIN AND THE COLLABORATOR DESIGN TEAM DISCLAIM ALL
** WARRANTIES WITH REGARD TO THIS SOFTWARE, INCLUDING ALL IMPLIED WARRANTIES
** OF MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE UNIVERSITY OF
** WISCONSIN OR THE COLLABORATOR DESIGN TEAM BE LIABLE FOR ANY SPECIAL, 
** INDIRECT OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING 
** FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, 
** NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION 
** WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
** 
** Author:  Ashish Thusoo
** 	         University of Wisconsin, Computer Sciences Dept.
** 
*/ 
/*
 * Please do not edit this file.
 * It was generated using rpcgen.
 */

#include "server.h"
#include "codec.h"
#include "sndMsg.h"
#include "ctrlMsg.h"
#include <stdio.h>
#include <stdlib.h> /* getenv, exit */
#include <string.h> /* strcmp */
#include <signal.h>
#include <sys/stat.h>
#include <fcntl.h>
#include <unistd.h> /* setsid */
#include <sys/types.h>
#include <memory.h>
#if defined(SUN)
#   include <sys/time.h>
#   include "machdep.h"
#endif
#include <sys/resource.h> /* rlimit */
#include <syslog.h>
#include <strings.h>

#ifndef SIG_PF
#define	SIG_PF void(*)(int)
#endif

#ifdef DEBUG
#define	RPC_SVC_FG
#endif

#include "colbr.h"
#include "Util.h"

/* States a server can be in wrt request */

static int _rpcsvccount = 0;		/* Number of requests serviced */

extern
void _msgout(char* msg);

int
server_prog_1(int fd)
{
	int cInfoLength;
	ConnectInfo cInfoArg;
	DbEntry entry;
	int intArg;
	int strLength;
	GroupKey strArg;
	Msg msgArg;
	int result;
	int ret = 0;
	int type;
	char* grouplist = NULL;

	_rpcsvccount++;
	if (XferMsgType(fd, MSG_DECODE, &type) <= 0) {
		return -1;
	}
	switch (type) {
		case RPC_REGISTER:
			if (XferMsg(fd, MSG_DECODE, 3,
				TYP_STRING, &strLength, &strArg,
				TYP_STRING, &cInfoLength, &cInfoArg,
				TYP_INTEGER, &intArg) <= 0) {
				ret = -1;
				break;
			}

			result = register_1_svc(fd, &strArg, cInfoArg, intArg);
			if (XferRpcReturn(fd, result) <= 0) {
				ret = -1;
			}
			break;

		case RPC_DEREGISTER:
			if (XferMsg(fd, MSG_DECODE, 3,
				TYP_STRING, &strLength, &strArg,
				TYP_STRING, &cInfoLength, &cInfoArg,
				TYP_INTEGER, &intArg) <= 0) {
				ret = -1;
				break;
			}

			result = deregister_1_svc(fd, &strArg, cInfoArg, intArg);
			if (XferRpcReturn(fd, result) <= 0) {
				ret = -1;
			}
			if (!result) {
				CloseConnection(fd);
			}
			break;

		case RPC_GROUPSEND:
			msgArg.msg = (char *) malloc(256);
			bzero(msgArg.msg, 256);
			if (XferMsg(fd, MSG_DECODE, 3,
				TYP_STRING, &strLength, &strArg,
				TYP_STRING, &cInfoLength, &cInfoArg,
				TYP_STRING, &(msgArg.size), 
					    msgArg.msg) <= 0) {
				ret = -1;
				break;
			}

			result = groupsend_1_svc(&strArg, cInfoArg, msgArg);
			free(msgArg.msg);
			if (XferRpcReturn(fd, result) <= 0) {
				ret = -1;
			}
			break;

		case RPC_QUERYGROUP:
			if (XferMsg(fd, MSG_DECODE, 2,
				TYP_STRING, &strLength, &strArg,
				TYP_STRING, &cInfoLength, &cInfoArg) <=0) {
					ret = -1;
					break;
			}
			result = querygroup_1_svc(&strArg, cInfoArg, grouplist);
			if (XferRpcReturn(fd, result) <= 0) {
				ret = -1;
			}
			else
			if (result >0)
			{
				XferMsg(fd, MSG_CODE, 1, TYP_STRING, &result, grouplist);
			}
			delete grouplist;	
			break;

				
		case RPC_LEADERSHIP:
			if (XferMsg(fd, MSG_DECODE, 3,
				TYP_STRING, &strLength, &strArg,
				TYP_STRING, &cInfoLength, &cInfoArg,
				TYP_INTEGER, &intArg) <= 0) {
				ret = -1;
				break;
			}

			result = leadership_1_svc(&strArg, cInfoArg, intArg);
			if (XferRpcReturn(fd, result) <= 0) {
				ret = -1;
			}
			setnewleader_1_svc(&strArg);
			break;

		case RPC_GETCKPT:
			if (XferMsg(fd, MSG_DECODE, 2,
				TYP_STRING, &strLength, &strArg,
				TYP_STRING, &cInfoLength, &cInfoArg) <= 0 ) {
				ret = -1;
				break;
			}

			result = getckpt_1_svc(&strArg, cInfoArg);
			if (XferRpcReturn(fd, result) <= 0) {
				ret = -1;
			}
			entry.FileDesc = fd;
			SendCtrlMsg(&entry, CTRL_EXECCKPT);
			break;

		case RPC_EXECCKPT:
			if (XferMsg(fd, MSG_DECODE, 2,
				TYP_STRING, &strLength, &strArg,
				TYP_STRING, &cInfoLength, &cInfoArg) <= 0 ) {
				ret = -1;
				break;
			}

			result = execckpt_1_svc(&strArg, cInfoArg);
			if (XferRpcReturn(fd, result) <= 0) {
				ret = -1;
			}
			break;

		default:
			ret = -1;
	}

	return ret;
}
