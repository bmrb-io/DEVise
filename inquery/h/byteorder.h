/**************************************************************************
*                         Copyright (c) 1996                              *
* by Sovereign Hill Software, Inc., Amherst, Massachusetts, U.S.A.        *
*        (413-256-6916;   http://www.sovereign-hill.com)                  *
*                          All Rights Reserved.                           *
*                                                                         *
* The SOFTWARE was developed in part at the Center for Intelligent        *
* Information Retrieval (CIIR) at the University of Massachusetts at      *
* Amherst (For more information, contact 413-545-0463 or                  *
* http://ciir.cs.umass.edu).  The SOFTWARE was acquired by Sovereign      *
* Hill Software Inc. and is the property of Sovereign Hill Software.      *
* ACSIOM is authorized, under an agreement with Sovereign Hill Software,  *
* to license the SOFTWARE for non-commercial, non-revenue-producing       *
* prototyping and internal evaluation purposes only.                      *
*                                                                         *
* This SOFTWARE was developed in significant part with private funding.   *
* The INQUERY SOFTWARE is proprietary to Sovereign Hill Software and may  *
* not be distributed in whole or in part or used in any way without       *
* authorized permission in writing from Sovereign Hill Software.          *
* Possession, use, duplication or dissemination of the INQUERY SOFTWARE   *
* and media is authorized only pursuant to a valid written license from   *
* ACSIOM or Sovereign Hill Software, Inc.                                 *
*                                                                         *
* RESTRICTED RIGHTS LEGEND:  Use, duplication, or disclosure by the U.S.  *
* Government is subject to restrictions as set forth in subparagraph      *
* (c)(l)(ii) of the Rights in Technical Data and Computer Software clause *
* at DFARS 252.227-7013, or in FAR 52.227-19, as applicable.              *
**************************************************************************/ 


/*
 * "BYTEORDER_H" is a header file for 
 * Type definitions, macros and literals implementing the byte order
 *protocols used by INQUERY.  (See also byteorder.c.)
 */

#if !defined(BYTEORDER_H)
#define BYTEORDER_H

#include "doctypes.h"


/* This has to be commented out because the MS Compilier chokes on it. */

static char byteorder_h_rcsid[]="$RCSfile$, $Revision$, $Date$";


/*
 *  Literals:
 */



/*
The preprocessor statements below determine the endian of the host.  
The INQUERY protocol is:
    1.  The endian of the host is determined from its architecture.
    2.  The host architecture is determined prior to compile time.

The specific mechanism is:
    1. In project-vars, the environment variable INQ_ARCH is set to
       the output of machine-type.
    2. In gmake.rules, the preprocessor symbol INQ_ARCH_xxx is defined
       on the compiler command line.
    3. This file then uses INQ_ARCH_xxx to determine MACHINE_ENDIAN.

When adding a new architecture, please follow the convention that the
symbol used in the test below should be INQ_ARCH followed by the
symbol generated by the machine-type script (that is, either the
"machine" command or the "arch" command on the host system, or its
equivalent).  If the new system does not have machine-type, it must be
created.  This convention will break in a well-behaved way: If someone
tries to compile INQUERY on a non-conforming system, compiling
byteorder.h will produce an error message that should be sufficient to
fix the problem.

Symbols for x86 and M68k should be added to this protocol.
*/

#if   defined(INQ_ARCH_sun4) || \
      defined(INQ_ARCH_solaris) || \
      defined(INQ_ARCH_rs6000) || \
      defined(INQ_ARCH_ksr1) || \
      defined(INQ_ARCH_sgi) || \
      defined(__MWERKS__)	/* Mac doesn't use gmake, so can't honor the convention */
#define MACHINE_ENDIAN ('B')
#elif defined(INQ_ARCH_mips)  || \
      defined(INQ_ARCH_alpha) || \
      defined(INQ_ARCH_dgux) || \
      defined(_WATCOM)		/* PC doesn't use gmake, so can't honor the convention */
#define MACHINE_ENDIAN ('L')
#endif


#if (! defined(MACHINE_ENDIAN))
#error "This machine must be declared to be either BIG_ENDIAN or LITTLE_ENDIAN"
#endif

/*  By convention, all INQUERY files are written in big-endian format, so
processes running on little-endian machines must perform byte swapping
where necessary.  The following definition, therefore, should not be
changed.  It has been determined that the overhead of byte swapping is
a very small fraction of the time it takes to do I/O.
*/

#define FILE_ENDIAN ('B')            /* don't change this */


/*
 *  Macros:
 */

    /*
     *  This macro reverses the bytes of a 2-byte object.  It uses two
     *  variables, a pointer bSwap_p and a character bSwap_c.  This macro
     *  is implemented like a call-by-reference function; although you do
     *  not pass the address of the 2-byte object, it must be available.
     *  This macro does not return a useful value, and it *does* change
     *  its argument.
     */
#define byteswap2(x) (\
    bSwap_p = (char *)&x, \
    bSwap_c = bSwap_p[0], bSwap_p[0] = bSwap_p[1], bSwap_p[1] = bSwap_c)

    /*
     *  This macro reverses the bytes of a 4-byte object.  It uses two
     *  variables, a pointer bSwap_p and a character bSwap_c.  This macro
     *  is implemented like a call-by-reference function; although you do
     *  not pass the address of the 4-byte object, it must be available.
     *  This macro does not return a useful value, and it *does* change
     *  its argument.
     */
#define byteswap4(x) (\
    bSwap_p = (char *)&x, \
    bSwap_c = bSwap_p[3], bSwap_p[3] = bSwap_p[0], bSwap_p[0] = bSwap_c, \
    bSwap_c = bSwap_p[2], bSwap_p[2] = bSwap_p[1], bSwap_p[1] = bSwap_c)

    /*
     *  These macros reverses the bytes of some common C types.
     *  The same effect could be accomplished with the above macros,
     *  but these make the code easier to read, and easier to maintain
     *  if we ever go to some non-standard architecture.
     */

/*
#define float_swap(x)  byteswap4(x)   This is not robust!  see below.
*/
#define int_swap(x)    byteswap4(x)
#define long_swap(x)   byteswap4(x)
#define short_swap(x)  byteswap2(x)
#define u_long_swap(x) byteswap4(x)

   /*
    *  The canonical_2bytes macro maps a 2-byte object into the data
    *  endian format.  This macro is implemented like, and should be called
    *  like, a call-by-value routine.  It returns a value, and it does *not*
    *  change its argument.
    */
#if (MACHINE_ENDIAN == FILE_ENDIAN)
#define canonical_2bytes(bytes) (bytes)
#else
#define canonical_2bytes(bytes) \
	  (*((short int *) (&bSwap4_In)) = (short int) (bytes), \
	   bSwap4_Out[0] = bSwap4_In[1], \
	   bSwap4_Out[1] = bSwap4_In[0], \
	   *((short int *) (&bSwap4_Out)))
#endif

   /*
    *  The canonical_4bytes macro maps a 4-byte object into the data
    *  endian format.  This macro is implemented like, and should be called
    *  like, a call-by-value routine.  It returns a value, and it does *not*
    *  change its argument.
    */
#if (MACHINE_ENDIAN == FILE_ENDIAN)
#define canonical_4bytes(bytes) (bytes)
#else
#define canonical_4bytes(bytes) \
	  (*((int *) (&bSwap4_In)) = (int) (bytes), \
	   bSwap4_Out[0] = bSwap4_In[3], \
	   bSwap4_Out[1] = bSwap4_In[2], \
	   bSwap4_Out[2] = bSwap4_In[1], \
	   bSwap4_Out[3] = bSwap4_In[0], \
	   *((int *) (&bSwap4_Out)))
#endif

#if 0
/* o-o-o-o-o-o-o-o-o-o-o-o-o-o-o-o-o-o-o-o-o-o-o-o-o-o-o-o-o-o-o-o-o-o-o-o-o-o
Warning: this macro won't work on KSR, which only has 8-byte floats.
The fix will require very machine-dependent code.  For now, inquery
doesn't read or write floats.  Doing so will require knowing how
floats are represented on each arch.

        *  The canonical_float macro maps a float into the data
        *  endian format.  This macro is implemented like, and should be called
        *  like, a call-by-value routine.  It returns a value, and it does *not
        *  change its argument.
 o-o-o-o-o-o-o-o-o-o-o-o-o-o-o-o-o-o-o-o-o-o-o-o-o-o-o-o-o-o-o-o-o-o-o-o-o-o */
    #if (MACHINE_ENDIAN == FILE_ENDIAN)
    #define canonical_float(bytes) (bytes)
    #else
    #define canonical_float(bytes) \
    	  (*((float *) (&bSwap4_In)) = (float) (bytes), \
    	   bSwap4_Out[0] = bSwap4_In[3], \
    	   bSwap4_Out[1] = bSwap4_In[2], \
    	   bSwap4_Out[2] = bSwap4_In[1], \
    	   bSwap4_Out[3] = bSwap4_In[0], \
    	   *((float *) (&bSwap4_Out)))
    #endif
#endif

  
   /*
    *  The canonical_Nbytes macro maps an N-byte object into the data
    *  endian format.  The caller must supply the address and length of
    *  the N-Byte object.  This macro returns a pointer to a memory
    *  location containing the swapped bytes.  The pointer remains valid
    *  until the next call to this macro.
    */
#if (MACHINE_ENDIAN == FILE_ENDIAN)
#define canonical_Nbytes(bytes, num_bytes) (bytes)
#else
#define canonical_Nbytes(bytes, num_bytes) reverse_Nbytes((void *) bytes, num_bytes)
#endif


/* 
These macros convert between machine and file byte order.  They are
analogous to the system calls htonl(), htons(), ntohl, and ntohs,
except that they are in-place (they don't return a value, and they
change their argument).  They are null if no conversion is necessary.
*/

#if (MACHINE_ENDIAN == FILE_ENDIAN)
    #define machinetofile2(a) (a)
    #define machinetofile4(a) (a)
    #define filetomachine2(a) (a)
    #define filetomachine4(a) (a)
#else
    #define machinetofile2(a) byteswap2(a)
    #define machinetofile4(a) byteswap4(a)
    #define filetomachine2(a) byteswap2(a)
    #define filetomachine4(a) byteswap4(a)
#endif

/*
 *  Type Definitions:
 */
typedef enum ORDER {little_endian, big_endian} b_order;


/* Declarations of variables and functions defined in byteorder.c: */

extern char *bSwap_p;		/* Used by byteswap macro */
extern char bSwap_c;		/* Used by byteswap macro */

extern char bSwap4_In[4];	/* Used by canonical_4bytes macro */
extern char bSwap4_Out[4];	/* Used by canonical_4bytes macro */

b_order machine_byte_order();
void correct_byte_order();
void *reverse_Nbytes (void *bytes, Int_t num_bytes);

#endif





